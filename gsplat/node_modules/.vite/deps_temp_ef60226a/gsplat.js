// node_modules/gsplat/dist/index.js
var A = class _A {
  constructor(A2 = 0, Q2 = 0, F2 = 0) {
    this.x = A2, this.y = Q2, this.z = F2;
  }
  equals(A2) {
    return this.x === A2.x && (this.y === A2.y && this.z === A2.z);
  }
  add(Q2) {
    return "number" == typeof Q2 ? new _A(this.x + Q2, this.y + Q2, this.z + Q2) : new _A(this.x + Q2.x, this.y + Q2.y, this.z + Q2.z);
  }
  subtract(Q2) {
    return "number" == typeof Q2 ? new _A(this.x - Q2, this.y - Q2, this.z - Q2) : new _A(this.x - Q2.x, this.y - Q2.y, this.z - Q2.z);
  }
  multiply(Q2) {
    return "number" == typeof Q2 ? new _A(this.x * Q2, this.y * Q2, this.z * Q2) : Q2 instanceof _A ? new _A(this.x * Q2.x, this.y * Q2.y, this.z * Q2.z) : new _A(this.x * Q2.buffer[0] + this.y * Q2.buffer[4] + this.z * Q2.buffer[8] + Q2.buffer[12], this.x * Q2.buffer[1] + this.y * Q2.buffer[5] + this.z * Q2.buffer[9] + Q2.buffer[13], this.x * Q2.buffer[2] + this.y * Q2.buffer[6] + this.z * Q2.buffer[10] + Q2.buffer[14]);
  }
  cross(Q2) {
    const F2 = this.y * Q2.z - this.z * Q2.y, B2 = this.z * Q2.x - this.x * Q2.z, U2 = this.x * Q2.y - this.y * Q2.x;
    return new _A(F2, B2, U2);
  }
  dot(A2) {
    return this.x * A2.x + this.y * A2.y + this.z * A2.z;
  }
  lerp(Q2, F2) {
    return new _A(this.x + (Q2.x - this.x) * F2, this.y + (Q2.y - this.y) * F2, this.z + (Q2.z - this.z) * F2);
  }
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  distanceTo(A2) {
    return Math.sqrt((this.x - A2.x) ** 2 + (this.y - A2.y) ** 2 + (this.z - A2.z) ** 2);
  }
  normalize() {
    const Q2 = this.magnitude();
    return new _A(this.x / Q2, this.y / Q2, this.z / Q2);
  }
  flat() {
    return [this.x, this.y, this.z];
  }
  clone() {
    return new _A(this.x, this.y, this.z);
  }
  toString() {
    return `[${this.flat().join(", ")}]`;
  }
  static One(Q2 = 1) {
    return new _A(Q2, Q2, Q2);
  }
};
var Q = class _Q {
  constructor(A2 = 0, Q2 = 0, F2 = 0, B2 = 1) {
    this.x = A2, this.y = Q2, this.z = F2, this.w = B2;
  }
  equals(A2) {
    return this.x === A2.x && (this.y === A2.y && (this.z === A2.z && this.w === A2.w));
  }
  normalize() {
    const A2 = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    return new _Q(this.x / A2, this.y / A2, this.z / A2, this.w / A2);
  }
  multiply(A2) {
    const F2 = this.w, B2 = this.x, U2 = this.y, l2 = this.z, t2 = A2.w, d2 = A2.x, n2 = A2.y, V2 = A2.z;
    return new _Q(F2 * d2 + B2 * t2 + U2 * V2 - l2 * n2, F2 * n2 - B2 * V2 + U2 * t2 + l2 * d2, F2 * V2 + B2 * n2 - U2 * d2 + l2 * t2, F2 * t2 - B2 * d2 - U2 * n2 - l2 * V2);
  }
  inverse() {
    const A2 = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    return new _Q(-this.x / A2, -this.y / A2, -this.z / A2, this.w / A2);
  }
  apply(F2) {
    const B2 = new _Q(F2.x, F2.y, F2.z, 0), U2 = new _Q(-this.x, -this.y, -this.z, this.w), l2 = this.multiply(B2).multiply(U2);
    return new A(l2.x, l2.y, l2.z);
  }
  flat() {
    return [this.x, this.y, this.z, this.w];
  }
  clone() {
    return new _Q(this.x, this.y, this.z, this.w);
  }
  static FromEuler(A2) {
    const F2 = A2.x / 2, B2 = A2.y / 2, U2 = A2.z / 2, l2 = Math.cos(B2), t2 = Math.sin(B2), d2 = Math.cos(F2), n2 = Math.sin(F2), V2 = Math.cos(U2), Z2 = Math.sin(U2);
    return new _Q(l2 * n2 * V2 + t2 * d2 * Z2, t2 * d2 * V2 - l2 * n2 * Z2, l2 * d2 * Z2 - t2 * n2 * V2, l2 * d2 * V2 + t2 * n2 * Z2);
  }
  toEuler() {
    const Q2 = 2 * (this.w * this.x + this.y * this.z), F2 = 1 - 2 * (this.x * this.x + this.y * this.y), B2 = Math.atan2(Q2, F2);
    let U2;
    const l2 = 2 * (this.w * this.y - this.z * this.x);
    U2 = Math.abs(l2) >= 1 ? Math.sign(l2) * Math.PI / 2 : Math.asin(l2);
    const t2 = 2 * (this.w * this.z + this.x * this.y), d2 = 1 - 2 * (this.y * this.y + this.z * this.z), n2 = Math.atan2(t2, d2);
    return new A(B2, U2, n2);
  }
  static FromMatrix3(A2) {
    const F2 = A2.buffer, B2 = F2[0] + F2[4] + F2[8];
    let U2, l2, t2, d2;
    if (B2 > 0) {
      const A3 = 0.5 / Math.sqrt(B2 + 1);
      d2 = 0.25 / A3, U2 = (F2[7] - F2[5]) * A3, l2 = (F2[2] - F2[6]) * A3, t2 = (F2[3] - F2[1]) * A3;
    } else if (F2[0] > F2[4] && F2[0] > F2[8]) {
      const A3 = 2 * Math.sqrt(1 + F2[0] - F2[4] - F2[8]);
      d2 = (F2[7] - F2[5]) / A3, U2 = 0.25 * A3, l2 = (F2[1] + F2[3]) / A3, t2 = (F2[2] + F2[6]) / A3;
    } else if (F2[4] > F2[8]) {
      const A3 = 2 * Math.sqrt(1 + F2[4] - F2[0] - F2[8]);
      d2 = (F2[2] - F2[6]) / A3, U2 = (F2[1] + F2[3]) / A3, l2 = 0.25 * A3, t2 = (F2[5] + F2[7]) / A3;
    } else {
      const A3 = 2 * Math.sqrt(1 + F2[8] - F2[0] - F2[4]);
      d2 = (F2[3] - F2[1]) / A3, U2 = (F2[2] + F2[6]) / A3, l2 = (F2[5] + F2[7]) / A3, t2 = 0.25 * A3;
    }
    return new _Q(U2, l2, t2, d2);
  }
  static FromAxisAngle(A2, F2) {
    const B2 = F2 / 2, U2 = Math.sin(B2), l2 = Math.cos(B2);
    return new _Q(A2.x * U2, A2.y * U2, A2.z * U2, l2);
  }
  toString() {
    return `[${this.flat().join(", ")}]`;
  }
};
var F = class {
  constructor() {
    const A2 = /* @__PURE__ */ new Map();
    this.addEventListener = (Q2, F2) => {
      A2.has(Q2) || A2.set(Q2, /* @__PURE__ */ new Set()), A2.get(Q2).add(F2);
    }, this.removeEventListener = (Q2, F2) => {
      A2.has(Q2) && A2.get(Q2).delete(F2);
    }, this.hasEventListener = (Q2, F2) => !!A2.has(Q2) && A2.get(Q2).has(F2), this.dispatchEvent = (Q2) => {
      if (A2.has(Q2.type))
        for (const F2 of A2.get(Q2.type))
          F2(Q2);
    };
  }
};
var B = class _B {
  constructor(A2 = 1, Q2 = 0, F2 = 0, B2 = 0, U2 = 0, l2 = 1, t2 = 0, d2 = 0, n2 = 0, V2 = 0, Z2 = 1, e2 = 0, I2 = 0, R2 = 0, a2 = 0, g2 = 1) {
    this.buffer = [A2, Q2, F2, B2, U2, l2, t2, d2, n2, V2, Z2, e2, I2, R2, a2, g2];
  }
  equals(A2) {
    if (this.buffer.length !== A2.buffer.length)
      return false;
    if (this.buffer === A2.buffer)
      return true;
    for (let Q2 = 0; Q2 < this.buffer.length; Q2++)
      if (this.buffer[Q2] !== A2.buffer[Q2])
        return false;
    return true;
  }
  multiply(A2) {
    const Q2 = this.buffer, F2 = A2.buffer;
    return new _B(F2[0] * Q2[0] + F2[1] * Q2[4] + F2[2] * Q2[8] + F2[3] * Q2[12], F2[0] * Q2[1] + F2[1] * Q2[5] + F2[2] * Q2[9] + F2[3] * Q2[13], F2[0] * Q2[2] + F2[1] * Q2[6] + F2[2] * Q2[10] + F2[3] * Q2[14], F2[0] * Q2[3] + F2[1] * Q2[7] + F2[2] * Q2[11] + F2[3] * Q2[15], F2[4] * Q2[0] + F2[5] * Q2[4] + F2[6] * Q2[8] + F2[7] * Q2[12], F2[4] * Q2[1] + F2[5] * Q2[5] + F2[6] * Q2[9] + F2[7] * Q2[13], F2[4] * Q2[2] + F2[5] * Q2[6] + F2[6] * Q2[10] + F2[7] * Q2[14], F2[4] * Q2[3] + F2[5] * Q2[7] + F2[6] * Q2[11] + F2[7] * Q2[15], F2[8] * Q2[0] + F2[9] * Q2[4] + F2[10] * Q2[8] + F2[11] * Q2[12], F2[8] * Q2[1] + F2[9] * Q2[5] + F2[10] * Q2[9] + F2[11] * Q2[13], F2[8] * Q2[2] + F2[9] * Q2[6] + F2[10] * Q2[10] + F2[11] * Q2[14], F2[8] * Q2[3] + F2[9] * Q2[7] + F2[10] * Q2[11] + F2[11] * Q2[15], F2[12] * Q2[0] + F2[13] * Q2[4] + F2[14] * Q2[8] + F2[15] * Q2[12], F2[12] * Q2[1] + F2[13] * Q2[5] + F2[14] * Q2[9] + F2[15] * Q2[13], F2[12] * Q2[2] + F2[13] * Q2[6] + F2[14] * Q2[10] + F2[15] * Q2[14], F2[12] * Q2[3] + F2[13] * Q2[7] + F2[14] * Q2[11] + F2[15] * Q2[15]);
  }
  clone() {
    const A2 = this.buffer;
    return new _B(A2[0], A2[1], A2[2], A2[3], A2[4], A2[5], A2[6], A2[7], A2[8], A2[9], A2[10], A2[11], A2[12], A2[13], A2[14], A2[15]);
  }
  determinant() {
    const A2 = this.buffer;
    return A2[12] * A2[9] * A2[6] * A2[3] - A2[8] * A2[13] * A2[6] * A2[3] - A2[12] * A2[5] * A2[10] * A2[3] + A2[4] * A2[13] * A2[10] * A2[3] + A2[8] * A2[5] * A2[14] * A2[3] - A2[4] * A2[9] * A2[14] * A2[3] - A2[12] * A2[9] * A2[2] * A2[7] + A2[8] * A2[13] * A2[2] * A2[7] + A2[12] * A2[1] * A2[10] * A2[7] - A2[0] * A2[13] * A2[10] * A2[7] - A2[8] * A2[1] * A2[14] * A2[7] + A2[0] * A2[9] * A2[14] * A2[7] + A2[12] * A2[5] * A2[2] * A2[11] - A2[4] * A2[13] * A2[2] * A2[11] - A2[12] * A2[1] * A2[6] * A2[11] + A2[0] * A2[13] * A2[6] * A2[11] + A2[4] * A2[1] * A2[14] * A2[11] - A2[0] * A2[5] * A2[14] * A2[11] - A2[8] * A2[5] * A2[2] * A2[15] + A2[4] * A2[9] * A2[2] * A2[15] + A2[8] * A2[1] * A2[6] * A2[15] - A2[0] * A2[9] * A2[6] * A2[15] - A2[4] * A2[1] * A2[10] * A2[15] + A2[0] * A2[5] * A2[10] * A2[15];
  }
  invert() {
    const A2 = this.buffer, Q2 = this.determinant();
    if (0 === Q2)
      throw new Error("Matrix is not invertible.");
    const F2 = 1 / Q2;
    return new _B(F2 * (A2[5] * A2[10] * A2[15] - A2[5] * A2[11] * A2[14] - A2[9] * A2[6] * A2[15] + A2[9] * A2[7] * A2[14] + A2[13] * A2[6] * A2[11] - A2[13] * A2[7] * A2[10]), F2 * (-A2[1] * A2[10] * A2[15] + A2[1] * A2[11] * A2[14] + A2[9] * A2[2] * A2[15] - A2[9] * A2[3] * A2[14] - A2[13] * A2[2] * A2[11] + A2[13] * A2[3] * A2[10]), F2 * (A2[1] * A2[6] * A2[15] - A2[1] * A2[7] * A2[14] - A2[5] * A2[2] * A2[15] + A2[5] * A2[3] * A2[14] + A2[13] * A2[2] * A2[7] - A2[13] * A2[3] * A2[6]), F2 * (-A2[1] * A2[6] * A2[11] + A2[1] * A2[7] * A2[10] + A2[5] * A2[2] * A2[11] - A2[5] * A2[3] * A2[10] - A2[9] * A2[2] * A2[7] + A2[9] * A2[3] * A2[6]), F2 * (-A2[4] * A2[10] * A2[15] + A2[4] * A2[11] * A2[14] + A2[8] * A2[6] * A2[15] - A2[8] * A2[7] * A2[14] - A2[12] * A2[6] * A2[11] + A2[12] * A2[7] * A2[10]), F2 * (A2[0] * A2[10] * A2[15] - A2[0] * A2[11] * A2[14] - A2[8] * A2[2] * A2[15] + A2[8] * A2[3] * A2[14] + A2[12] * A2[2] * A2[11] - A2[12] * A2[3] * A2[10]), F2 * (-A2[0] * A2[6] * A2[15] + A2[0] * A2[7] * A2[14] + A2[4] * A2[2] * A2[15] - A2[4] * A2[3] * A2[14] - A2[12] * A2[2] * A2[7] + A2[12] * A2[3] * A2[6]), F2 * (A2[0] * A2[6] * A2[11] - A2[0] * A2[7] * A2[10] - A2[4] * A2[2] * A2[11] + A2[4] * A2[3] * A2[10] + A2[8] * A2[2] * A2[7] - A2[8] * A2[3] * A2[6]), F2 * (A2[4] * A2[9] * A2[15] - A2[4] * A2[11] * A2[13] - A2[8] * A2[5] * A2[15] + A2[8] * A2[7] * A2[13] + A2[12] * A2[5] * A2[11] - A2[12] * A2[7] * A2[9]), F2 * (-A2[0] * A2[9] * A2[15] + A2[0] * A2[11] * A2[13] + A2[8] * A2[1] * A2[15] - A2[8] * A2[3] * A2[13] - A2[12] * A2[1] * A2[11] + A2[12] * A2[3] * A2[9]), F2 * (A2[0] * A2[5] * A2[15] - A2[0] * A2[7] * A2[13] - A2[4] * A2[1] * A2[15] + A2[4] * A2[3] * A2[13] + A2[12] * A2[1] * A2[7] - A2[12] * A2[3] * A2[5]), F2 * (-A2[0] * A2[5] * A2[11] + A2[0] * A2[7] * A2[9] + A2[4] * A2[1] * A2[11] - A2[4] * A2[3] * A2[9] - A2[8] * A2[1] * A2[7] + A2[8] * A2[3] * A2[5]), F2 * (-A2[4] * A2[9] * A2[14] + A2[4] * A2[10] * A2[13] + A2[8] * A2[5] * A2[14] - A2[8] * A2[6] * A2[13] - A2[12] * A2[5] * A2[10] + A2[12] * A2[6] * A2[9]), F2 * (A2[0] * A2[9] * A2[14] - A2[0] * A2[10] * A2[13] - A2[8] * A2[1] * A2[14] + A2[8] * A2[2] * A2[13] + A2[12] * A2[1] * A2[10] - A2[12] * A2[2] * A2[9]), F2 * (-A2[0] * A2[5] * A2[14] + A2[0] * A2[6] * A2[13] + A2[4] * A2[1] * A2[14] - A2[4] * A2[2] * A2[13] - A2[12] * A2[1] * A2[6] + A2[12] * A2[2] * A2[5]), F2 * (A2[0] * A2[5] * A2[10] - A2[0] * A2[6] * A2[9] - A2[4] * A2[1] * A2[10] + A2[4] * A2[2] * A2[9] + A2[8] * A2[1] * A2[6] - A2[8] * A2[2] * A2[5]));
  }
  static Compose(A2, Q2, F2) {
    const U2 = Q2.x, l2 = Q2.y, t2 = Q2.z, d2 = Q2.w, n2 = U2 + U2, V2 = l2 + l2, Z2 = t2 + t2, e2 = U2 * n2, I2 = U2 * V2, R2 = U2 * Z2, a2 = l2 * V2, g2 = l2 * Z2, i2 = t2 * Z2, W2 = d2 * n2, c2 = d2 * V2, C2 = d2 * Z2, h2 = F2.x, s2 = F2.y, o2 = F2.z;
    return new _B((1 - (a2 + i2)) * h2, (I2 + C2) * h2, (R2 - c2) * h2, 0, (I2 - C2) * s2, (1 - (e2 + i2)) * s2, (g2 + W2) * s2, 0, (R2 + c2) * o2, (g2 - W2) * o2, (1 - (e2 + a2)) * o2, 0, A2.x, A2.y, A2.z, 1);
  }
  toString() {
    return `[${this.buffer.join(", ")}]`;
  }
};
var U = class extends Event {
  constructor(A2) {
    super("objectAdded"), this.object = A2;
  }
};
var l = class extends Event {
  constructor(A2) {
    super("objectRemoved"), this.object = A2;
  }
};
var t = class extends Event {
  constructor(A2) {
    super("objectChanged"), this.object = A2;
  }
};
var d = class extends F {
  constructor() {
    super(), this.positionChanged = false, this.rotationChanged = false, this.scaleChanged = false, this._position = new A(), this._rotation = new Q(), this._scale = new A(1, 1, 1), this._transform = new B(), this._changeEvent = new t(this), this.update = () => {
    }, this.applyPosition = () => {
      this.position = new A();
    }, this.applyRotation = () => {
      this.rotation = new Q();
    }, this.applyScale = () => {
      this.scale = new A(1, 1, 1);
    };
  }
  _updateMatrix() {
    this._transform = B.Compose(this._position, this._rotation, this._scale);
  }
  get position() {
    return this._position;
  }
  set position(A2) {
    this._position.equals(A2) || (this._position = A2, this.positionChanged = true, this._updateMatrix(), this.dispatchEvent(this._changeEvent));
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(A2) {
    this._rotation.equals(A2) || (this._rotation = A2, this.rotationChanged = true, this._updateMatrix(), this.dispatchEvent(this._changeEvent));
  }
  get scale() {
    return this._scale;
  }
  set scale(A2) {
    this._scale.equals(A2) || (this._scale = A2, this.scaleChanged = true, this._updateMatrix(), this.dispatchEvent(this._changeEvent));
  }
  get forward() {
    let Q2 = new A(0, 0, 1);
    return Q2 = this.rotation.apply(Q2), Q2;
  }
  get transform() {
    return this._transform;
  }
};
var n = class _n {
  constructor(A2 = 1, Q2 = 0, F2 = 0, B2 = 0, U2 = 1, l2 = 0, t2 = 0, d2 = 0, n2 = 1) {
    this.buffer = [A2, Q2, F2, B2, U2, l2, t2, d2, n2];
  }
  equals(A2) {
    if (this.buffer.length !== A2.buffer.length)
      return false;
    if (this.buffer === A2.buffer)
      return true;
    for (let Q2 = 0; Q2 < this.buffer.length; Q2++)
      if (this.buffer[Q2] !== A2.buffer[Q2])
        return false;
    return true;
  }
  multiply(A2) {
    const Q2 = this.buffer, F2 = A2.buffer;
    return new _n(F2[0] * Q2[0] + F2[3] * Q2[1] + F2[6] * Q2[2], F2[1] * Q2[0] + F2[4] * Q2[1] + F2[7] * Q2[2], F2[2] * Q2[0] + F2[5] * Q2[1] + F2[8] * Q2[2], F2[0] * Q2[3] + F2[3] * Q2[4] + F2[6] * Q2[5], F2[1] * Q2[3] + F2[4] * Q2[4] + F2[7] * Q2[5], F2[2] * Q2[3] + F2[5] * Q2[4] + F2[8] * Q2[5], F2[0] * Q2[6] + F2[3] * Q2[7] + F2[6] * Q2[8], F2[1] * Q2[6] + F2[4] * Q2[7] + F2[7] * Q2[8], F2[2] * Q2[6] + F2[5] * Q2[7] + F2[8] * Q2[8]);
  }
  clone() {
    const A2 = this.buffer;
    return new _n(A2[0], A2[1], A2[2], A2[3], A2[4], A2[5], A2[6], A2[7], A2[8]);
  }
  static Eye(A2 = 1) {
    return new _n(A2, 0, 0, 0, A2, 0, 0, 0, A2);
  }
  static Diagonal(A2) {
    return new _n(A2.x, 0, 0, 0, A2.y, 0, 0, 0, A2.z);
  }
  static RotationFromQuaternion(A2) {
    return new _n(1 - 2 * A2.y * A2.y - 2 * A2.z * A2.z, 2 * A2.x * A2.y - 2 * A2.z * A2.w, 2 * A2.x * A2.z + 2 * A2.y * A2.w, 2 * A2.x * A2.y + 2 * A2.z * A2.w, 1 - 2 * A2.x * A2.x - 2 * A2.z * A2.z, 2 * A2.y * A2.z - 2 * A2.x * A2.w, 2 * A2.x * A2.z - 2 * A2.y * A2.w, 2 * A2.y * A2.z + 2 * A2.x * A2.w, 1 - 2 * A2.x * A2.x - 2 * A2.y * A2.y);
  }
  static RotationFromEuler(A2) {
    const Q2 = Math.cos(A2.x), F2 = Math.sin(A2.x), B2 = Math.cos(A2.y), U2 = Math.sin(A2.y), l2 = Math.cos(A2.z), t2 = Math.sin(A2.z);
    return new _n(...[B2 * l2 + U2 * F2 * t2, -B2 * t2 + U2 * F2 * l2, U2 * Q2, Q2 * t2, Q2 * l2, -F2, -U2 * l2 + B2 * F2 * t2, U2 * t2 + B2 * F2 * l2, B2 * Q2]);
  }
  toString() {
    return `[${this.buffer.join(", ")}]`;
  }
};
var V = class _V {
  constructor(A2 = 0, F2 = null, B2 = null, U2 = null, l2 = null) {
    this.changed = false, this.detached = false, this._vertexCount = A2, this._positions = F2 || new Float32Array(0), this._rotations = B2 || new Float32Array(0), this._scales = U2 || new Float32Array(0), this._colors = l2 || new Uint8Array(0), this._selection = new Uint8Array(this.vertexCount), this.translate = (A3) => {
      for (let Q2 = 0; Q2 < this.vertexCount; Q2++)
        this.positions[3 * Q2 + 0] += A3.x, this.positions[3 * Q2 + 1] += A3.y, this.positions[3 * Q2 + 2] += A3.z;
      this.changed = true;
    }, this.rotate = (A3) => {
      const F3 = n.RotationFromQuaternion(A3).buffer;
      for (let B3 = 0; B3 < this.vertexCount; B3++) {
        const U3 = this.positions[3 * B3 + 0], l3 = this.positions[3 * B3 + 1], t2 = this.positions[3 * B3 + 2];
        this.positions[3 * B3 + 0] = F3[0] * U3 + F3[1] * l3 + F3[2] * t2, this.positions[3 * B3 + 1] = F3[3] * U3 + F3[4] * l3 + F3[5] * t2, this.positions[3 * B3 + 2] = F3[6] * U3 + F3[7] * l3 + F3[8] * t2;
        const d2 = new Q(this.rotations[4 * B3 + 1], this.rotations[4 * B3 + 2], this.rotations[4 * B3 + 3], this.rotations[4 * B3 + 0]), n2 = A3.multiply(d2);
        this.rotations[4 * B3 + 1] = n2.x, this.rotations[4 * B3 + 2] = n2.y, this.rotations[4 * B3 + 3] = n2.z, this.rotations[4 * B3 + 0] = n2.w;
      }
      this.changed = true;
    }, this.scale = (A3) => {
      for (let Q2 = 0; Q2 < this.vertexCount; Q2++)
        this.positions[3 * Q2 + 0] *= A3.x, this.positions[3 * Q2 + 1] *= A3.y, this.positions[3 * Q2 + 2] *= A3.z, this.scales[3 * Q2 + 0] *= A3.x, this.scales[3 * Q2 + 1] *= A3.y, this.scales[3 * Q2 + 2] *= A3.z;
      this.changed = true;
    }, this.serialize = () => {
      const A3 = new Uint8Array(this.vertexCount * _V.RowLength), Q2 = new Float32Array(A3.buffer), F3 = new Uint8Array(A3.buffer);
      for (let A4 = 0; A4 < this.vertexCount; A4++)
        Q2[8 * A4 + 0] = this.positions[3 * A4 + 0], Q2[8 * A4 + 1] = this.positions[3 * A4 + 1], Q2[8 * A4 + 2] = this.positions[3 * A4 + 2], F3[32 * A4 + 24 + 0] = this.colors[4 * A4 + 0], F3[32 * A4 + 24 + 1] = this.colors[4 * A4 + 1], F3[32 * A4 + 24 + 2] = this.colors[4 * A4 + 2], F3[32 * A4 + 24 + 3] = this.colors[4 * A4 + 3], Q2[8 * A4 + 3 + 0] = this.scales[3 * A4 + 0], Q2[8 * A4 + 3 + 1] = this.scales[3 * A4 + 1], Q2[8 * A4 + 3 + 2] = this.scales[3 * A4 + 2], F3[32 * A4 + 28 + 0] = 128 * this.rotations[4 * A4 + 0] + 128 & 255, F3[32 * A4 + 28 + 1] = 128 * this.rotations[4 * A4 + 1] + 128 & 255, F3[32 * A4 + 28 + 2] = 128 * this.rotations[4 * A4 + 2] + 128 & 255, F3[32 * A4 + 28 + 3] = 128 * this.rotations[4 * A4 + 3] + 128 & 255;
      return A3;
    }, this.reattach = (A3, Q2, F3, B3, U3) => {
      console.assert(A3.byteLength === 3 * this.vertexCount * 4, `Expected ${3 * this.vertexCount * 4} bytes, got ${A3.byteLength} bytes`), this._positions = new Float32Array(A3), this._rotations = new Float32Array(Q2), this._scales = new Float32Array(F3), this._colors = new Uint8Array(B3), this._selection = new Uint8Array(U3), this.detached = false;
    };
  }
  static Deserialize(A2) {
    const Q2 = A2.length / _V.RowLength, F2 = new Float32Array(3 * Q2), B2 = new Float32Array(4 * Q2), U2 = new Float32Array(3 * Q2), l2 = new Uint8Array(4 * Q2), t2 = new Float32Array(A2.buffer), d2 = new Uint8Array(A2.buffer);
    for (let A3 = 0; A3 < Q2; A3++)
      F2[3 * A3 + 0] = t2[8 * A3 + 0], F2[3 * A3 + 1] = t2[8 * A3 + 1], F2[3 * A3 + 2] = t2[8 * A3 + 2], B2[4 * A3 + 0] = (d2[32 * A3 + 28 + 0] - 128) / 128, B2[4 * A3 + 1] = (d2[32 * A3 + 28 + 1] - 128) / 128, B2[4 * A3 + 2] = (d2[32 * A3 + 28 + 2] - 128) / 128, B2[4 * A3 + 3] = (d2[32 * A3 + 28 + 3] - 128) / 128, U2[3 * A3 + 0] = t2[8 * A3 + 3 + 0], U2[3 * A3 + 1] = t2[8 * A3 + 3 + 1], U2[3 * A3 + 2] = t2[8 * A3 + 3 + 2], l2[4 * A3 + 0] = d2[32 * A3 + 24 + 0], l2[4 * A3 + 1] = d2[32 * A3 + 24 + 1], l2[4 * A3 + 2] = d2[32 * A3 + 24 + 2], l2[4 * A3 + 3] = d2[32 * A3 + 24 + 3];
    return new _V(Q2, F2, B2, U2, l2);
  }
  get vertexCount() {
    return this._vertexCount;
  }
  get positions() {
    return this._positions;
  }
  get rotations() {
    return this._rotations;
  }
  get scales() {
    return this._scales;
  }
  get colors() {
    return this._colors;
  }
  get selection() {
    return this._selection;
  }
};
V.RowLength = 32;
var Z = class extends d {
  constructor(F2 = void 0) {
    super(), this.selectedChanged = false, this._selected = false, this._data = F2 || new V(), this.applyPosition = () => {
      this.data.translate(this.position), this.position = new A();
    }, this.applyRotation = () => {
      this.data.rotate(this.rotation), this.rotation = new Q();
    }, this.applyScale = () => {
      this.data.scale(this.scale), this.scale = new A(1, 1, 1);
    };
  }
  saveToFile(A2 = null) {
    if (!document)
      return;
    if (!A2) {
      const Q3 = /* @__PURE__ */ new Date();
      A2 = `splat-${Q3.getFullYear()}-${Q3.getMonth() + 1}-${Q3.getDate()}.splat`;
    }
    this.applyRotation(), this.applyScale(), this.applyPosition();
    const Q2 = this.data.serialize(), F2 = new Blob([Q2], { type: "application/octet-stream" }), B2 = document.createElement("a");
    B2.download = A2, B2.href = URL.createObjectURL(F2), B2.click();
  }
  get data() {
    return this._data;
  }
  get selected() {
    return this._selected;
  }
  set selected(A2) {
    this._selected !== A2 && (this._selected = A2, this.selectedChanged = true, this.dispatchEvent(this._changeEvent));
  }
};
var e = class {
  constructor() {
    this._fx = 1132, this._fy = 1132, this._near = 0.1, this._far = 100, this._width = 512, this._height = 512, this._projectionMatrix = new B(), this._viewMatrix = new B(), this._viewProj = new B(), this._updateProjectionMatrix = () => {
      this._projectionMatrix = new B(2 * this.fx / this.width, 0, 0, 0, 0, -2 * this.fy / this.height, 0, 0, 0, 0, this.far / (this.far - this.near), 1, 0, 0, -this.far * this.near / (this.far - this.near), 0), this._viewProj = this.projectionMatrix.multiply(this.viewMatrix);
    }, this.update = (A2, Q2) => {
      const F2 = n.RotationFromQuaternion(Q2).buffer, U2 = A2.flat();
      this._viewMatrix = new B(F2[0], F2[1], F2[2], 0, F2[3], F2[4], F2[5], 0, F2[6], F2[7], F2[8], 0, -U2[0] * F2[0] - U2[1] * F2[3] - U2[2] * F2[6], -U2[0] * F2[1] - U2[1] * F2[4] - U2[2] * F2[7], -U2[0] * F2[2] - U2[1] * F2[5] - U2[2] * F2[8], 1), this._viewProj = this.projectionMatrix.multiply(this.viewMatrix);
    }, this.setSize = (A2, Q2) => {
      this._width = A2, this._height = Q2, this._updateProjectionMatrix();
    };
  }
  get fx() {
    return this._fx;
  }
  set fx(A2) {
    this._fx !== A2 && (this._fx = A2, this._updateProjectionMatrix());
  }
  get fy() {
    return this._fy;
  }
  set fy(A2) {
    this._fy !== A2 && (this._fy = A2, this._updateProjectionMatrix());
  }
  get near() {
    return this._near;
  }
  set near(A2) {
    this._near !== A2 && (this._near = A2, this._updateProjectionMatrix());
  }
  get far() {
    return this._far;
  }
  set far(A2) {
    this._far !== A2 && (this._far = A2, this._updateProjectionMatrix());
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get projectionMatrix() {
    return this._projectionMatrix;
  }
  get viewMatrix() {
    return this._viewMatrix;
  }
  get viewProj() {
    return this._viewProj;
  }
};
var I = class _I {
  constructor(A2 = 0, Q2 = 0, F2 = 0, B2 = 0) {
    this.x = A2, this.y = Q2, this.z = F2, this.w = B2;
  }
  equals(A2) {
    return this.x === A2.x && (this.y === A2.y && (this.z === A2.z && this.w === A2.w));
  }
  add(A2) {
    return "number" == typeof A2 ? new _I(this.x + A2, this.y + A2, this.z + A2, this.w + A2) : new _I(this.x + A2.x, this.y + A2.y, this.z + A2.z, this.w + A2.w);
  }
  subtract(A2) {
    return "number" == typeof A2 ? new _I(this.x - A2, this.y - A2, this.z - A2, this.w - A2) : new _I(this.x - A2.x, this.y - A2.y, this.z - A2.z, this.w - A2.w);
  }
  multiply(A2) {
    return "number" == typeof A2 ? new _I(this.x * A2, this.y * A2, this.z * A2, this.w * A2) : A2 instanceof _I ? new _I(this.x * A2.x, this.y * A2.y, this.z * A2.z, this.w * A2.w) : new _I(this.x * A2.buffer[0] + this.y * A2.buffer[4] + this.z * A2.buffer[8] + this.w * A2.buffer[12], this.x * A2.buffer[1] + this.y * A2.buffer[5] + this.z * A2.buffer[9] + this.w * A2.buffer[13], this.x * A2.buffer[2] + this.y * A2.buffer[6] + this.z * A2.buffer[10] + this.w * A2.buffer[14], this.x * A2.buffer[3] + this.y * A2.buffer[7] + this.z * A2.buffer[11] + this.w * A2.buffer[15]);
  }
  dot(A2) {
    return this.x * A2.x + this.y * A2.y + this.z * A2.z + this.w * A2.w;
  }
  lerp(A2, Q2) {
    return new _I(this.x + (A2.x - this.x) * Q2, this.y + (A2.y - this.y) * Q2, this.z + (A2.z - this.z) * Q2, this.w + (A2.w - this.w) * Q2);
  }
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  distanceTo(A2) {
    return Math.sqrt((this.x - A2.x) ** 2 + (this.y - A2.y) ** 2 + (this.z - A2.z) ** 2 + (this.w - A2.w) ** 2);
  }
  normalize() {
    const A2 = this.magnitude();
    return new _I(this.x / A2, this.y / A2, this.z / A2, this.w / A2);
  }
  flat() {
    return [this.x, this.y, this.z, this.w];
  }
  clone() {
    return new _I(this.x, this.y, this.z, this.w);
  }
  toString() {
    return `[${this.flat().join(", ")}]`;
  }
};
var R = class extends d {
  constructor(Q2 = void 0) {
    super(), this._data = Q2 || new e(), this._position = new A(0, 0, -5), this.update = () => {
      this.data.update(this.position, this.rotation);
    }, this.screenPointToRay = (Q3, F2) => {
      const B2 = new I(Q3, F2, -1, 1), U2 = this._data.projectionMatrix.invert(), l2 = B2.multiply(U2), t2 = this._data.viewMatrix.invert(), d2 = l2.multiply(t2);
      return new A(d2.x / d2.w, d2.y / d2.w, d2.z / d2.w).subtract(this.position).normalize();
    };
  }
  get data() {
    return this._data;
  }
};
var a = class extends F {
  constructor() {
    super(), this._objects = [], this.addObject = (A2) => {
      this.objects.push(A2), this.dispatchEvent(new U(A2));
    }, this.removeObject = (A2) => {
      const Q2 = this.objects.indexOf(A2);
      if (Q2 < 0)
        throw new Error("Object not found in scene");
      this.objects.splice(Q2, 1), this.dispatchEvent(new l(A2));
    }, this.findObject = (A2) => {
      for (const Q2 of this.objects)
        if (A2(Q2))
          return Q2;
    }, this.findObjectOfType = (A2) => {
      for (const Q2 of this.objects)
        if (Q2 instanceof A2)
          return Q2;
    }, this.reset = () => {
      const A2 = this.objects.slice();
      for (const Q2 of A2)
        this.removeObject(Q2);
    }, this.reset();
  }
  saveToFile(A2 = null) {
    if (!document)
      return;
    if (!A2) {
      const Q3 = /* @__PURE__ */ new Date();
      A2 = `scene-${Q3.getFullYear()}-${Q3.getMonth() + 1}-${Q3.getDate()}.splat`;
    }
    const Q2 = [];
    let F2 = 0;
    for (const A3 of this.objects)
      if (A3.applyRotation(), A3.applyScale(), A3.applyPosition(), A3 instanceof Z) {
        const B3 = A3.data.serialize();
        Q2.push(B3), F2 += A3.data.vertexCount;
      }
    const B2 = new Uint8Array(F2 * V.RowLength);
    let U2 = 0;
    for (const A3 of Q2)
      B2.set(A3, U2), U2 += A3.length;
    const l2 = new Blob([B2.buffer], { type: "application/octet-stream" }), t2 = document.createElement("a");
    t2.download = A2, t2.href = URL.createObjectURL(l2), t2.click();
  }
  get objects() {
    return this._objects;
  }
};
var g = class {
  static async LoadAsync(A2, Q2, F2, B2 = false) {
    const U2 = await fetch(A2, { mode: "cors", credentials: "omit", cache: B2 ? "force-cache" : "default" });
    if (200 != U2.status)
      throw new Error(U2.status + " Unable to load " + U2.url);
    const l2 = U2.body.getReader(), t2 = parseInt(U2.headers.get("content-length")), d2 = new Uint8Array(t2);
    let n2 = 0;
    for (; ; ) {
      const { done: A3, value: Q3 } = await l2.read();
      if (A3)
        break;
      d2.set(Q3, n2), n2 += Q3.length, null == F2 || F2(n2 / t2);
    }
    const e2 = V.Deserialize(d2), I2 = new Z(e2);
    return Q2.addObject(I2), I2;
  }
  static async LoadFromFileAsync(A2, Q2, F2) {
    const B2 = new FileReader();
    let U2 = new Z();
    return B2.onload = (A3) => {
      const F3 = new Uint8Array(A3.target.result), B3 = V.Deserialize(F3);
      U2 = new Z(B3), Q2.addObject(U2);
    }, B2.onprogress = (A3) => {
      null == F2 || F2(A3.loaded / A3.total);
    }, B2.readAsArrayBuffer(A2), await new Promise((A3) => {
      B2.onloadend = () => {
        A3();
      };
    }), U2;
  }
};
var i = class {
  static async LoadAsync(A2, Q2, F2, B2 = "", U2 = false) {
    const l2 = await fetch(A2, { mode: "cors", credentials: "omit", cache: U2 ? "force-cache" : "default" });
    if (200 != l2.status)
      throw new Error(l2.status + " Unable to load " + l2.url);
    const t2 = l2.body.getReader(), d2 = parseInt(l2.headers.get("content-length")), n2 = new Uint8Array(d2);
    let e2 = 0;
    for (; ; ) {
      const { done: A3, value: Q3 } = await t2.read();
      if (A3)
        break;
      n2.set(Q3, e2), e2 += Q3.length, null == F2 || F2(e2 / d2);
    }
    if (112 !== n2[0] || 108 !== n2[1] || 121 !== n2[2] || 10 !== n2[3])
      throw new Error("Invalid PLY file");
    const I2 = new Uint8Array(this._ParsePLYBuffer(n2.buffer, B2)), R2 = V.Deserialize(I2), a2 = new Z(R2);
    return Q2.addObject(a2), a2;
  }
  static async LoadFromFileAsync(A2, Q2, F2, B2 = "") {
    const U2 = new FileReader();
    let l2 = new Z();
    return U2.onload = (A3) => {
      const F3 = new Uint8Array(this._ParsePLYBuffer(A3.target.result, B2)), U3 = V.Deserialize(F3);
      l2 = new Z(U3), Q2.addObject(l2);
    }, U2.onprogress = (A3) => {
      null == F2 || F2(A3.loaded / A3.total);
    }, U2.readAsArrayBuffer(A2), await new Promise((A3) => {
      U2.onloadend = () => {
        A3();
      };
    }), l2;
  }
  static _ParsePLYBuffer(F2, B2) {
    const U2 = new Uint8Array(F2), l2 = new TextDecoder().decode(U2.slice(0, 10240)), t2 = "end_header\n", d2 = l2.indexOf(t2);
    if (d2 < 0)
      throw new Error("Unable to read .ply file header");
    const n2 = parseInt(/element vertex (\d+)\n/.exec(l2)[1]);
    let Z2 = 0;
    const e2 = { double: 8, int: 4, uint: 4, float: 4, short: 2, ushort: 2, uchar: 1 }, I2 = [];
    for (const A2 of l2.slice(0, d2).split("\n").filter((A3) => A3.startsWith("property "))) {
      const [Q2, F3, B3] = A2.split(" ");
      if (I2.push({ name: B3, type: F3, offset: Z2 }), !e2[F3])
        throw new Error(`Unsupported property type: ${F3}`);
      Z2 += e2[F3];
    }
    const R2 = new DataView(F2, d2 + 11), a2 = new ArrayBuffer(V.RowLength * n2), g2 = Q.FromEuler(new A(Math.PI / 2, 0, 0));
    for (let A2 = 0; A2 < n2; A2++) {
      const F3 = new Float32Array(a2, A2 * V.RowLength, 3), U3 = new Float32Array(a2, A2 * V.RowLength + 12, 3), l3 = new Uint8ClampedArray(a2, A2 * V.RowLength + 24, 4), t3 = new Uint8ClampedArray(a2, A2 * V.RowLength + 28, 4);
      let d3 = 255, n3 = 0, e3 = 0, i2 = 0;
      I2.forEach((Q2) => {
        let B3;
        switch (Q2.type) {
          case "float":
            B3 = R2.getFloat32(Q2.offset + A2 * Z2, true);
            break;
          case "int":
            B3 = R2.getInt32(Q2.offset + A2 * Z2, true);
            break;
          default:
            throw new Error(`Unsupported property type: ${Q2.type}`);
        }
        switch (Q2.name) {
          case "x":
            F3[0] = B3;
            break;
          case "y":
            F3[1] = B3;
            break;
          case "z":
            F3[2] = B3;
            break;
          case "scale_0":
            U3[0] = Math.exp(B3);
            break;
          case "scale_1":
            U3[1] = Math.exp(B3);
            break;
          case "scale_2":
            U3[2] = Math.exp(B3);
            break;
          case "red":
            l3[0] = B3;
            break;
          case "green":
            l3[1] = B3;
            break;
          case "blue":
            l3[2] = B3;
            break;
          case "f_dc_0":
            l3[0] = 255 * (0.5 + this.SH_C0 * B3);
            break;
          case "f_dc_1":
            l3[1] = 255 * (0.5 + this.SH_C0 * B3);
            break;
          case "f_dc_2":
            l3[2] = 255 * (0.5 + this.SH_C0 * B3);
            break;
          case "f_dc_3":
            l3[3] = 255 * (0.5 + this.SH_C0 * B3);
            break;
          case "opacity":
            l3[3] = 1 / (1 + Math.exp(-B3)) * 255;
            break;
          case "rot_0":
            d3 = B3;
            break;
          case "rot_1":
            n3 = B3;
            break;
          case "rot_2":
            e3 = B3;
            break;
          case "rot_3":
            i2 = B3;
        }
      });
      let W2 = new Q(n3, e3, i2, d3);
      switch (B2) {
        case "polycam": {
          const A3 = F3[1];
          F3[1] = -F3[2], F3[2] = A3, W2 = g2.multiply(W2);
          break;
        }
        case "":
          break;
        default:
          throw new Error(`Unsupported format: ${B2}`);
      }
      W2 = W2.normalize(), t3[0] = 128 * W2.w + 128, t3[1] = 128 * W2.x + 128, t3[2] = 128 * W2.y + 128, t3[3] = 128 * W2.z + 128;
    }
    return a2;
  }
};
function W(A2, Q2, F2) {
  var B2 = void 0 === Q2 ? null : Q2, U2 = function(A3, Q3) {
    var F3 = atob(A3);
    if (Q3) {
      for (var B3 = new Uint8Array(F3.length), U3 = 0, l3 = F3.length; U3 < l3; ++U3)
        B3[U3] = F3.charCodeAt(U3);
      return String.fromCharCode.apply(null, new Uint16Array(B3.buffer));
    }
    return F3;
  }(A2, void 0 !== F2 && F2), l2 = U2.indexOf("\n", 10) + 1, t2 = U2.substring(l2) + (B2 ? "//# sourceMappingURL=" + B2 : ""), d2 = new Blob([t2], { type: "application/javascript" });
  return URL.createObjectURL(d2);
}
function c(A2, Q2, F2) {
  var B2;
  return function(U2) {
    return B2 = B2 || W(A2, Q2, F2), new Worker(B2, U2);
  };
}
i.SH_C0 = 0.28209479177387814;
var C = c("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgdmFyIGxvYWRXYXNtID0gKCgpID0+IHsKICAgIAogICAgcmV0dXJuICgKICBmdW5jdGlvbihtb2R1bGVBcmcgPSB7fSkgewoKICB2YXIgTW9kdWxlPW1vZHVsZUFyZzt2YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSxyZWFkeVByb21pc2VSZWplY3Q7TW9kdWxlWyJyZWFkeSJdPW5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntyZWFkeVByb21pc2VSZXNvbHZlPXJlc29sdmU7cmVhZHlQcm9taXNlUmVqZWN0PXJlamVjdDt9KTt2YXIgbW9kdWxlT3ZlcnJpZGVzPU9iamVjdC5hc3NpZ24oe30sTW9kdWxlKTt2YXIgc2NyaXB0RGlyZWN0b3J5PSIiO2Z1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCl7aWYoTW9kdWxlWyJsb2NhdGVGaWxlIl0pe3JldHVybiBNb2R1bGVbImxvY2F0ZUZpbGUiXShwYXRoLHNjcmlwdERpcmVjdG9yeSl9cmV0dXJuIHNjcmlwdERpcmVjdG9yeStwYXRofXZhciByZWFkQmluYXJ5O3t7c2NyaXB0RGlyZWN0b3J5PXNlbGYubG9jYXRpb24uaHJlZjt9aWYoc2NyaXB0RGlyZWN0b3J5LmluZGV4T2YoImJsb2I6IikhPT0wKXtzY3JpcHREaXJlY3Rvcnk9c2NyaXB0RGlyZWN0b3J5LnN1YnN0cigwLHNjcmlwdERpcmVjdG9yeS5yZXBsYWNlKC9bPyNdLiovLCIiKS5sYXN0SW5kZXhPZigiLyIpKzEpO31lbHNlIHtzY3JpcHREaXJlY3Rvcnk9IiI7fXt7cmVhZEJpbmFyeT11cmw9Pnt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbigiR0VUIix1cmwsZmFsc2UpO3hoci5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIjt4aHIuc2VuZChudWxsKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKX07fX19TW9kdWxlWyJwcmludCJdfHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO3ZhciBlcnI9TW9kdWxlWyJwcmludEVyciJdfHxjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihNb2R1bGUsbW9kdWxlT3ZlcnJpZGVzKTttb2R1bGVPdmVycmlkZXM9bnVsbDtpZihNb2R1bGVbImFyZ3VtZW50cyJdKU1vZHVsZVsiYXJndW1lbnRzIl07aWYoTW9kdWxlWyJ0aGlzUHJvZ3JhbSJdKU1vZHVsZVsidGhpc1Byb2dyYW0iXTtpZihNb2R1bGVbInF1aXQiXSlNb2R1bGVbInF1aXQiXTt2YXIgd2FzbUJpbmFyeTtpZihNb2R1bGVbIndhc21CaW5hcnkiXSl3YXNtQmluYXJ5PU1vZHVsZVsid2FzbUJpbmFyeSJdO2lmKHR5cGVvZiBXZWJBc3NlbWJseSE9Im9iamVjdCIpe2Fib3J0KCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkIik7fWZ1bmN0aW9uIGludEFycmF5RnJvbUJhc2U2NChzKXt2YXIgZGVjb2RlZD1hdG9iKHMpO3ZhciBieXRlcz1uZXcgVWludDhBcnJheShkZWNvZGVkLmxlbmd0aCk7Zm9yKHZhciBpPTA7aTxkZWNvZGVkLmxlbmd0aDsrK2kpe2J5dGVzW2ldPWRlY29kZWQuY2hhckNvZGVBdChpKTt9cmV0dXJuIGJ5dGVzfWZ1bmN0aW9uIHRyeVBhcnNlQXNEYXRhVVJJKGZpbGVuYW1lKXtpZighaXNEYXRhVVJJKGZpbGVuYW1lKSl7cmV0dXJufXJldHVybiBpbnRBcnJheUZyb21CYXNlNjQoZmlsZW5hbWUuc2xpY2UoZGF0YVVSSVByZWZpeC5sZW5ndGgpKX12YXIgd2FzbU1lbW9yeTt2YXIgQUJPUlQ9ZmFsc2U7dmFyIEhFQVA4LEhFQVBVOCxIRUFQMTYsSEVBUFUxNixIRUFQMzIsSEVBUFUzMixIRUFQRjMyLEhFQVBGNjQ7ZnVuY3Rpb24gdXBkYXRlTWVtb3J5Vmlld3MoKXt2YXIgYj13YXNtTWVtb3J5LmJ1ZmZlcjtNb2R1bGVbIkhFQVA4Il09SEVBUDg9bmV3IEludDhBcnJheShiKTtNb2R1bGVbIkhFQVAxNiJdPUhFQVAxNj1uZXcgSW50MTZBcnJheShiKTtNb2R1bGVbIkhFQVBVOCJdPUhFQVBVOD1uZXcgVWludDhBcnJheShiKTtNb2R1bGVbIkhFQVBVMTYiXT1IRUFQVTE2PW5ldyBVaW50MTZBcnJheShiKTtNb2R1bGVbIkhFQVAzMiJdPUhFQVAzMj1uZXcgSW50MzJBcnJheShiKTtNb2R1bGVbIkhFQVBVMzIiXT1IRUFQVTMyPW5ldyBVaW50MzJBcnJheShiKTtNb2R1bGVbIkhFQVBGMzIiXT1IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkoYik7TW9kdWxlWyJIRUFQRjY0Il09SEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KGIpO312YXIgX19BVFBSRVJVTl9fPVtdO3ZhciBfX0FUSU5JVF9fPVtdO3ZhciBfX0FUUE9TVFJVTl9fPVtdO2Z1bmN0aW9uIHByZVJ1bigpe2lmKE1vZHVsZVsicHJlUnVuIl0pe2lmKHR5cGVvZiBNb2R1bGVbInByZVJ1biJdPT0iZnVuY3Rpb24iKU1vZHVsZVsicHJlUnVuIl09W01vZHVsZVsicHJlUnVuIl1dO3doaWxlKE1vZHVsZVsicHJlUnVuIl0ubGVuZ3RoKXthZGRPblByZVJ1bihNb2R1bGVbInByZVJ1biJdLnNoaWZ0KCkpO319Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBSRVJVTl9fKTt9ZnVuY3Rpb24gaW5pdFJ1bnRpbWUoKXtjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKTt9ZnVuY3Rpb24gcG9zdFJ1bigpe2lmKE1vZHVsZVsicG9zdFJ1biJdKXtpZih0eXBlb2YgTW9kdWxlWyJwb3N0UnVuIl09PSJmdW5jdGlvbiIpTW9kdWxlWyJwb3N0UnVuIl09W01vZHVsZVsicG9zdFJ1biJdXTt3aGlsZShNb2R1bGVbInBvc3RSdW4iXS5sZW5ndGgpe2FkZE9uUG9zdFJ1bihNb2R1bGVbInBvc3RSdW4iXS5zaGlmdCgpKTt9fWNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQT1NUUlVOX18pO31mdW5jdGlvbiBhZGRPblByZVJ1bihjYil7X19BVFBSRVJVTl9fLnVuc2hpZnQoY2IpO31mdW5jdGlvbiBhZGRPbkluaXQoY2Ipe19fQVRJTklUX18udW5zaGlmdChjYik7fWZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYil7X19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKTt9dmFyIHJ1bkRlcGVuZGVuY2llcz0wO3ZhciBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9bnVsbDtmdW5jdGlvbiBhZGRSdW5EZXBlbmRlbmN5KGlkKXtydW5EZXBlbmRlbmNpZXMrKztNb2R1bGVbIm1vbml0b3JSdW5EZXBlbmRlbmNpZXMiXT8uKHJ1bkRlcGVuZGVuY2llcyk7fWZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpe3J1bkRlcGVuZGVuY2llcy0tO01vZHVsZVsibW9uaXRvclJ1bkRlcGVuZGVuY2llcyJdPy4ocnVuRGVwZW5kZW5jaWVzKTtpZihydW5EZXBlbmRlbmNpZXM9PTApe2lmKGRlcGVuZGVuY2llc0Z1bGZpbGxlZCl7dmFyIGNhbGxiYWNrPWRlcGVuZGVuY2llc0Z1bGZpbGxlZDtkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9bnVsbDtjYWxsYmFjaygpO319fWZ1bmN0aW9uIGFib3J0KHdoYXQpe01vZHVsZVsib25BYm9ydCJdPy4od2hhdCk7d2hhdD0iQWJvcnRlZCgiK3doYXQrIikiO2Vycih3aGF0KTtBQk9SVD10cnVlO3doYXQrPSIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uIjt2YXIgZT1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHdoYXQpO3JlYWR5UHJvbWlzZVJlamVjdChlKTt0aHJvdyBlfXZhciBkYXRhVVJJUHJlZml4PSJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsIjt2YXIgaXNEYXRhVVJJPWZpbGVuYW1lPT5maWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpO3ZhciB3YXNtQmluYXJ5RmlsZTt3YXNtQmluYXJ5RmlsZT0iZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LEFHRnpiUUVBQUFBQld3MWdCSDkvZjM4QVlBTi9mMzhBWUFWL2YzOS9md0JnQm45L2YzOS9md0JnQVg4QmYyQUNmMzhBWUFOL2YzOEJmMkFCZndCZ0FBQmdBbjkvQVg5Z0IzOS9mMzkvZjM4QVlBUi9mMzUrQUdBS2YzOS9mMzkvZjM5L2Z3QUNQUW9CWVFGaEFBRUJZUUZpQUFJQllRRmpBQUVCWVFGa0FBVUJZUUZsQUFFQllRRm1BQW9CWVFGbkFBUUJZUUZvQUFVQllRRnBBQUFCWVFGcUFBVURHUmdHQkFjSUJ3Y0pDd2dCQUFFRUJBTURBZ0lBQUFrR0Jnd0VCUUZ3QVJBUUJRY0JBWUFDZ0lBQ0JnZ0Jmd0ZCd0o0RUN3Y1pCZ0ZyQWdBQmJBQU5BVzBBSVFGdUFRQUJid0FYQVhBQUR3a1ZBUUJCQVFzUEVoWU1EZzRnREI4WUdoME1HUnNjQ3ExT0dIRUJBWDhnQWtVRVFDQUFLQUlFSUFFb0FnUkdEd3NnQUNBQlJnUkFRUUVQQ3dKQUlBQW9BZ1FpQWkwQUFDSUFSU0FBSUFFb0FnUWlBUzBBQUNJRFIzSU5BQU5BSUFFdEFBRWhBeUFDTFFBQklnQkZEUUVnQVVFQmFpRUJJQUpCQVdvaEFpQUFJQU5HRFFBTEN5QUFJQU5HQzA4QkFuOUJ1Qm9vQWdBaUFTQUFRUWRxUVhoeElnSnFJUUFDUUNBQ1FRQWdBQ0FCVFJ0RkJFQWdBRDhBUVJCMFRRMEJJQUFRQmcwQkMwSElHa0V3TmdJQVFYOFBDMEc0R2lBQU5nSUFJQUVMQmdBZ0FCQVBDeWtBUWNBYVFRRTJBZ0JCeEJwQkFEWUNBQkFTUWNRYVFid2FLQUlBTmdJQVFid2FRY0FhTmdJQUN3SUFDOUlMQVFkL0FrQWdBRVVOQUNBQVFRaHJJZ0lnQUVFRWF5Z0NBQ0lCUVhoeElnQnFJUVVDUUNBQlFRRnhEUUFnQVVFQ2NVVU5BU0FDSUFJb0FnQWlBV3NpQWtIY0dpZ0NBRWtOQVNBQUlBRnFJUUFDUUFKQVFlQWFLQUlBSUFKSEJFQWdBVUgvQVUwRVFDQUJRUU4ySVFRZ0FpZ0NEQ0lCSUFJb0FnZ2lBMFlFUUVITUdrSE1HaWdDQUVGK0lBUjNjVFlDQUF3RkN5QURJQUUyQWd3Z0FTQUROZ0lJREFRTElBSW9BaGdoQmlBQ0lBSW9BZ3dpQVVjRVFDQUNLQUlJSWdNZ0FUWUNEQ0FCSUFNMkFnZ01Bd3NnQWtFVWFpSUVLQUlBSWdORkJFQWdBaWdDRUNJRFJRMENJQUpCRUdvaEJBc0RRQ0FFSVFjZ0F5SUJRUlJxSWdRb0FnQWlBdzBBSUFGQkVHb2hCQ0FCS0FJUUlnTU5BQXNnQjBFQU5nSUFEQUlMSUFVb0FnUWlBVUVEY1VFRFJ3MENRZFFhSUFBMkFnQWdCU0FCUVg1eE5nSUVJQUlnQUVFQmNqWUNCQ0FGSUFBMkFnQVBDMEVBSVFFTElBWkZEUUFDUUNBQ0tBSWNJZ05CQW5SQi9CeHFJZ1FvQWdBZ0FrWUVRQ0FFSUFFMkFnQWdBUTBCUWRBYVFkQWFLQUlBUVg0Z0EzZHhOZ0lBREFJTElBWkJFRUVVSUFZb0FoQWdBa1liYWlBQk5nSUFJQUZGRFFFTElBRWdCallDR0NBQ0tBSVFJZ01FUUNBQklBTTJBaEFnQXlBQk5nSVlDeUFDS0FJVUlnTkZEUUFnQVNBRE5nSVVJQU1nQVRZQ0dBc2dBaUFGVHcwQUlBVW9BZ1FpQVVFQmNVVU5BQUpBQWtBQ1FBSkFJQUZCQW5GRkJFQkI1Qm9vQWdBZ0JVWUVRRUhrR2lBQ05nSUFRZGdhUWRnYUtBSUFJQUJxSWdBMkFnQWdBaUFBUVFGeU5nSUVJQUpCNEJvb0FnQkhEUVpCMUJwQkFEWUNBRUhnR2tFQU5nSUFEd3RCNEJvb0FnQWdCVVlFUUVIZ0dpQUNOZ0lBUWRRYVFkUWFLQUlBSUFCcUlnQTJBZ0FnQWlBQVFRRnlOZ0lFSUFBZ0Ftb2dBRFlDQUE4TElBRkJlSEVnQUdvaEFDQUJRZjhCVFFSQUlBRkJBM1loQkNBRktBSU1JZ0VnQlNnQ0NDSURSZ1JBUWN3YVFjd2FLQUlBUVg0Z0JIZHhOZ0lBREFVTElBTWdBVFlDRENBQklBTTJBZ2dNQkFzZ0JTZ0NHQ0VHSUFVZ0JTZ0NEQ0lCUndSQVFkd2FLQUlBR2lBRktBSUlJZ01nQVRZQ0RDQUJJQU0yQWdnTUF3c2dCVUVVYWlJRUtBSUFJZ05GQkVBZ0JTZ0NFQ0lEUlEwQ0lBVkJFR29oQkFzRFFDQUVJUWNnQXlJQlFSUnFJZ1FvQWdBaUF3MEFJQUZCRUdvaEJDQUJLQUlRSWdNTkFBc2dCMEVBTmdJQURBSUxJQVVnQVVGK2NUWUNCQ0FDSUFCQkFYSTJBZ1FnQUNBQ2FpQUFOZ0lBREFNTFFRQWhBUXNnQmtVTkFBSkFJQVVvQWh3aUEwRUNkRUg4SEdvaUJDZ0NBQ0FGUmdSQUlBUWdBVFlDQUNBQkRRRkIwQnBCMEJvb0FnQkJmaUFEZDNFMkFnQU1BZ3NnQmtFUVFSUWdCaWdDRUNBRlJodHFJQUUyQWdBZ0FVVU5BUXNnQVNBR05nSVlJQVVvQWhBaUF3UkFJQUVnQXpZQ0VDQURJQUUyQWhnTElBVW9BaFFpQTBVTkFDQUJJQU0yQWhRZ0F5QUJOZ0lZQ3lBQ0lBQkJBWEkyQWdRZ0FDQUNhaUFBTmdJQUlBSkI0Qm9vQWdCSERRQkIxQm9nQURZQ0FBOExJQUJCL3dGTkJFQWdBRUY0Y1VIMEdtb2hBUUovUWN3YUtBSUFJZ05CQVNBQVFRTjJkQ0lBY1VVRVFFSE1HaUFBSUFOeU5nSUFJQUVNQVFzZ0FTZ0NDQXNoQUNBQklBSTJBZ2dnQUNBQ05nSU1JQUlnQVRZQ0RDQUNJQUEyQWdnUEMwRWZJUU1nQUVILy8vOEhUUVJBSUFCQkppQUFRUWgyWnlJQmEzWkJBWEVnQVVFQmRHdEJQbW9oQXdzZ0FpQUROZ0ljSUFKQ0FEY0NFQ0FEUVFKMFFmd2NhaUVCQWtBQ1FBSkFRZEFhS0FJQUlnUkJBU0FEZENJSGNVVUVRRUhRR2lBRUlBZHlOZ0lBSUFFZ0FqWUNBQ0FDSUFFMkFoZ01BUXNnQUVFWklBTkJBWFpyUVFBZ0EwRWZSeHQwSVFNZ0FTZ0NBQ0VCQTBBZ0FTSUVLQUlFUVhoeElBQkdEUUlnQTBFZGRpRUJJQU5CQVhRaEF5QUVJQUZCQkhGcUlnZEJFR29vQWdBaUFRMEFDeUFISUFJMkFoQWdBaUFFTmdJWUN5QUNJQUkyQWd3Z0FpQUNOZ0lJREFFTElBUW9BZ2dpQUNBQ05nSU1JQVFnQWpZQ0NDQUNRUUEyQWhnZ0FpQUVOZ0lNSUFJZ0FEWUNDQXRCN0JwQjdCb29BZ0JCQVdzaUFFRi9JQUFiTmdJQUN3c3BBUUYvSUFFRVFDQUFJUUlEUUNBQ1FRQTZBQUFnQWtFQmFpRUNJQUZCQVdzaUFRMEFDd3NnQUFzY0FDQUFJQUZCQ0NBQ3B5QUNRaUNJcHlBRHB5QURRaUNJcHhBRkMrRURBRUhzRjBHYUNSQUpRZmdYUWJrSVFRRkJBQkFJUVlRWVFiUUlRUUZCZ0g5Qi93QVFBVUdjR0VHdENFRUJRWUIvUWY4QUVBRkJrQmhCcXdoQkFVRUFRZjhCRUFGQnFCaEJpUWhCQWtHQWdINUIvLzhCRUFGQnRCaEJnQWhCQWtFQVFmLy9BeEFCUWNBWVFaZ0lRUVJCZ0lDQWdIaEIvLy8vL3djUUFVSE1HRUdQQ0VFRVFRQkJmeEFCUWRnWVFkY0lRUVJCZ0lDQWdIaEIvLy8vL3djUUFVSGtHRUhPQ0VFRVFRQkJmeEFCUWZBWVFhTUlRb0NBZ0lDQWdJQ0FnSDlDLy8vLy8vLy8vLy8vQUJBUlFmd1lRYUlJUWdCQ2Z4QVJRWWdaUVp3SVFRUVFCRUdVR1VHVENVRUlFQVJCaEE5QjZRZ1FBMEhNRDBHWERSQURRWlFRUVFSQjNBZ1FBa0hnRUVFQ1FmVUlFQUpCckJGQkJFR0VDUkFDUWNnUlFiNElFQWRCOEJGQkFFSFNEQkFBUVpnU1FRQkJ1QTBRQUVIQUVrRUJRZkFNRUFCQjZCSkJBa0dmQ1JBQVFaQVRRUU5CdmdrUUFFRzRFMEVFUWVZSkVBQkI0Qk5CQlVHRENoQUFRWWdVUVFSQjNRMFFBRUd3RkVFRlFmc05FQUJCbUJKQkFFSHBDaEFBUWNBU1FRRkJ5QW9RQUVIb0VrRUNRYXNMRUFCQmtCTkJBMEdKQ3hBQVFiZ1RRUVJCc1F3UUFFSGdFMEVGUVk4TUVBQkIyQlJCQ0VIdUN4QUFRWUFWUVFsQnpBc1FBRUdvRlVFR1Fha0tFQUJCMEJWQkIwR2lEaEFBQ3lBQUFrQWdBQ2dDQkNBQlJ3MEFJQUFvQWh4QkFVWU5BQ0FBSUFJMkFod0xDNW9CQUNBQVFRRTZBRFVDUUNBQUtBSUVJQUpIRFFBZ0FFRUJPZ0EwQWtBZ0FDZ0NFQ0lDUlFSQUlBQkJBVFlDSkNBQUlBTTJBaGdnQUNBQk5nSVFJQU5CQVVjTkFpQUFLQUl3UVFGR0RRRU1BZ3NnQVNBQ1JnUkFJQUFvQWhnaUFrRUNSZ1JBSUFBZ0F6WUNHQ0FESVFJTElBQW9BakJCQVVjTkFpQUNRUUZHRFFFTUFnc2dBQ0FBS0FJa1FRRnFOZ0lrQ3lBQVFRRTZBRFlMQzEwQkFYOGdBQ2dDRUNJRFJRUkFJQUJCQVRZQ0pDQUFJQUkyQWhnZ0FDQUJOZ0lRRHdzQ1FDQUJJQU5HQkVBZ0FDZ0NHRUVDUncwQklBQWdBallDR0E4TElBQkJBVG9BTmlBQVFRSTJBaGdnQUNBQUtBSWtRUUZxTmdJa0N3c0VBQ0FBQzhZbkFReC9Jd0JCRUdzaUNpUUFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUJCOUFGTkJFQkJ6Qm9vQWdBaUJrRVFJQUJCQzJwQitBTnhJQUJCQzBrYklnVkJBM1lpQUhZaUFVRURjUVJBQWtBZ0FVRi9jMEVCY1NBQWFpSUNRUU4wSWdGQjlCcHFJZ0FnQVVIOEdtb29BZ0FpQVNnQ0NDSURSZ1JBUWN3YUlBWkJmaUFDZDNFMkFnQU1BUXNnQXlBQU5nSU1JQUFnQXpZQ0NBc2dBVUVJYWlFQUlBRWdBa0VEZENJQ1FRTnlOZ0lFSUFFZ0Ftb2lBU0FCS0FJRVFRRnlOZ0lFREFvTElBVkIxQm9vQWdBaUIwME5BU0FCQkVBQ1FFRUNJQUIwSWdKQkFDQUNhM0lnQVNBQWRIRm9JZ0ZCQTNRaUFFSDBHbW9pQWlBQVFmd2FhaWdDQUNJQUtBSUlJZ05HQkVCQnpCb2dCa0YrSUFGM2NTSUdOZ0lBREFFTElBTWdBallDRENBQ0lBTTJBZ2dMSUFBZ0JVRURjallDQkNBQUlBVnFJZ1FnQVVFRGRDSUJJQVZySWdOQkFYSTJBZ1FnQUNBQmFpQUROZ0lBSUFjRVFDQUhRWGh4UWZRYWFpRUJRZUFhS0FJQUlRSUNmeUFHUVFFZ0IwRURkblFpQlhGRkJFQkJ6Qm9nQlNBR2NqWUNBQ0FCREFFTElBRW9BZ2dMSVFVZ0FTQUNOZ0lJSUFVZ0FqWUNEQ0FDSUFFMkFnd2dBaUFGTmdJSUN5QUFRUWhxSVFCQjRCb2dCRFlDQUVIVUdpQUROZ0lBREFvTFFkQWFLQUlBSWd0RkRRRWdDMmhCQW5SQi9CeHFLQUlBSWdJb0FnUkJlSEVnQldzaEJDQUNJUUVEUUFKQUlBRW9BaEFpQUVVRVFDQUJLQUlVSWdCRkRRRUxJQUFvQWdSQmVIRWdCV3NpQVNBRUlBRWdCRWtpQVJzaEJDQUFJQUlnQVJzaEFpQUFJUUVNQVFzTElBSW9BaGdoQ1NBQ0lBSW9BZ3dpQTBjRVFFSGNHaWdDQUJvZ0FpZ0NDQ0lBSUFNMkFnd2dBeUFBTmdJSURBa0xJQUpCRkdvaUFTZ0NBQ0lBUlFSQUlBSW9BaEFpQUVVTkF5QUNRUkJxSVFFTEEwQWdBU0VJSUFBaUEwRVVhaUlCS0FJQUlnQU5BQ0FEUVJCcUlRRWdBeWdDRUNJQURRQUxJQWhCQURZQ0FBd0lDMEYvSVFVZ0FFRy9mMHNOQUNBQVFRdHFJZ0JCZUhFaEJVSFFHaWdDQUNJSVJRMEFRUUFnQldzaEJBSkFBa0FDUUFKL1FRQWdCVUdBQWtrTkFCcEJIeUFGUWYvLy93ZExEUUFhSUFWQkppQUFRUWgyWnlJQWEzWkJBWEVnQUVFQmRHdEJQbW9MSWdkQkFuUkIvQnhxS0FJQUlnRkZCRUJCQUNFQURBRUxRUUFoQUNBRlFSa2dCMEVCZG10QkFDQUhRUjlIRzNRaEFnTkFBa0FnQVNnQ0JFRjRjU0FGYXlJR0lBUlBEUUFnQVNFRElBWWlCQTBBUVFBaEJDQUJJUUFNQXdzZ0FDQUJLQUlVSWdZZ0JpQUJJQUpCSFhaQkJIRnFLQUlRSWdGR0d5QUFJQVliSVFBZ0FrRUJkQ0VDSUFFTkFBc0xJQUFnQTNKRkJFQkJBQ0VEUVFJZ0IzUWlBRUVBSUFCcmNpQUljU0lBUlEwRElBQm9RUUowUWZ3Y2FpZ0NBQ0VBQ3lBQVJRMEJDd05BSUFBb0FnUkJlSEVnQldzaUFpQUVTU0VCSUFJZ0JDQUJHeUVFSUFBZ0F5QUJHeUVESUFBb0FoQWlBUVIvSUFFRklBQW9BaFFMSWdBTkFBc0xJQU5GRFFBZ0JFSFVHaWdDQUNBRmEwOE5BQ0FES0FJWUlRY2dBeUFES0FJTUlnSkhCRUJCM0Jvb0FnQWFJQU1vQWdnaUFDQUNOZ0lNSUFJZ0FEWUNDQXdIQ3lBRFFSUnFJZ0VvQWdBaUFFVUVRQ0FES0FJUUlnQkZEUU1nQTBFUWFpRUJDd05BSUFFaEJpQUFJZ0pCRkdvaUFTZ0NBQ0lBRFFBZ0FrRVFhaUVCSUFJb0FoQWlBQTBBQ3lBR1FRQTJBZ0FNQmdzZ0JVSFVHaWdDQUNJRFRRUkFRZUFhS0FJQUlRQUNRQ0FESUFWcklnRkJFRThFUUNBQUlBVnFJZ0lnQVVFQmNqWUNCQ0FBSUFOcUlBRTJBZ0FnQUNBRlFRTnlOZ0lFREFFTElBQWdBMEVEY2pZQ0JDQUFJQU5xSWdFZ0FTZ0NCRUVCY2pZQ0JFRUFJUUpCQUNFQkMwSFVHaUFCTmdJQVFlQWFJQUkyQWdBZ0FFRUlhaUVBREFnTElBVkIyQm9vQWdBaUFra0VRRUhZR2lBQ0lBVnJJZ0UyQWdCQjVCcEI1Qm9vQWdBaUFDQUZhaUlDTmdJQUlBSWdBVUVCY2pZQ0JDQUFJQVZCQTNJMkFnUWdBRUVJYWlFQURBZ0xRUUFoQUNBRlFTOXFJZ1FDZjBHa0hpZ0NBQVJBUWF3ZUtBSUFEQUVMUWJBZVFuODNBZ0JCcUI1Q2dLQ0FnSUNBQkRjQ0FFR2tIaUFLUVF4cVFYQnhRZGlxMWFvRmN6WUNBRUc0SGtFQU5nSUFRWWdlUVFBMkFnQkJnQ0FMSWdGcUlnWkJBQ0FCYXlJSWNTSUJJQVZORFFkQmhCNG9BZ0FpQXdSQVFmd2RLQUlBSWdjZ0FXb2lDU0FIVFNBRElBbEpjZzBJQ3dKQVFZZ2VMUUFBUVFSeFJRUkFBa0FDUUFKQUFrQkI1Qm9vQWdBaUF3UkFRWXdlSVFBRFFDQURJQUFvQWdBaUIwOEVRQ0FISUFBb0FnUnFJQU5MRFFNTElBQW9BZ2dpQUEwQUN3dEJBQkFMSWdKQmYwWU5BeUFCSVFaQnFCNG9BZ0FpQUVFQmF5SURJQUp4QkVBZ0FTQUNheUFDSUFOcVFRQWdBR3R4YWlFR0N5QUZJQVpQRFFOQmhCNG9BZ0FpQUFSQVFmd2RLQUlBSWdNZ0Jtb2lDQ0FEVFNBQUlBaEpjZzBFQ3lBR0VBc2lBQ0FDUncwQkRBVUxJQVlnQW1zZ0NIRWlCaEFMSWdJZ0FDZ0NBQ0FBS0FJRWFrWU5BU0FDSVFBTElBQkJmMFlOQVNBRlFUQnFJQVpOQkVBZ0FDRUNEQVFMUWF3ZUtBSUFJZ0lnQkNBR2EycEJBQ0FDYTNFaUFoQUxRWDlHRFFFZ0FpQUdhaUVHSUFBaEFnd0RDeUFDUVg5SERRSUxRWWdlUVlnZUtBSUFRUVJ5TmdJQUN5QUJFQXNpQWtGL1JrRUFFQXNpQUVGL1JuSWdBQ0FDVFhJTkJTQUFJQUpySWdZZ0JVRW9hazBOQlF0Qi9CMUIvQjBvQWdBZ0Jtb2lBRFlDQUVHQUhpZ0NBQ0FBU1FSQVFZQWVJQUEyQWdBTEFrQkI1Qm9vQWdBaUJBUkFRWXdlSVFBRFFDQUNJQUFvQWdBaUFTQUFLQUlFSWdOcVJnMENJQUFvQWdnaUFBMEFDd3dFQzBIY0dpZ0NBQ0lBUVFBZ0FDQUNUUnRGQkVCQjNCb2dBallDQUF0QkFDRUFRWkFlSUFZMkFnQkJqQjRnQWpZQ0FFSHNHa0YvTmdJQVFmQWFRYVFlS0FJQU5nSUFRWmdlUVFBMkFnQURRQ0FBUVFOMElnRkIvQnBxSUFGQjlCcHFJZ00yQWdBZ0FVR0FHMm9nQXpZQ0FDQUFRUUZxSWdCQklFY05BQXRCMkJvZ0JrRW9heUlBUVhnZ0FtdEJCM0VpQVdzaUF6WUNBRUhrR2lBQklBSnFJZ0UyQWdBZ0FTQURRUUZ5TmdJRUlBQWdBbXBCS0RZQ0JFSG9Ha0cwSGlnQ0FEWUNBQXdFQ3lBQ0lBUk5JQUVnQkV0eURRSWdBQ2dDREVFSWNRMENJQUFnQXlBR2FqWUNCRUhrR2lBRVFYZ2dCR3RCQjNFaUFHb2lBVFlDQUVIWUdrSFlHaWdDQUNBR2FpSUNJQUJySWdBMkFnQWdBU0FBUVFGeU5nSUVJQUlnQkdwQktEWUNCRUhvR2tHMEhpZ0NBRFlDQUF3REMwRUFJUU1NQlF0QkFDRUNEQU1MUWR3YUtBSUFJQUpMQkVCQjNCb2dBallDQUFzZ0FpQUdhaUVCUVl3ZUlRQUNRQUpBQWtBRFFDQUJJQUFvQWdCSEJFQWdBQ2dDQ0NJQURRRU1BZ3NMSUFBdEFBeEJDSEZGRFFFTFFZd2VJUUFEUUFKQUlBUWdBQ2dDQUNJQlR3UkFJQUVnQUNnQ0JHb2lBeUFFU3cwQkN5QUFLQUlJSVFBTUFRc0xRZGdhSUFaQktHc2lBRUY0SUFKclFRZHhJZ0ZySWdnMkFnQkI1Qm9nQVNBQ2FpSUJOZ0lBSUFFZ0NFRUJjallDQkNBQUlBSnFRU2cyQWdSQjZCcEJ0QjRvQWdBMkFnQWdCQ0FEUVNjZ0EydEJCM0ZxUVM5cklnQWdBQ0FFUVJCcVNSc2lBVUViTmdJRUlBRkJsQjRwQWdBM0FoQWdBVUdNSGlrQ0FEY0NDRUdVSGlBQlFRaHFOZ0lBUVpBZUlBWTJBZ0JCakI0Z0FqWUNBRUdZSGtFQU5nSUFJQUZCR0dvaEFBTkFJQUJCQnpZQ0JDQUFRUWhxSVF3Z0FFRUVhaUVBSUF3Z0Ewa05BQXNnQVNBRVJnMENJQUVnQVNnQ0JFRitjVFlDQkNBRUlBRWdCR3NpQWtFQmNqWUNCQ0FCSUFJMkFnQWdBa0gvQVUwRVFDQUNRWGh4UWZRYWFpRUFBbjlCekJvb0FnQWlBVUVCSUFKQkEzWjBJZ0p4UlFSQVFjd2FJQUVnQW5JMkFnQWdBQXdCQ3lBQUtBSUlDeUVCSUFBZ0JEWUNDQ0FCSUFRMkFnd2dCQ0FBTmdJTUlBUWdBVFlDQ0F3REMwRWZJUUFnQWtILy8vOEhUUVJBSUFKQkppQUNRUWgyWnlJQWEzWkJBWEVnQUVFQmRHdEJQbW9oQUFzZ0JDQUFOZ0ljSUFSQ0FEY0NFQ0FBUVFKMFFmd2NhaUVCQWtCQjBCb29BZ0FpQTBFQklBQjBJZ1p4UlFSQVFkQWFJQU1nQm5JMkFnQWdBU0FFTmdJQURBRUxJQUpCR1NBQVFRRjJhMEVBSUFCQkgwY2JkQ0VBSUFFb0FnQWhBd05BSUFNaUFTZ0NCRUY0Y1NBQ1JnMERJQUJCSFhZaEF5QUFRUUYwSVFBZ0FTQURRUVJ4YWlJR0tBSVFJZ01OQUFzZ0JpQUVOZ0lRQ3lBRUlBRTJBaGdnQkNBRU5nSU1JQVFnQkRZQ0NBd0NDeUFBSUFJMkFnQWdBQ0FBS0FJRUlBWnFOZ0lFSUFKQmVDQUNhMEVIY1dvaUJ5QUZRUU55TmdJRUlBRkJlQ0FCYTBFSGNXb2lCQ0FGSUFkcUlnVnJJUVlDUUVIa0dpZ0NBQ0FFUmdSQVFlUWFJQVUyQWdCQjJCcEIyQm9vQWdBZ0Jtb2lBRFlDQUNBRklBQkJBWEkyQWdRTUFRdEI0Qm9vQWdBZ0JFWUVRRUhnR2lBRk5nSUFRZFFhUWRRYUtBSUFJQVpxSWdBMkFnQWdCU0FBUVFGeU5nSUVJQUFnQldvZ0FEWUNBQXdCQ3lBRUtBSUVJZ0pCQTNGQkFVWUVRQ0FDUVhoeElRa0NRQ0FDUWY4QlRRUkFJQVFvQWd3aUFDQUVLQUlJSWdGR0JFQkJ6QnBCekJvb0FnQkJmaUFDUVFOMmQzRTJBZ0FNQWdzZ0FTQUFOZ0lNSUFBZ0FUWUNDQXdCQ3lBRUtBSVlJUWdDUUNBRUlBUW9BZ3dpQUVjRVFFSGNHaWdDQUJvZ0JDZ0NDQ0lCSUFBMkFnd2dBQ0FCTmdJSURBRUxBa0FnQkVFVWFpSUJLQUlBSWdKRkJFQWdCQ2dDRUNJQ1JRMEJJQVJCRUdvaEFRc0RRQ0FCSVFNZ0FpSUFRUlJxSWdFb0FnQWlBZzBBSUFCQkVHb2hBU0FBS0FJUUlnSU5BQXNnQTBFQU5nSUFEQUVMUVFBaEFBc2dDRVVOQUFKQUlBUW9BaHdpQVVFQ2RFSDhIR29pQWlnQ0FDQUVSZ1JBSUFJZ0FEWUNBQ0FBRFFGQjBCcEIwQm9vQWdCQmZpQUJkM0UyQWdBTUFnc2dDRUVRUVJRZ0NDZ0NFQ0FFUmh0cUlBQTJBZ0FnQUVVTkFRc2dBQ0FJTmdJWUlBUW9BaEFpQVFSQUlBQWdBVFlDRUNBQklBQTJBaGdMSUFRb0FoUWlBVVVOQUNBQUlBRTJBaFFnQVNBQU5nSVlDeUFHSUFscUlRWWdCQ0FKYWlJRUtBSUVJUUlMSUFRZ0FrRitjVFlDQkNBRklBWkJBWEkyQWdRZ0JTQUdhaUFHTmdJQUlBWkIvd0ZOQkVBZ0JrRjRjVUgwR21vaEFBSi9RY3dhS0FJQUlnRkJBU0FHUVFOMmRDSUNjVVVFUUVITUdpQUJJQUp5TmdJQUlBQU1BUXNnQUNnQ0NBc2hBU0FBSUFVMkFnZ2dBU0FGTmdJTUlBVWdBRFlDRENBRklBRTJBZ2dNQVF0Qkh5RUNJQVpCLy8vL0IwMEVRQ0FHUVNZZ0JrRUlkbWNpQUd0MlFRRnhJQUJCQVhSclFUNXFJUUlMSUFVZ0FqWUNIQ0FGUWdBM0FoQWdBa0VDZEVIOEhHb2hBUUpBQWtCQjBCb29BZ0FpQUVFQklBSjBJZ054UlFSQVFkQWFJQUFnQTNJMkFnQWdBU0FGTmdJQURBRUxJQVpCR1NBQ1FRRjJhMEVBSUFKQkgwY2JkQ0VDSUFFb0FnQWhBQU5BSUFBaUFTZ0NCRUY0Y1NBR1JnMENJQUpCSFhZaEFDQUNRUUYwSVFJZ0FTQUFRUVJ4YWlJREtBSVFJZ0FOQUFzZ0F5QUZOZ0lRQ3lBRklBRTJBaGdnQlNBRk5nSU1JQVVnQlRZQ0NBd0JDeUFCS0FJSUlnQWdCVFlDRENBQklBVTJBZ2dnQlVFQU5nSVlJQVVnQVRZQ0RDQUZJQUEyQWdnTElBZEJDR29oQUF3RkN5QUJLQUlJSWdBZ0JEWUNEQ0FCSUFRMkFnZ2dCRUVBTmdJWUlBUWdBVFlDRENBRUlBQTJBZ2dMUWRnYUtBSUFJZ0FnQlUwTkFFSFlHaUFBSUFWcklnRTJBZ0JCNUJwQjVCb29BZ0FpQUNBRmFpSUNOZ0lBSUFJZ0FVRUJjallDQkNBQUlBVkJBM0kyQWdRZ0FFRUlhaUVBREFNTFFjZ2FRVEEyQWdCQkFDRUFEQUlMQWtBZ0IwVU5BQUpBSUFNb0Fod2lBRUVDZEVIOEhHb2lBU2dDQUNBRFJnUkFJQUVnQWpZQ0FDQUNEUUZCMEJvZ0NFRitJQUIzY1NJSU5nSUFEQUlMSUFkQkVFRVVJQWNvQWhBZ0EwWWJhaUFDTmdJQUlBSkZEUUVMSUFJZ0J6WUNHQ0FES0FJUUlnQUVRQ0FDSUFBMkFoQWdBQ0FDTmdJWUN5QURLQUlVSWdCRkRRQWdBaUFBTmdJVUlBQWdBallDR0FzQ1FDQUVRUTlOQkVBZ0F5QUVJQVZxSWdCQkEzSTJBZ1FnQUNBRGFpSUFJQUFvQWdSQkFYSTJBZ1FNQVFzZ0F5QUZRUU55TmdJRUlBTWdCV29pQWlBRVFRRnlOZ0lFSUFJZ0JHb2dCRFlDQUNBRVFmOEJUUVJBSUFSQmVIRkI5QnBxSVFBQ2YwSE1HaWdDQUNJQlFRRWdCRUVEZG5RaUJYRkZCRUJCekJvZ0FTQUZjallDQUNBQURBRUxJQUFvQWdnTElRRWdBQ0FDTmdJSUlBRWdBallDRENBQ0lBQTJBZ3dnQWlBQk5nSUlEQUVMUVI4aEFDQUVRZi8vL3dkTkJFQWdCRUVtSUFSQkNIWm5JZ0JyZGtFQmNTQUFRUUYwYTBFK2FpRUFDeUFDSUFBMkFod2dBa0lBTndJUUlBQkJBblJCL0J4cUlRRUNRQUpBSUFoQkFTQUFkQ0lGY1VVRVFFSFFHaUFGSUFoeU5nSUFJQUVnQWpZQ0FBd0JDeUFFUVJrZ0FFRUJkbXRCQUNBQVFSOUhHM1FoQUNBQktBSUFJUVVEUUNBRklnRW9BZ1JCZUhFZ0JFWU5BaUFBUVIxMklRVWdBRUVCZENFQUlBRWdCVUVFY1dvaUJpZ0NFQ0lGRFFBTElBWWdBallDRUFzZ0FpQUJOZ0lZSUFJZ0FqWUNEQ0FDSUFJMkFnZ01BUXNnQVNnQ0NDSUFJQUkyQWd3Z0FTQUNOZ0lJSUFKQkFEWUNHQ0FDSUFFMkFnd2dBaUFBTmdJSUN5QURRUWhxSVFBTUFRc0NRQ0FKUlEwQUFrQWdBaWdDSENJQVFRSjBRZndjYWlJQktBSUFJQUpHQkVBZ0FTQUROZ0lBSUFNTkFVSFFHaUFMUVg0Z0FIZHhOZ0lBREFJTElBbEJFRUVVSUFrb0FoQWdBa1liYWlBRE5nSUFJQU5GRFFFTElBTWdDVFlDR0NBQ0tBSVFJZ0FFUUNBRElBQTJBaEFnQUNBRE5nSVlDeUFDS0FJVUlnQkZEUUFnQXlBQU5nSVVJQUFnQXpZQ0dBc0NRQ0FFUVE5TkJFQWdBaUFFSUFWcUlnQkJBM0kyQWdRZ0FDQUNhaUlBSUFBb0FnUkJBWEkyQWdRTUFRc2dBaUFGUVFOeU5nSUVJQUlnQldvaUF5QUVRUUZ5TmdJRUlBTWdCR29nQkRZQ0FDQUhCRUFnQjBGNGNVSDBHbW9oQUVIZ0dpZ0NBQ0VCQW45QkFTQUhRUU4yZENJRklBWnhSUVJBUWN3YUlBVWdCbkkyQWdBZ0FBd0JDeUFBS0FJSUN5RUZJQUFnQVRZQ0NDQUZJQUUyQWd3Z0FTQUFOZ0lNSUFFZ0JUWUNDQXRCNEJvZ0F6WUNBRUhVR2lBRU5nSUFDeUFDUVFocUlRQUxJQXBCRUdva0FDQUFDeG9BSUFBZ0FTZ0NDQ0FGRUFvRVFDQUJJQUlnQXlBRUVCUUxDemNBSUFBZ0FTZ0NDQ0FGRUFvRVFDQUJJQUlnQXlBRUVCUVBDeUFBS0FJSUlnQWdBU0FDSUFNZ0JDQUZJQUFvQWdBb0FoUVJBd0FMa1FFQUlBQWdBU2dDQ0NBRUVBb0VRQ0FCSUFJZ0F4QVREd3NDUUNBQUlBRW9BZ0FnQkJBS1JRMEFBa0FnQWlBQktBSVFSd1JBSUFFb0FoUWdBa2NOQVFzZ0EwRUJSdzBCSUFGQkFUWUNJQThMSUFFZ0FqWUNGQ0FCSUFNMkFpQWdBU0FCS0FJb1FRRnFOZ0lvQWtBZ0FTZ0NKRUVCUncwQUlBRW9BaGhCQWtjTkFDQUJRUUU2QURZTElBRkJCRFlDTEFzTDhnRUFJQUFnQVNnQ0NDQUVFQW9FUUNBQklBSWdBeEFURHdzQ1FDQUFJQUVvQWdBZ0JCQUtCRUFDUUNBQ0lBRW9BaEJIQkVBZ0FTZ0NGQ0FDUncwQkN5QURRUUZIRFFJZ0FVRUJOZ0lnRHdzZ0FTQUROZ0lnQWtBZ0FTZ0NMRUVFUmcwQUlBRkJBRHNCTkNBQUtBSUlJZ0FnQVNBQ0lBSkJBU0FFSUFBb0FnQW9BaFFSQXdBZ0FTMEFOUVJBSUFGQkF6WUNMQ0FCTFFBMFJRMEJEQU1MSUFGQkJEWUNMQXNnQVNBQ05nSVVJQUVnQVNnQ0tFRUJhallDS0NBQktBSWtRUUZIRFFFZ0FTZ0NHRUVDUncwQklBRkJBVG9BTmc4TElBQW9BZ2dpQUNBQklBSWdBeUFFSUFBb0FnQW9BaGdSQWdBTEN6RUFJQUFnQVNnQ0NFRUFFQW9FUUNBQklBSWdBeEFWRHdzZ0FDZ0NDQ0lBSUFFZ0FpQURJQUFvQWdBb0Fod1JBQUFMR0FBZ0FDQUJLQUlJUVFBUUNnUkFJQUVnQWlBREVCVUxDNEFEQVFSL0l3QkI4QUJySWdJa0FDQUFLQUlBSWdOQkJHc29BZ0FoQkNBRFFRaHJLQUlBSVFVZ0FrSUFOd0pRSUFKQ0FEY0NXQ0FDUWdBM0FtQWdBa0lBTndCbklBSkNBRGNDU0NBQ1FRQTJBa1FnQWtIOEZUWUNRQ0FDSUFBMkFqd2dBaUFCTmdJNElBQWdCV29oQXdKQUlBUWdBVUVBRUFvRVFFRUFJQU1nQlJzaEFBd0JDeUFBSUFOT0JFQWdBa0lBTndBdklBSkNBRGNDR0NBQ1FnQTNBaUFnQWtJQU53SW9JQUpDQURjQ0VDQUNRUUEyQWd3Z0FpQUJOZ0lJSUFJZ0FEWUNCQ0FDSUFRMkFnQWdBa0VCTmdJd0lBUWdBaUFESUFOQkFVRUFJQVFvQWdBb0FoUVJBd0FnQWlnQ0dBMEJDMEVBSVFBZ0JDQUNRVGhxSUFOQkFVRUFJQVFvQWdBb0FoZ1JBZ0FDUUFKQUlBSW9BbHdPQWdBQkFnc2dBaWdDVEVFQUlBSW9BbGhCQVVZYlFRQWdBaWdDVkVFQlJodEJBQ0FDS0FKZ1FRRkdHeUVBREFFTElBSW9BbEJCQVVjRVFDQUNLQUpnRFFFZ0FpZ0NWRUVCUncwQklBSW9BbGhCQVVjTkFRc2dBaWdDU0NFQUN5QUNRZkFBYWlRQUlBQUxtZ0VCQW44akFFRkFhaUlESkFBQ2YwRUJJQUFnQVVFQUVBb05BQnBCQUNBQlJRMEFHa0VBSUFGQnJCWVFIaUlCUlEwQUdpQURRUXhxUVRRUUVCb2dBMEVCTmdJNElBTkJmellDRkNBRElBQTJBaEFnQXlBQk5nSUlJQUVnQTBFSWFpQUNLQUlBUVFFZ0FTZ0NBQ2dDSEJFQUFDQURLQUlnSWdCQkFVWUVRQ0FDSUFNb0FoZzJBZ0FMSUFCQkFVWUxJUVFnQTBGQWF5UUFJQVFMQ2dBZ0FDQUJRUUFRQ2d1QUNnSUlmeUo5UWYvLy8vOEhJUTVCZ0lDQWdIZ2hEMEYvSVFvRFFDQURJQXhHQkVCQkFDRUFJQWxCZ0lBUUVCQWhBVU1BQUlCSElBOGdEbXV5bFNFZEEwQWdBQ0FEUmdSQVFRQWhBQ0FJUVFBMkFnQWdBVUVFYXlFQlFRQWhERUVCSVFzRFFDQUxRWUNBQkVaRkJFQWdDQ0FMUVFKMElnSnFJQUVnQW1vb0FnQWdER29pRERZQ0FDQUxRUUZxSVFzTUFRc0xBMEFnQUNBRFJrVUVRQ0FJSUFZZ0FFRUNkR29vQWdCQkFuUnFJZ0VnQVNnQ0FDSUJRUUZxTmdJQUlBY2dBVUVDZEdvZ0FEWUNBQ0FBUVFGcUlRQU1BUXNMQlFKL0lCMGdCaUFBUVFKMGFpSUNLQUlBSUE1cnM1UWlFa01BQUlCUFhTQVNRd0FBQUFCZ2NRUkFJQktwREFFTFFRQUxJUXNnQWlBTE5nSUFJQUVnQzBFQ2RHb2lBaUFDS0FJQVFRRnFOZ0lBSUFCQkFXb2hBQXdCQ3dzRklBUWdERUVNYkdvaUN5b0NBQ0VTSUFzcUFnZ2hIU0FMS2dJRUlTRWdDaUFDSUF4QkFuUWlEV29vQWdBaUMwY0VRQ0FCSUF0QjBBQnNhaUlLS2dJOEloUWdBQ29DUENJVmxDQUtLZ0k0SWhZZ0FDb0NMQ0lZbENBS0tnSXdJaGtnQUNvQ0RDSWFsQ0FBS2dJY0loNGdDaW9DTkNJVGxKS1NraUVwSUJRZ0FDb0NPQ0lmbENBV0lBQXFBaWdpSUpRZ0dTQUFLZ0lJSWlLVUlBQXFBaGdpSXlBVGxKS1NraUVxSUJRZ0FDb0NOQ0lrbENBV0lBQXFBaVFpSlpRZ0dTQUFLZ0lFSWlhVUlBQXFBaFFpSnlBVGxKS1NraUVySUJRZ0FDb0NNQ0lVbENBV0lBQXFBaUFpRnBRZ0dTQUFLZ0lBSWhtVUlBQXFBaEFpS0NBVGxKS1NraUVzSUFvcUFpd2lFeUFWbENBS0tnSW9JaGNnR0pRZ0Npb0NJQ0liSUJxVUlCNGdDaW9DSkNJY2xKS1NraUV0SUJNZ0g1UWdGeUFnbENBYklDS1VJQ01nSEpTU2twSWhMaUFUSUNTVUlCY2dKWlFnR3lBbWxDQW5JQnlVa3BLU0lTOGdFeUFVbENBWElCYVVJQnNnR1pRZ0tDQWNsSktTa2lFd0lBb3FBaHdpRXlBVmxDQUtLZ0lZSWhjZ0dKUWdDaW9DRUNJYklCcVVJQjRnQ2lvQ0ZDSWNsSktTa2lFeElCTWdINVFnRnlBZ2xDQWJJQ0tVSUNNZ0hKU1NrcEloTWlBVElDU1VJQmNnSlpRZ0d5QW1sQ0FuSUJ5VWtwS1NJVE1nRXlBVWxDQVhJQmFVSUJzZ0daUWdLQ0FjbEpLU2tpRVhJQW9xQWd3aUV5QVZsQ0FLS2dJSUloVWdHSlFnQ2lvQ0FDSVlJQnFVSUFvcUFnUWlHaUFlbEpLU2tpRWVJQk1nSDVRZ0ZTQWdsQ0FZSUNLVUlCb2dJNVNTa3BJaEh5QVRJQ1NVSUJVZ0paUWdHQ0FtbENBYUlDZVVrcEtTSVNBZ0V5QVVsQ0FWSUJhVUlCZ2dHWlFnR2lBb2xKS1NraUVXSUFzaENnc2dCaUFOYWdKL0lDNGdIWlFnSHlBU2xDQWhJREtVa3BJZ0twSkRBQUNBUlpRaUZJdERBQUFBVDEwRVFDQVVxQXdCQzBHQWdJQ0FlQXNpQ3pZQ0FDQUxJQTVLSVJBZ0N5QVBTQ0VSUWY4QklRMENRQ0F0SUIyVUlCNGdFcFFnSVNBeGxKS1NJQ21TSWhSREFBQUFBRnNOQUNBd0lCMlVJQllnRXBRZ0lTQVhsSktTSUN5U0lCU1ZRd0FBZ0QrU1F3QUFBRCtVSWhWREFBQUFBR0JGSUJWREFBQ0FQMTFGY2cwQUlDOGdIWlFnSUNBU2xDQWhJRE9Va3BJZ0s1SWdGSlZEQUFDQVA1SkRBQUFBUDVRaUVrTUFBQUFBWUVVZ0VrTUFBSUEvWFVWeURRQUNmeUFTUXdBQWNFR1VJaEpEQUFDQVQxMGdFa01BQUFBQVlIRUVRQ0FTcVF3QkMwRUFDMEVQYkNFTkFuOGdGVU1BQUhCQmxDSVNRd0FBZ0U5ZElCSkRBQUFBQUdCeEJFQWdFcWtNQVF0QkFBc2dEV29oRFFzZ0RpQUxJQkFiSVE0Z0R5QUxJQkViSVE4Z0JTQU1haUFOT2dBQUlBeEJBV29oREF3QkN3c0xDOGNTQWdCQmdBZ0x0aEoxYm5OcFoyNWxaQ0J6YUc5eWRBQjFibk5wWjI1bFpDQnBiblFBWm14dllYUUFkV2x1ZERZMFgzUUFkVzV6YVdkdVpXUWdZMmhoY2dCaWIyOXNBR1Z0YzJOeWFYQjBaVzQ2T25aaGJBQjFibk5wWjI1bFpDQnNiMjVuQUhOMFpEbzZkM04wY21sdVp3QnpkR1E2T25OMGNtbHVad0J6ZEdRNk9uVXhObk4wY21sdVp3QnpkR1E2T25Vek1uTjBjbWx1WndCa2IzVmliR1VBZG05cFpBQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4emFHOXlkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhkVzV6YVdkdVpXUWdjMmh2Y25RK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEdsdWRENEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGRXNXphV2R1WldRZ2FXNTBQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eG1iRzloZEQ0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4ZFdsdWREaGZkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhhVzUwT0Y5MFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4MWFXNTBNVFpmZEQ0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4YVc1ME1UWmZkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhkV2x1ZERZMFgzUStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BHbHVkRFkwWDNRK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEhWcGJuUXpNbDkwUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkenhwYm5Rek1sOTBQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eGphR0Z5UGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkengxYm5OcFoyNWxaQ0JqYUdGeVBnQnpkR1E2T21KaGMybGpYM04wY21sdVp6eDFibk5wWjI1bFpDQmphR0Z5UGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkenh6YVdkdVpXUWdZMmhoY2o0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4Ykc5dVp6NEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGRXNXphV2R1WldRZ2JHOXVaejRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhaRzkxWW14bFBnQk9VM1F6WDE4eU1USmlZWE5wWTE5emRISnBibWRKWTA1VFh6RXhZMmhoY2w5MGNtRnBkSE5KWTBWRlRsTmZPV0ZzYkc5allYUnZja2xqUlVWRlJRQUFBQUNrREFBQVFnY0FBRTVUZEROZlh6SXhNbUpoYzJsalgzTjBjbWx1WjBsb1RsTmZNVEZqYUdGeVgzUnlZV2wwYzBsb1JVVk9VMTg1WVd4c2IyTmhkRzl5U1doRlJVVkZBQUNrREFBQWpBY0FBRTVUZEROZlh6SXhNbUpoYzJsalgzTjBjbWx1WjBsM1RsTmZNVEZqYUdGeVgzUnlZV2wwYzBsM1JVVk9VMTg1WVd4c2IyTmhkRzl5U1hkRlJVVkZBQUNrREFBQTFBY0FBRTVUZEROZlh6SXhNbUpoYzJsalgzTjBjbWx1WjBsRWMwNVRYekV4WTJoaGNsOTBjbUZwZEhOSlJITkZSVTVUWHpsaGJHeHZZMkYwYjNKSlJITkZSVVZGQUFBQXBBd0FBQndJQUFCT1UzUXpYMTh5TVRKaVlYTnBZMTl6ZEhKcGJtZEpSR2xPVTE4eE1XTm9ZWEpmZEhKaGFYUnpTVVJwUlVWT1UxODVZV3hzYjJOaGRHOXlTVVJwUlVWRlJRQUFBS1FNQUFCb0NBQUFUakV3WlcxelkzSnBjSFJsYmpOMllXeEZBQUNrREFBQXRBZ0FBRTR4TUdWdGMyTnlhWEIwWlc0eE1XMWxiVzl5ZVY5MmFXVjNTV05GUlFBQXBBd0FBTkFJQUFCT01UQmxiWE5qY21sd2RHVnVNVEZ0WlcxdmNubGZkbWxsZDBsaFJVVUFBS1FNQUFENENBQUFUakV3WlcxelkzSnBjSFJsYmpFeGJXVnRiM0o1WDNacFpYZEphRVZGQUFDa0RBQUFJQWtBQUU0eE1HVnRjMk55YVhCMFpXNHhNVzFsYlc5eWVWOTJhV1YzU1hORlJRQUFwQXdBQUVnSkFBQk9NVEJsYlhOamNtbHdkR1Z1TVRGdFpXMXZjbmxmZG1sbGQwbDBSVVVBQUtRTUFBQndDUUFBVGpFd1pXMXpZM0pwY0hSbGJqRXhiV1Z0YjNKNVgzWnBaWGRKYVVWRkFBQ2tEQUFBbUFrQUFFNHhNR1Z0YzJOeWFYQjBaVzR4TVcxbGJXOXllVjkyYVdWM1NXcEZSUUFBcEF3QUFNQUpBQUJPTVRCbGJYTmpjbWx3ZEdWdU1URnRaVzF2Y25sZmRtbGxkMGxzUlVVQUFLUU1BQURvQ1FBQVRqRXdaVzF6WTNKcGNIUmxiakV4YldWdGIzSjVYM1pwWlhkSmJVVkZBQUNrREFBQUVBb0FBRTR4TUdWdGMyTnlhWEIwWlc0eE1XMWxiVzl5ZVY5MmFXVjNTWGhGUlFBQXBBd0FBRGdLQUFCT01UQmxiWE5qY21sd2RHVnVNVEZ0WlcxdmNubGZkbWxsZDBsNVJVVUFBS1FNQUFCZ0NnQUFUakV3WlcxelkzSnBjSFJsYmpFeGJXVnRiM0o1WDNacFpYZEpaa1ZGQUFDa0RBQUFpQW9BQUU0eE1HVnRjMk55YVhCMFpXNHhNVzFsYlc5eWVWOTJhV1YzU1dSRlJRQUFwQXdBQUxBS0FBQk9NVEJmWDJONGVHRmlhWFl4TVRaZlgzTm9hVzFmZEhsd1pWOXBibVp2UlFBQUFBRE1EQUFBMkFvQUFEQU5BQUJPTVRCZlgyTjRlR0ZpYVhZeE1UZGZYMk5zWVhOelgzUjVjR1ZmYVc1bWIwVUFBQURNREFBQUNBc0FBUHdLQUFCT01UQmZYMk40ZUdGaWFYWXhNVGRmWDNCaVlYTmxYM1I1Y0dWZmFXNW1iMFVBQUFETURBQUFPQXNBQVB3S0FBQk9NVEJmWDJONGVHRmlhWFl4TVRsZlgzQnZhVzUwWlhKZmRIbHdaVjlwYm1adlJRRE1EQUFBYUFzQUFGd0xBQUFBQUFBQTNBc0FBQUlBQUFBREFBQUFCQUFBQUFVQUFBQUdBQUFBVGpFd1gxOWplSGhoWW1sMk1USXpYMTltZFc1a1lXMWxiblJoYkY5MGVYQmxYMmx1Wm05RkFNd01BQUMwQ3dBQS9Bb0FBSFlBQUFDZ0N3QUE2QXNBQUdJQUFBQ2dDd0FBOUFzQUFHTUFBQUNnQ3dBQUFBd0FBR2dBQUFDZ0N3QUFEQXdBQUdFQUFBQ2dDd0FBR0F3QUFITUFBQUNnQ3dBQUpBd0FBSFFBQUFDZ0N3QUFNQXdBQUdrQUFBQ2dDd0FBUEF3QUFHb0FBQUNnQ3dBQVNBd0FBR3dBQUFDZ0N3QUFWQXdBQUcwQUFBQ2dDd0FBWUF3QUFIZ0FBQUNnQ3dBQWJBd0FBSGtBQUFDZ0N3QUFlQXdBQUdZQUFBQ2dDd0FBaEF3QUFHUUFBQUNnQ3dBQWtBd0FBQUFBQUFBc0N3QUFBZ0FBQUFjQUFBQUVBQUFBQlFBQUFBZ0FBQUFKQUFBQUNnQUFBQXNBQUFBQUFBQUFGQTBBQUFJQUFBQU1BQUFBQkFBQUFBVUFBQUFJQUFBQURRQUFBQTRBQUFBUEFBQUFUakV3WDE5amVIaGhZbWwyTVRJd1gxOXphVjlqYkdGemMxOTBlWEJsWDJsdVptOUZBQUFBQU13TUFBRHNEQUFBTEFzQUFGTjBPWFI1Y0dWZmFXNW1id0FBQUFDa0RBQUFJQTBBUWJnYUN3TkFEd0U9IjtpZighaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSl7d2FzbUJpbmFyeUZpbGU9bG9jYXRlRmlsZSh3YXNtQmluYXJ5RmlsZSk7fWZ1bmN0aW9uIGdldEJpbmFyeVN5bmMoZmlsZSl7aWYoZmlsZT09d2FzbUJpbmFyeUZpbGUmJndhc21CaW5hcnkpe3JldHVybiBuZXcgVWludDhBcnJheSh3YXNtQmluYXJ5KX12YXIgYmluYXJ5PXRyeVBhcnNlQXNEYXRhVVJJKGZpbGUpO2lmKGJpbmFyeSl7cmV0dXJuIGJpbmFyeX1pZihyZWFkQmluYXJ5KXtyZXR1cm4gcmVhZEJpbmFyeShmaWxlKX10aHJvdyAiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWQifWZ1bmN0aW9uIGdldEJpbmFyeVByb21pc2UoYmluYXJ5RmlsZSl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PmdldEJpbmFyeVN5bmMoYmluYXJ5RmlsZSkpfWZ1bmN0aW9uIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIoYmluYXJ5RmlsZSxpbXBvcnRzLHJlY2VpdmVyKXtyZXR1cm4gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKS50aGVuKGJpbmFyeT0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LGltcG9ydHMpKS50aGVuKGluc3RhbmNlPT5pbnN0YW5jZSkudGhlbihyZWNlaXZlcixyZWFzb249PntlcnIoYGZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICR7cmVhc29ufWApO2Fib3J0KHJlYXNvbik7fSl9ZnVuY3Rpb24gaW5zdGFudGlhdGVBc3luYyhiaW5hcnksYmluYXJ5RmlsZSxpbXBvcnRzLGNhbGxiYWNrKXtyZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLGltcG9ydHMsY2FsbGJhY2spfWZ1bmN0aW9uIGNyZWF0ZVdhc20oKXt2YXIgaW5mbz17ImEiOndhc21JbXBvcnRzfTtmdW5jdGlvbiByZWNlaXZlSW5zdGFuY2UoaW5zdGFuY2UsbW9kdWxlKXt3YXNtRXhwb3J0cz1pbnN0YW5jZS5leHBvcnRzO3dhc21NZW1vcnk9d2FzbUV4cG9ydHNbImsiXTt1cGRhdGVNZW1vcnlWaWV3cygpO2FkZE9uSW5pdCh3YXNtRXhwb3J0c1sibCJdKTtyZW1vdmVSdW5EZXBlbmRlbmN5KCk7cmV0dXJuIHdhc21FeHBvcnRzfWFkZFJ1bkRlcGVuZGVuY3koKTtmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpe3JlY2VpdmVJbnN0YW5jZShyZXN1bHRbImluc3RhbmNlIl0pO31pZihNb2R1bGVbImluc3RhbnRpYXRlV2FzbSJdKXt0cnl7cmV0dXJuIE1vZHVsZVsiaW5zdGFudGlhdGVXYXNtIl0oaW5mbyxyZWNlaXZlSW5zdGFuY2UpfWNhdGNoKGUpe2VycihgTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJHtlfWApO3JlYWR5UHJvbWlzZVJlamVjdChlKTt9fWluc3RhbnRpYXRlQXN5bmMod2FzbUJpbmFyeSx3YXNtQmluYXJ5RmlsZSxpbmZvLHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KS5jYXRjaChyZWFkeVByb21pc2VSZWplY3QpO3JldHVybiB7fX12YXIgY2FsbFJ1bnRpbWVDYWxsYmFja3M9Y2FsbGJhY2tzPT57d2hpbGUoY2FsbGJhY2tzLmxlbmd0aD4wKXtjYWxsYmFja3Muc2hpZnQoKShNb2R1bGUpO319O01vZHVsZVsibm9FeGl0UnVudGltZSJdfHx0cnVlO3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9iaWdpbnQ9KHByaW1pdGl2ZVR5cGUsbmFtZSxzaXplLG1pblJhbmdlLG1heFJhbmdlKT0+e307dmFyIGVtYmluZF9pbml0X2NoYXJDb2Rlcz0oKT0+e3ZhciBjb2Rlcz1uZXcgQXJyYXkoMjU2KTtmb3IodmFyIGk9MDtpPDI1NjsrK2kpe2NvZGVzW2ldPVN0cmluZy5mcm9tQ2hhckNvZGUoaSk7fWVtYmluZF9jaGFyQ29kZXM9Y29kZXM7fTt2YXIgZW1iaW5kX2NoYXJDb2Rlczt2YXIgcmVhZExhdGluMVN0cmluZz1wdHI9Pnt2YXIgcmV0PSIiO3ZhciBjPXB0cjt3aGlsZShIRUFQVThbY10pe3JldCs9ZW1iaW5kX2NoYXJDb2Rlc1tIRUFQVThbYysrXV07fXJldHVybiByZXR9O3ZhciBhd2FpdGluZ0RlcGVuZGVuY2llcz17fTt2YXIgcmVnaXN0ZXJlZFR5cGVzPXt9O3ZhciBCaW5kaW5nRXJyb3I7dmFyIHRocm93QmluZGluZ0Vycm9yPW1lc3NhZ2U9Pnt0aHJvdyBuZXcgQmluZGluZ0Vycm9yKG1lc3NhZ2UpfTtmdW5jdGlvbiBzaGFyZWRSZWdpc3RlclR5cGUocmF3VHlwZSxyZWdpc3RlcmVkSW5zdGFuY2Usb3B0aW9ucz17fSl7dmFyIG5hbWU9cmVnaXN0ZXJlZEluc3RhbmNlLm5hbWU7aWYoIXJhd1R5cGUpe3Rocm93QmluZGluZ0Vycm9yKGB0eXBlICIke25hbWV9IiBtdXN0IGhhdmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHR5cGVpZCBwb2ludGVyYCk7fWlmKHJlZ2lzdGVyZWRUeXBlcy5oYXNPd25Qcm9wZXJ0eShyYXdUeXBlKSl7aWYob3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVSZWdpc3RyYXRpb25zKXtyZXR1cm59ZWxzZSB7dGhyb3dCaW5kaW5nRXJyb3IoYENhbm5vdCByZWdpc3RlciB0eXBlICcke25hbWV9JyB0d2ljZWApO319cmVnaXN0ZXJlZFR5cGVzW3Jhd1R5cGVdPXJlZ2lzdGVyZWRJbnN0YW5jZTtpZihhd2FpdGluZ0RlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShyYXdUeXBlKSl7dmFyIGNhbGxiYWNrcz1hd2FpdGluZ0RlcGVuZGVuY2llc1tyYXdUeXBlXTtkZWxldGUgYXdhaXRpbmdEZXBlbmRlbmNpZXNbcmF3VHlwZV07Y2FsbGJhY2tzLmZvckVhY2goY2I9PmNiKCkpO319ZnVuY3Rpb24gcmVnaXN0ZXJUeXBlKHJhd1R5cGUscmVnaXN0ZXJlZEluc3RhbmNlLG9wdGlvbnM9e30pe2lmKCEoImFyZ1BhY2tBZHZhbmNlImluIHJlZ2lzdGVyZWRJbnN0YW5jZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoInJlZ2lzdGVyVHlwZSByZWdpc3RlcmVkSW5zdGFuY2UgcmVxdWlyZXMgYXJnUGFja0FkdmFuY2UiKX1yZXR1cm4gc2hhcmVkUmVnaXN0ZXJUeXBlKHJhd1R5cGUscmVnaXN0ZXJlZEluc3RhbmNlLG9wdGlvbnMpfXZhciBHZW5lcmljV2lyZVR5cGVTaXplPTg7dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2w9KHJhd1R5cGUsbmFtZSx0cnVlVmFsdWUsZmFsc2VWYWx1ZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjpmdW5jdGlvbih3dCl7cmV0dXJuICEhd3R9LCJ0b1dpcmVUeXBlIjpmdW5jdGlvbihkZXN0cnVjdG9ycyxvKXtyZXR1cm4gbz90cnVlVmFsdWU6ZmFsc2VWYWx1ZX0sImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6ZnVuY3Rpb24ocG9pbnRlcil7cmV0dXJuIHRoaXNbImZyb21XaXJlVHlwZSJdKEhFQVBVOFtwb2ludGVyXSl9LGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSk7fTtmdW5jdGlvbiBoYW5kbGVBbGxvY2F0b3JJbml0KCl7T2JqZWN0LmFzc2lnbihIYW5kbGVBbGxvY2F0b3IucHJvdG90eXBlLHtnZXQoaWQpe3JldHVybiB0aGlzLmFsbG9jYXRlZFtpZF19LGhhcyhpZCl7cmV0dXJuIHRoaXMuYWxsb2NhdGVkW2lkXSE9PXVuZGVmaW5lZH0sYWxsb2NhdGUoaGFuZGxlKXt2YXIgaWQ9dGhpcy5mcmVlbGlzdC5wb3AoKXx8dGhpcy5hbGxvY2F0ZWQubGVuZ3RoO3RoaXMuYWxsb2NhdGVkW2lkXT1oYW5kbGU7cmV0dXJuIGlkfSxmcmVlKGlkKXt0aGlzLmFsbG9jYXRlZFtpZF09dW5kZWZpbmVkO3RoaXMuZnJlZWxpc3QucHVzaChpZCk7fX0pO31mdW5jdGlvbiBIYW5kbGVBbGxvY2F0b3IoKXt0aGlzLmFsbG9jYXRlZD1bdW5kZWZpbmVkXTt0aGlzLmZyZWVsaXN0PVtdO312YXIgZW12YWxfaGFuZGxlcz1uZXcgSGFuZGxlQWxsb2NhdG9yO3ZhciBfX2VtdmFsX2RlY3JlZj1oYW5kbGU9PntpZihoYW5kbGU+PWVtdmFsX2hhbmRsZXMucmVzZXJ2ZWQmJjA9PT0tLWVtdmFsX2hhbmRsZXMuZ2V0KGhhbmRsZSkucmVmY291bnQpe2VtdmFsX2hhbmRsZXMuZnJlZShoYW5kbGUpO319O3ZhciBjb3VudF9lbXZhbF9oYW5kbGVzPSgpPT57dmFyIGNvdW50PTA7Zm9yKHZhciBpPWVtdmFsX2hhbmRsZXMucmVzZXJ2ZWQ7aTxlbXZhbF9oYW5kbGVzLmFsbG9jYXRlZC5sZW5ndGg7KytpKXtpZihlbXZhbF9oYW5kbGVzLmFsbG9jYXRlZFtpXSE9PXVuZGVmaW5lZCl7Kytjb3VudDt9fXJldHVybiBjb3VudH07dmFyIGluaXRfZW12YWw9KCk9PntlbXZhbF9oYW5kbGVzLmFsbG9jYXRlZC5wdXNoKHt2YWx1ZTp1bmRlZmluZWR9LHt2YWx1ZTpudWxsfSx7dmFsdWU6dHJ1ZX0se3ZhbHVlOmZhbHNlfSk7ZW12YWxfaGFuZGxlcy5yZXNlcnZlZD1lbXZhbF9oYW5kbGVzLmFsbG9jYXRlZC5sZW5ndGg7TW9kdWxlWyJjb3VudF9lbXZhbF9oYW5kbGVzIl09Y291bnRfZW12YWxfaGFuZGxlczt9O3ZhciBFbXZhbD17dG9WYWx1ZTpoYW5kbGU9PntpZighaGFuZGxlKXt0aHJvd0JpbmRpbmdFcnJvcigiQ2Fubm90IHVzZSBkZWxldGVkIHZhbC4gaGFuZGxlID0gIitoYW5kbGUpO31yZXR1cm4gZW12YWxfaGFuZGxlcy5nZXQoaGFuZGxlKS52YWx1ZX0sdG9IYW5kbGU6dmFsdWU9Pntzd2l0Y2godmFsdWUpe2Nhc2UgdW5kZWZpbmVkOnJldHVybiAxO2Nhc2UgbnVsbDpyZXR1cm4gMjtjYXNlIHRydWU6cmV0dXJuIDM7Y2FzZSBmYWxzZTpyZXR1cm4gNDtkZWZhdWx0OntyZXR1cm4gZW12YWxfaGFuZGxlcy5hbGxvY2F0ZSh7cmVmY291bnQ6MSx2YWx1ZTp2YWx1ZX0pfX19fTtmdW5jdGlvbiBzaW1wbGVSZWFkVmFsdWVGcm9tUG9pbnRlcihwb2ludGVyKXtyZXR1cm4gdGhpc1siZnJvbVdpcmVUeXBlIl0oSEVBUDMyW3BvaW50ZXI+PjJdKX12YXIgX19lbWJpbmRfcmVnaXN0ZXJfZW12YWw9KHJhd1R5cGUsbmFtZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjpoYW5kbGU9Pnt2YXIgcnY9RW12YWwudG9WYWx1ZShoYW5kbGUpO19fZW12YWxfZGVjcmVmKGhhbmRsZSk7cmV0dXJuIHJ2fSwidG9XaXJlVHlwZSI6KGRlc3RydWN0b3JzLHZhbHVlKT0+RW12YWwudG9IYW5kbGUodmFsdWUpLCJhcmdQYWNrQWR2YW5jZSI6R2VuZXJpY1dpcmVUeXBlU2l6ZSwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOnNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSk7fTt2YXIgZmxvYXRSZWFkVmFsdWVGcm9tUG9pbnRlcj0obmFtZSx3aWR0aCk9Pntzd2l0Y2god2lkdGgpe2Nhc2UgNDpyZXR1cm4gZnVuY3Rpb24ocG9pbnRlcil7cmV0dXJuIHRoaXNbImZyb21XaXJlVHlwZSJdKEhFQVBGMzJbcG9pbnRlcj4+Ml0pfTtjYXNlIDg6cmV0dXJuIGZ1bmN0aW9uKHBvaW50ZXIpe3JldHVybiB0aGlzWyJmcm9tV2lyZVR5cGUiXShIRUFQRjY0W3BvaW50ZXI+PjNdKX07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGZsb2F0IHdpZHRoICgke3dpZHRofSk6ICR7bmFtZX1gKX19O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9mbG9hdD0ocmF3VHlwZSxuYW1lLHNpemUpPT57bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsImZyb21XaXJlVHlwZSI6dmFsdWU9PnZhbHVlLCJ0b1dpcmVUeXBlIjooZGVzdHJ1Y3RvcnMsdmFsdWUpPT52YWx1ZSwiYXJnUGFja0FkdmFuY2UiOkdlbmVyaWNXaXJlVHlwZVNpemUsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjpmbG9hdFJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsc2l6ZSksZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KTt9O3ZhciBpbnRlZ2VyUmVhZFZhbHVlRnJvbVBvaW50ZXI9KG5hbWUsd2lkdGgsc2lnbmVkKT0+e3N3aXRjaCh3aWR0aCl7Y2FzZSAxOnJldHVybiBzaWduZWQ/cG9pbnRlcj0+SEVBUDhbcG9pbnRlcj4+MF06cG9pbnRlcj0+SEVBUFU4W3BvaW50ZXI+PjBdO2Nhc2UgMjpyZXR1cm4gc2lnbmVkP3BvaW50ZXI9PkhFQVAxNltwb2ludGVyPj4xXTpwb2ludGVyPT5IRUFQVTE2W3BvaW50ZXI+PjFdO2Nhc2UgNDpyZXR1cm4gc2lnbmVkP3BvaW50ZXI9PkhFQVAzMltwb2ludGVyPj4yXTpwb2ludGVyPT5IRUFQVTMyW3BvaW50ZXI+PjJdO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBpbnRlZ2VyIHdpZHRoICgke3dpZHRofSk6ICR7bmFtZX1gKX19O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyPShwcmltaXRpdmVUeXBlLG5hbWUsc2l6ZSxtaW5SYW5nZSxtYXhSYW5nZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7dmFyIGZyb21XaXJlVHlwZT12YWx1ZT0+dmFsdWU7aWYobWluUmFuZ2U9PT0wKXt2YXIgYml0c2hpZnQ9MzItOCpzaXplO2Zyb21XaXJlVHlwZT12YWx1ZT0+dmFsdWU8PGJpdHNoaWZ0Pj4+Yml0c2hpZnQ7fXZhciBpc1Vuc2lnbmVkVHlwZT1uYW1lLmluY2x1ZGVzKCJ1bnNpZ25lZCIpO3ZhciBjaGVja0Fzc2VydGlvbnM9KHZhbHVlLHRvVHlwZU5hbWUpPT57fTt2YXIgdG9XaXJlVHlwZTtpZihpc1Vuc2lnbmVkVHlwZSl7dG9XaXJlVHlwZT1mdW5jdGlvbihkZXN0cnVjdG9ycyx2YWx1ZSl7Y2hlY2tBc3NlcnRpb25zKHZhbHVlLHRoaXMubmFtZSk7cmV0dXJuIHZhbHVlPj4+MH07fWVsc2Uge3RvV2lyZVR5cGU9ZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsdmFsdWUpe2NoZWNrQXNzZXJ0aW9ucyh2YWx1ZSx0aGlzLm5hbWUpO3JldHVybiB2YWx1ZX07fXJlZ2lzdGVyVHlwZShwcmltaXRpdmVUeXBlLHtuYW1lOm5hbWUsImZyb21XaXJlVHlwZSI6ZnJvbVdpcmVUeXBlLCJ0b1dpcmVUeXBlIjp0b1dpcmVUeXBlLCJhcmdQYWNrQWR2YW5jZSI6R2VuZXJpY1dpcmVUeXBlU2l6ZSwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOmludGVnZXJSZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLHNpemUsbWluUmFuZ2UhPT0wKSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pO307dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3PShyYXdUeXBlLGRhdGFUeXBlSW5kZXgsbmFtZSk9Pnt2YXIgdHlwZU1hcHBpbmc9W0ludDhBcnJheSxVaW50OEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5XTt2YXIgVEE9dHlwZU1hcHBpbmdbZGF0YVR5cGVJbmRleF07ZnVuY3Rpb24gZGVjb2RlTWVtb3J5VmlldyhoYW5kbGUpe3ZhciBzaXplPUhFQVBVMzJbaGFuZGxlPj4yXTt2YXIgZGF0YT1IRUFQVTMyW2hhbmRsZSs0Pj4yXTtyZXR1cm4gbmV3IFRBKEhFQVA4LmJ1ZmZlcixkYXRhLHNpemUpfW5hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLCJmcm9tV2lyZVR5cGUiOmRlY29kZU1lbW9yeVZpZXcsImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6ZGVjb2RlTWVtb3J5Vmlld30se2lnbm9yZUR1cGxpY2F0ZVJlZ2lzdHJhdGlvbnM6dHJ1ZX0pO307ZnVuY3Rpb24gcmVhZFBvaW50ZXIocG9pbnRlcil7cmV0dXJuIHRoaXNbImZyb21XaXJlVHlwZSJdKEhFQVBVMzJbcG9pbnRlcj4+Ml0pfXZhciBzdHJpbmdUb1VURjhBcnJheT0oc3RyLGhlYXAsb3V0SWR4LG1heEJ5dGVzVG9Xcml0ZSk9PntpZighKG1heEJ5dGVzVG9Xcml0ZT4wKSlyZXR1cm4gMDt2YXIgc3RhcnRJZHg9b3V0SWR4O3ZhciBlbmRJZHg9b3V0SWR4K21heEJ5dGVzVG9Xcml0ZS0xO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciB1PXN0ci5jaGFyQ29kZUF0KGkpO2lmKHU+PTU1Mjk2JiZ1PD01NzM0Myl7dmFyIHUxPXN0ci5jaGFyQ29kZUF0KCsraSk7dT02NTUzNisoKHUmMTAyMyk8PDEwKXx1MSYxMDIzO31pZih1PD0xMjcpe2lmKG91dElkeD49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPXU7fWVsc2UgaWYodTw9MjA0Nyl7aWYob3V0SWR4KzE+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT0xOTJ8dT4+NjtoZWFwW291dElkeCsrXT0xMjh8dSY2Mzt9ZWxzZSBpZih1PD02NTUzNSl7aWYob3V0SWR4KzI+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT0yMjR8dT4+MTI7aGVhcFtvdXRJZHgrK109MTI4fHU+PjYmNjM7aGVhcFtvdXRJZHgrK109MTI4fHUmNjM7fWVsc2Uge2lmKG91dElkeCszPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109MjQwfHU+PjE4O2hlYXBbb3V0SWR4KytdPTEyOHx1Pj4xMiY2MztoZWFwW291dElkeCsrXT0xMjh8dT4+NiY2MztoZWFwW291dElkeCsrXT0xMjh8dSY2Mzt9fWhlYXBbb3V0SWR4XT0wO3JldHVybiBvdXRJZHgtc3RhcnRJZHh9O3ZhciBzdHJpbmdUb1VURjg9KHN0cixvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKT0+c3RyaW5nVG9VVEY4QXJyYXkoc3RyLEhFQVBVOCxvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKTt2YXIgbGVuZ3RoQnl0ZXNVVEY4PXN0cj0+e3ZhciBsZW49MDtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgYz1zdHIuY2hhckNvZGVBdChpKTtpZihjPD0xMjcpe2xlbisrO31lbHNlIGlmKGM8PTIwNDcpe2xlbis9Mjt9ZWxzZSBpZihjPj01NTI5NiYmYzw9NTczNDMpe2xlbis9NDsrK2k7fWVsc2Uge2xlbis9Mzt9fXJldHVybiBsZW59O3ZhciBVVEY4RGVjb2Rlcj10eXBlb2YgVGV4dERlY29kZXIhPSJ1bmRlZmluZWQiP25ldyBUZXh0RGVjb2RlcigidXRmOCIpOnVuZGVmaW5lZDt2YXIgVVRGOEFycmF5VG9TdHJpbmc9KGhlYXBPckFycmF5LGlkeCxtYXhCeXRlc1RvUmVhZCk9Pnt2YXIgZW5kSWR4PWlkeCttYXhCeXRlc1RvUmVhZDt2YXIgZW5kUHRyPWlkeDt3aGlsZShoZWFwT3JBcnJheVtlbmRQdHJdJiYhKGVuZFB0cj49ZW5kSWR4KSkrK2VuZFB0cjtpZihlbmRQdHItaWR4PjE2JiZoZWFwT3JBcnJheS5idWZmZXImJlVURjhEZWNvZGVyKXtyZXR1cm4gVVRGOERlY29kZXIuZGVjb2RlKGhlYXBPckFycmF5LnN1YmFycmF5KGlkeCxlbmRQdHIpKX12YXIgc3RyPSIiO3doaWxlKGlkeDxlbmRQdHIpe3ZhciB1MD1oZWFwT3JBcnJheVtpZHgrK107aWYoISh1MCYxMjgpKXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUodTApO2NvbnRpbnVlfXZhciB1MT1oZWFwT3JBcnJheVtpZHgrK10mNjM7aWYoKHUwJjIyNCk9PTE5Mil7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCh1MCYzMSk8PDZ8dTEpO2NvbnRpbnVlfXZhciB1Mj1oZWFwT3JBcnJheVtpZHgrK10mNjM7aWYoKHUwJjI0MCk9PTIyNCl7dTA9KHUwJjE1KTw8MTJ8dTE8PDZ8dTI7fWVsc2Uge3UwPSh1MCY3KTw8MTh8dTE8PDEyfHUyPDw2fGhlYXBPckFycmF5W2lkeCsrXSY2Mzt9aWYodTA8NjU1MzYpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7fWVsc2Uge3ZhciBjaD11MC02NTUzNjtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Y2g+PjEwLDU2MzIwfGNoJjEwMjMpO319cmV0dXJuIHN0cn07dmFyIFVURjhUb1N0cmluZz0ocHRyLG1heEJ5dGVzVG9SZWFkKT0+cHRyP1VURjhBcnJheVRvU3RyaW5nKEhFQVBVOCxwdHIsbWF4Qnl0ZXNUb1JlYWQpOiIiO3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nPShyYXdUeXBlLG5hbWUpPT57bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3ZhciBzdGRTdHJpbmdJc1VURjg9bmFtZT09PSJzdGQ6OnN0cmluZyI7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIih2YWx1ZSl7dmFyIGxlbmd0aD1IRUFQVTMyW3ZhbHVlPj4yXTt2YXIgcGF5bG9hZD12YWx1ZSs0O3ZhciBzdHI7aWYoc3RkU3RyaW5nSXNVVEY4KXt2YXIgZGVjb2RlU3RhcnRQdHI9cGF5bG9hZDtmb3IodmFyIGk9MDtpPD1sZW5ndGg7KytpKXt2YXIgY3VycmVudEJ5dGVQdHI9cGF5bG9hZCtpO2lmKGk9PWxlbmd0aHx8SEVBUFU4W2N1cnJlbnRCeXRlUHRyXT09MCl7dmFyIG1heFJlYWQ9Y3VycmVudEJ5dGVQdHItZGVjb2RlU3RhcnRQdHI7dmFyIHN0cmluZ1NlZ21lbnQ9VVRGOFRvU3RyaW5nKGRlY29kZVN0YXJ0UHRyLG1heFJlYWQpO2lmKHN0cj09PXVuZGVmaW5lZCl7c3RyPXN0cmluZ1NlZ21lbnQ7fWVsc2Uge3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSgwKTtzdHIrPXN0cmluZ1NlZ21lbnQ7fWRlY29kZVN0YXJ0UHRyPWN1cnJlbnRCeXRlUHRyKzE7fX19ZWxzZSB7dmFyIGE9bmV3IEFycmF5KGxlbmd0aCk7Zm9yKHZhciBpPTA7aTxsZW5ndGg7KytpKXthW2ldPVN0cmluZy5mcm9tQ2hhckNvZGUoSEVBUFU4W3BheWxvYWQraV0pO31zdHI9YS5qb2luKCIiKTt9X2ZyZWUodmFsdWUpO3JldHVybiBzdHJ9LCJ0b1dpcmVUeXBlIihkZXN0cnVjdG9ycyx2YWx1ZSl7aWYodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7dmFsdWU9bmV3IFVpbnQ4QXJyYXkodmFsdWUpO312YXIgbGVuZ3RoO3ZhciB2YWx1ZUlzT2ZUeXBlU3RyaW5nPXR5cGVvZiB2YWx1ZT09InN0cmluZyI7aWYoISh2YWx1ZUlzT2ZUeXBlU3RyaW5nfHx2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fHZhbHVlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl8fHZhbHVlIGluc3RhbmNlb2YgSW50OEFycmF5KSl7dGhyb3dCaW5kaW5nRXJyb3IoIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gc3RkOjpzdHJpbmciKTt9aWYoc3RkU3RyaW5nSXNVVEY4JiZ2YWx1ZUlzT2ZUeXBlU3RyaW5nKXtsZW5ndGg9bGVuZ3RoQnl0ZXNVVEY4KHZhbHVlKTt9ZWxzZSB7bGVuZ3RoPXZhbHVlLmxlbmd0aDt9dmFyIGJhc2U9X21hbGxvYyg0K2xlbmd0aCsxKTt2YXIgcHRyPWJhc2UrNDtIRUFQVTMyW2Jhc2U+PjJdPWxlbmd0aDtpZihzdGRTdHJpbmdJc1VURjgmJnZhbHVlSXNPZlR5cGVTdHJpbmcpe3N0cmluZ1RvVVRGOCh2YWx1ZSxwdHIsbGVuZ3RoKzEpO31lbHNlIHtpZih2YWx1ZUlzT2ZUeXBlU3RyaW5nKXtmb3IodmFyIGk9MDtpPGxlbmd0aDsrK2kpe3ZhciBjaGFyQ29kZT12YWx1ZS5jaGFyQ29kZUF0KGkpO2lmKGNoYXJDb2RlPjI1NSl7X2ZyZWUocHRyKTt0aHJvd0JpbmRpbmdFcnJvcigiU3RyaW5nIGhhcyBVVEYtMTYgY29kZSB1bml0cyB0aGF0IGRvIG5vdCBmaXQgaW4gOCBiaXRzIik7fUhFQVBVOFtwdHIraV09Y2hhckNvZGU7fX1lbHNlIHtmb3IodmFyIGk9MDtpPGxlbmd0aDsrK2kpe0hFQVBVOFtwdHIraV09dmFsdWVbaV07fX19aWYoZGVzdHJ1Y3RvcnMhPT1udWxsKXtkZXN0cnVjdG9ycy5wdXNoKF9mcmVlLGJhc2UpO31yZXR1cm4gYmFzZX0sImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6cmVhZFBvaW50ZXIsZGVzdHJ1Y3RvckZ1bmN0aW9uKHB0cil7X2ZyZWUocHRyKTt9fSk7fTt2YXIgVVRGMTZEZWNvZGVyPXR5cGVvZiBUZXh0RGVjb2RlciE9InVuZGVmaW5lZCI/bmV3IFRleHREZWNvZGVyKCJ1dGYtMTZsZSIpOnVuZGVmaW5lZDt2YXIgVVRGMTZUb1N0cmluZz0ocHRyLG1heEJ5dGVzVG9SZWFkKT0+e3ZhciBlbmRQdHI9cHRyO3ZhciBpZHg9ZW5kUHRyPj4xO3ZhciBtYXhJZHg9aWR4K21heEJ5dGVzVG9SZWFkLzI7d2hpbGUoIShpZHg+PW1heElkeCkmJkhFQVBVMTZbaWR4XSkrK2lkeDtlbmRQdHI9aWR4PDwxO2lmKGVuZFB0ci1wdHI+MzImJlVURjE2RGVjb2RlcilyZXR1cm4gVVRGMTZEZWNvZGVyLmRlY29kZShIRUFQVTguc3ViYXJyYXkocHRyLGVuZFB0cikpO3ZhciBzdHI9IiI7Zm9yKHZhciBpPTA7IShpPj1tYXhCeXRlc1RvUmVhZC8yKTsrK2kpe3ZhciBjb2RlVW5pdD1IRUFQMTZbcHRyK2kqMj4+MV07aWYoY29kZVVuaXQ9PTApYnJlYWs7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVVbml0KTt9cmV0dXJuIHN0cn07dmFyIHN0cmluZ1RvVVRGMTY9KHN0cixvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKT0+e21heEJ5dGVzVG9Xcml0ZT8/PTIxNDc0ODM2NDc7aWYobWF4Qnl0ZXNUb1dyaXRlPDIpcmV0dXJuIDA7bWF4Qnl0ZXNUb1dyaXRlLT0yO3ZhciBzdGFydFB0cj1vdXRQdHI7dmFyIG51bUNoYXJzVG9Xcml0ZT1tYXhCeXRlc1RvV3JpdGU8c3RyLmxlbmd0aCoyP21heEJ5dGVzVG9Xcml0ZS8yOnN0ci5sZW5ndGg7Zm9yKHZhciBpPTA7aTxudW1DaGFyc1RvV3JpdGU7KytpKXt2YXIgY29kZVVuaXQ9c3RyLmNoYXJDb2RlQXQoaSk7SEVBUDE2W291dFB0cj4+MV09Y29kZVVuaXQ7b3V0UHRyKz0yO31IRUFQMTZbb3V0UHRyPj4xXT0wO3JldHVybiBvdXRQdHItc3RhcnRQdHJ9O3ZhciBsZW5ndGhCeXRlc1VURjE2PXN0cj0+c3RyLmxlbmd0aCoyO3ZhciBVVEYzMlRvU3RyaW5nPShwdHIsbWF4Qnl0ZXNUb1JlYWQpPT57dmFyIGk9MDt2YXIgc3RyPSIiO3doaWxlKCEoaT49bWF4Qnl0ZXNUb1JlYWQvNCkpe3ZhciB1dGYzMj1IRUFQMzJbcHRyK2kqND4+Ml07aWYodXRmMzI9PTApYnJlYWs7KytpO2lmKHV0ZjMyPj02NTUzNil7dmFyIGNoPXV0ZjMyLTY1NTM2O3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxjaD4+MTAsNTYzMjB8Y2gmMTAyMyk7fWVsc2Uge3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1dGYzMik7fX1yZXR1cm4gc3RyfTt2YXIgc3RyaW5nVG9VVEYzMj0oc3RyLG91dFB0cixtYXhCeXRlc1RvV3JpdGUpPT57bWF4Qnl0ZXNUb1dyaXRlPz89MjE0NzQ4MzY0NztpZihtYXhCeXRlc1RvV3JpdGU8NClyZXR1cm4gMDt2YXIgc3RhcnRQdHI9b3V0UHRyO3ZhciBlbmRQdHI9c3RhcnRQdHIrbWF4Qnl0ZXNUb1dyaXRlLTQ7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIGNvZGVVbml0PXN0ci5jaGFyQ29kZUF0KGkpO2lmKGNvZGVVbml0Pj01NTI5NiYmY29kZVVuaXQ8PTU3MzQzKXt2YXIgdHJhaWxTdXJyb2dhdGU9c3RyLmNoYXJDb2RlQXQoKytpKTtjb2RlVW5pdD02NTUzNisoKGNvZGVVbml0JjEwMjMpPDwxMCl8dHJhaWxTdXJyb2dhdGUmMTAyMzt9SEVBUDMyW291dFB0cj4+Ml09Y29kZVVuaXQ7b3V0UHRyKz00O2lmKG91dFB0cis0PmVuZFB0cilicmVha31IRUFQMzJbb3V0UHRyPj4yXT0wO3JldHVybiBvdXRQdHItc3RhcnRQdHJ9O3ZhciBsZW5ndGhCeXRlc1VURjMyPXN0cj0+e3ZhciBsZW49MDtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgY29kZVVuaXQ9c3RyLmNoYXJDb2RlQXQoaSk7aWYoY29kZVVuaXQ+PTU1Mjk2JiZjb2RlVW5pdDw9NTczNDMpKytpO2xlbis9NDt9cmV0dXJuIGxlbn07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nPShyYXdUeXBlLGNoYXJTaXplLG5hbWUpPT57bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3ZhciBkZWNvZGVTdHJpbmcsZW5jb2RlU3RyaW5nLGdldEhlYXAsbGVuZ3RoQnl0ZXNVVEYsc2hpZnQ7aWYoY2hhclNpemU9PT0yKXtkZWNvZGVTdHJpbmc9VVRGMTZUb1N0cmluZztlbmNvZGVTdHJpbmc9c3RyaW5nVG9VVEYxNjtsZW5ndGhCeXRlc1VURj1sZW5ndGhCeXRlc1VURjE2O2dldEhlYXA9KCk9PkhFQVBVMTY7c2hpZnQ9MTt9ZWxzZSBpZihjaGFyU2l6ZT09PTQpe2RlY29kZVN0cmluZz1VVEYzMlRvU3RyaW5nO2VuY29kZVN0cmluZz1zdHJpbmdUb1VURjMyO2xlbmd0aEJ5dGVzVVRGPWxlbmd0aEJ5dGVzVVRGMzI7Z2V0SGVhcD0oKT0+SEVBUFUzMjtzaGlmdD0yO31yZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLCJmcm9tV2lyZVR5cGUiOnZhbHVlPT57dmFyIGxlbmd0aD1IRUFQVTMyW3ZhbHVlPj4yXTt2YXIgSEVBUD1nZXRIZWFwKCk7dmFyIHN0cjt2YXIgZGVjb2RlU3RhcnRQdHI9dmFsdWUrNDtmb3IodmFyIGk9MDtpPD1sZW5ndGg7KytpKXt2YXIgY3VycmVudEJ5dGVQdHI9dmFsdWUrNCtpKmNoYXJTaXplO2lmKGk9PWxlbmd0aHx8SEVBUFtjdXJyZW50Qnl0ZVB0cj4+c2hpZnRdPT0wKXt2YXIgbWF4UmVhZEJ5dGVzPWN1cnJlbnRCeXRlUHRyLWRlY29kZVN0YXJ0UHRyO3ZhciBzdHJpbmdTZWdtZW50PWRlY29kZVN0cmluZyhkZWNvZGVTdGFydFB0cixtYXhSZWFkQnl0ZXMpO2lmKHN0cj09PXVuZGVmaW5lZCl7c3RyPXN0cmluZ1NlZ21lbnQ7fWVsc2Uge3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSgwKTtzdHIrPXN0cmluZ1NlZ21lbnQ7fWRlY29kZVN0YXJ0UHRyPWN1cnJlbnRCeXRlUHRyK2NoYXJTaXplO319X2ZyZWUodmFsdWUpO3JldHVybiBzdHJ9LCJ0b1dpcmVUeXBlIjooZGVzdHJ1Y3RvcnMsdmFsdWUpPT57aWYoISh0eXBlb2YgdmFsdWU9PSJzdHJpbmciKSl7dGhyb3dCaW5kaW5nRXJyb3IoYENhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gQysrIHN0cmluZyB0eXBlICR7bmFtZX1gKTt9dmFyIGxlbmd0aD1sZW5ndGhCeXRlc1VURih2YWx1ZSk7dmFyIHB0cj1fbWFsbG9jKDQrbGVuZ3RoK2NoYXJTaXplKTtIRUFQVTMyW3B0cj4+Ml09bGVuZ3RoPj5zaGlmdDtlbmNvZGVTdHJpbmcodmFsdWUscHRyKzQsbGVuZ3RoK2NoYXJTaXplKTtpZihkZXN0cnVjdG9ycyE9PW51bGwpe2Rlc3RydWN0b3JzLnB1c2goX2ZyZWUscHRyKTt9cmV0dXJuIHB0cn0sImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6c2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIsZGVzdHJ1Y3RvckZ1bmN0aW9uKHB0cil7X2ZyZWUocHRyKTt9fSk7fTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfdm9pZD0ocmF3VHlwZSxuYW1lKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7aXNWb2lkOnRydWUsbmFtZTpuYW1lLCJhcmdQYWNrQWR2YW5jZSI6MCwiZnJvbVdpcmVUeXBlIjooKT0+dW5kZWZpbmVkLCJ0b1dpcmVUeXBlIjooZGVzdHJ1Y3RvcnMsbyk9PnVuZGVmaW5lZH0pO307dmFyIGdldEhlYXBNYXg9KCk9PjIxNDc0ODM2NDg7dmFyIGdyb3dNZW1vcnk9c2l6ZT0+e3ZhciBiPXdhc21NZW1vcnkuYnVmZmVyO3ZhciBwYWdlcz0oc2l6ZS1iLmJ5dGVMZW5ndGgrNjU1MzUpLzY1NTM2O3RyeXt3YXNtTWVtb3J5Lmdyb3cocGFnZXMpO3VwZGF0ZU1lbW9yeVZpZXdzKCk7cmV0dXJuIDF9Y2F0Y2goZSl7fX07dmFyIF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwPXJlcXVlc3RlZFNpemU9Pnt2YXIgb2xkU2l6ZT1IRUFQVTgubGVuZ3RoO3JlcXVlc3RlZFNpemU+Pj49MDt2YXIgbWF4SGVhcFNpemU9Z2V0SGVhcE1heCgpO2lmKHJlcXVlc3RlZFNpemU+bWF4SGVhcFNpemUpe3JldHVybiBmYWxzZX12YXIgYWxpZ25VcD0oeCxtdWx0aXBsZSk9PngrKG11bHRpcGxlLXglbXVsdGlwbGUpJW11bHRpcGxlO2Zvcih2YXIgY3V0RG93bj0xO2N1dERvd248PTQ7Y3V0RG93bio9Mil7dmFyIG92ZXJHcm93bkhlYXBTaXplPW9sZFNpemUqKDErLjIvY3V0RG93bik7b3Zlckdyb3duSGVhcFNpemU9TWF0aC5taW4ob3Zlckdyb3duSGVhcFNpemUscmVxdWVzdGVkU2l6ZSsxMDA2NjMyOTYpO3ZhciBuZXdTaXplPU1hdGgubWluKG1heEhlYXBTaXplLGFsaWduVXAoTWF0aC5tYXgocmVxdWVzdGVkU2l6ZSxvdmVyR3Jvd25IZWFwU2l6ZSksNjU1MzYpKTt2YXIgcmVwbGFjZW1lbnQ9Z3Jvd01lbW9yeShuZXdTaXplKTtpZihyZXBsYWNlbWVudCl7cmV0dXJuIHRydWV9fXJldHVybiBmYWxzZX07ZW1iaW5kX2luaXRfY2hhckNvZGVzKCk7QmluZGluZ0Vycm9yPU1vZHVsZVsiQmluZGluZ0Vycm9yIl09Y2xhc3MgQmluZGluZ0Vycm9yIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IobWVzc2FnZSl7c3VwZXIobWVzc2FnZSk7dGhpcy5uYW1lPSJCaW5kaW5nRXJyb3IiO319O01vZHVsZVsiSW50ZXJuYWxFcnJvciJdPWNsYXNzIEludGVybmFsRXJyb3IgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihtZXNzYWdlKXtzdXBlcihtZXNzYWdlKTt0aGlzLm5hbWU9IkludGVybmFsRXJyb3IiO319O2hhbmRsZUFsbG9jYXRvckluaXQoKTtpbml0X2VtdmFsKCk7dmFyIHdhc21JbXBvcnRzPXtmOl9fZW1iaW5kX3JlZ2lzdGVyX2JpZ2ludCxpOl9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2wsaDpfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbCxlOl9fZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0LGI6X19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcixhOl9fZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3LGQ6X19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZyxjOl9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nLGo6X19lbWJpbmRfcmVnaXN0ZXJfdm9pZCxnOl9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwfTt2YXIgd2FzbUV4cG9ydHM9Y3JlYXRlV2FzbSgpO01vZHVsZVsiX3NvcnQiXT0oYTAsYTEsYTIsYTMsYTQsYTUsYTYsYTcsYTgsYTkpPT4oTW9kdWxlWyJfc29ydCJdPXdhc21FeHBvcnRzWyJtIl0pKGEwLGExLGEyLGEzLGE0LGE1LGE2LGE3LGE4LGE5KTt2YXIgX21hbGxvYz1Nb2R1bGVbIl9tYWxsb2MiXT1hMD0+KF9tYWxsb2M9TW9kdWxlWyJfbWFsbG9jIl09d2FzbUV4cG9ydHNbIm8iXSkoYTApO3ZhciBfZnJlZT1Nb2R1bGVbIl9mcmVlIl09YTA9PihfZnJlZT1Nb2R1bGVbIl9mcmVlIl09d2FzbUV4cG9ydHNbInAiXSkoYTApO3ZhciBjYWxsZWRSdW47ZGVwZW5kZW5jaWVzRnVsZmlsbGVkPWZ1bmN0aW9uIHJ1bkNhbGxlcigpe2lmKCFjYWxsZWRSdW4pcnVuKCk7aWYoIWNhbGxlZFJ1bilkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9cnVuQ2FsbGVyO307ZnVuY3Rpb24gcnVuKCl7aWYocnVuRGVwZW5kZW5jaWVzPjApe3JldHVybn1wcmVSdW4oKTtpZihydW5EZXBlbmRlbmNpZXM+MCl7cmV0dXJufWZ1bmN0aW9uIGRvUnVuKCl7aWYoY2FsbGVkUnVuKXJldHVybjtjYWxsZWRSdW49dHJ1ZTtNb2R1bGVbImNhbGxlZFJ1biJdPXRydWU7aWYoQUJPUlQpcmV0dXJuO2luaXRSdW50aW1lKCk7cmVhZHlQcm9taXNlUmVzb2x2ZShNb2R1bGUpO2lmKE1vZHVsZVsib25SdW50aW1lSW5pdGlhbGl6ZWQiXSlNb2R1bGVbIm9uUnVudGltZUluaXRpYWxpemVkIl0oKTtwb3N0UnVuKCk7fWlmKE1vZHVsZVsic2V0U3RhdHVzIl0pe01vZHVsZVsic2V0U3RhdHVzIl0oIlJ1bm5pbmcuLi4iKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe01vZHVsZVsic2V0U3RhdHVzIl0oIiIpO30sMSk7ZG9SdW4oKTt9LDEpO31lbHNlIHtkb1J1bigpO319aWYoTW9kdWxlWyJwcmVJbml0Il0pe2lmKHR5cGVvZiBNb2R1bGVbInByZUluaXQiXT09ImZ1bmN0aW9uIilNb2R1bGVbInByZUluaXQiXT1bTW9kdWxlWyJwcmVJbml0Il1dO3doaWxlKE1vZHVsZVsicHJlSW5pdCJdLmxlbmd0aD4wKXtNb2R1bGVbInByZUluaXQiXS5wb3AoKSgpO319cnVuKCk7CgoKICAgIHJldHVybiBtb2R1bGVBcmcucmVhZHkKICB9CiAgKTsKICB9KSgpOwoKICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueQogIGxldCB3YXNtTW9kdWxlOwogIGFzeW5jIGZ1bmN0aW9uIGluaXRXYXNtKCkgewogICAgICB3YXNtTW9kdWxlID0gYXdhaXQgbG9hZFdhc20oKTsKICB9CiAgbGV0IHNvcnREYXRhOwogIGxldCB2aWV3UHJvalB0cjsKICBsZXQgdHJhbnNmb3Jtc1B0cjsKICBsZXQgdHJhbnNmb3JtSW5kaWNlc1B0cjsKICBsZXQgcG9zaXRpb25zUHRyOwogIGxldCBjaHVua3NQdHI7CiAgbGV0IGRlcHRoQnVmZmVyUHRyOwogIGxldCBkZXB0aEluZGV4UHRyOwogIGxldCBzdGFydHNQdHI7CiAgbGV0IGNvdW50c1B0cjsKICBsZXQgYWxsb2NhdGVkVmVydGV4Q291bnQgPSAwOwogIGxldCBhbGxvY2F0ZWRUcmFuc2Zvcm1Db3VudCA9IDA7CiAgbGV0IHZpZXdQcm9qOwogIGxldCBydW5uaW5nID0gZmFsc2U7CiAgbGV0IGFsbG9jYXRpbmcgPSBmYWxzZTsKICBjb25zdCBhbGxvY2F0ZUJ1ZmZlcnMgPSBhc3luYyAoKSA9PiB7CiAgICAgIGFsbG9jYXRpbmcgPSB0cnVlOwogICAgICBpZiAoIXdhc21Nb2R1bGUpCiAgICAgICAgICBhd2FpdCBpbml0V2FzbSgpOwogICAgICBjb25zdCB0YXJnZXRBbGxvY2F0ZWRWZXJ0ZXhDb3VudCA9IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIoc29ydERhdGEudmVydGV4Q291bnQpKSk7CiAgICAgIGlmIChhbGxvY2F0ZWRWZXJ0ZXhDb3VudCA8IHRhcmdldEFsbG9jYXRlZFZlcnRleENvdW50KSB7CiAgICAgICAgICB3aGlsZSAocnVubmluZykgewogICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDApKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChhbGxvY2F0ZWRWZXJ0ZXhDb3VudCA+IDApIHsKICAgICAgICAgICAgICB3YXNtTW9kdWxlLl9mcmVlKHZpZXdQcm9qUHRyKTsKICAgICAgICAgICAgICB3YXNtTW9kdWxlLl9mcmVlKHRyYW5zZm9ybUluZGljZXNQdHIpOwogICAgICAgICAgICAgIHdhc21Nb2R1bGUuX2ZyZWUocG9zaXRpb25zUHRyKTsKICAgICAgICAgICAgICB3YXNtTW9kdWxlLl9mcmVlKGNodW5rc1B0cik7CiAgICAgICAgICAgICAgd2FzbU1vZHVsZS5fZnJlZShkZXB0aEJ1ZmZlclB0cik7CiAgICAgICAgICAgICAgd2FzbU1vZHVsZS5fZnJlZShkZXB0aEluZGV4UHRyKTsKICAgICAgICAgICAgICB3YXNtTW9kdWxlLl9mcmVlKHN0YXJ0c1B0cik7CiAgICAgICAgICAgICAgd2FzbU1vZHVsZS5fZnJlZShjb3VudHNQdHIpOwogICAgICAgICAgfQogICAgICAgICAgYWxsb2NhdGVkVmVydGV4Q291bnQgPSB0YXJnZXRBbGxvY2F0ZWRWZXJ0ZXhDb3VudDsKICAgICAgICAgIHZpZXdQcm9qUHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKDE2ICogNCk7CiAgICAgICAgICB0cmFuc2Zvcm1JbmRpY2VzUHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKGFsbG9jYXRlZFZlcnRleENvdW50ICogNCk7CiAgICAgICAgICBwb3NpdGlvbnNQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2MoMyAqIGFsbG9jYXRlZFZlcnRleENvdW50ICogNCk7CiAgICAgICAgICBjaHVua3NQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2MoYWxsb2NhdGVkVmVydGV4Q291bnQpOwogICAgICAgICAgZGVwdGhCdWZmZXJQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2MoYWxsb2NhdGVkVmVydGV4Q291bnQgKiA0KTsKICAgICAgICAgIGRlcHRoSW5kZXhQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2MoYWxsb2NhdGVkVmVydGV4Q291bnQgKiA0KTsKICAgICAgICAgIHN0YXJ0c1B0ciA9IHdhc21Nb2R1bGUuX21hbGxvYyhhbGxvY2F0ZWRWZXJ0ZXhDb3VudCAqIDQpOwogICAgICAgICAgY291bnRzUHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKGFsbG9jYXRlZFZlcnRleENvdW50ICogNCk7CiAgICAgIH0KICAgICAgY29uc3QgdGFyZ2V0QWxsb2NhdGVkVHJhbnNmb3JtQ291bnQgPSBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cyKHNvcnREYXRhLnRyYW5zZm9ybXMubGVuZ3RoIC8gMjApKSk7CiAgICAgIGlmIChhbGxvY2F0ZWRUcmFuc2Zvcm1Db3VudCA8IHRhcmdldEFsbG9jYXRlZFRyYW5zZm9ybUNvdW50KSB7CiAgICAgICAgICB3aGlsZSAocnVubmluZykgewogICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDApKTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChhbGxvY2F0ZWRUcmFuc2Zvcm1Db3VudCA+IDApIHsKICAgICAgICAgICAgICB3YXNtTW9kdWxlLl9mcmVlKHRyYW5zZm9ybXNQdHIpOwogICAgICAgICAgfQogICAgICAgICAgYWxsb2NhdGVkVHJhbnNmb3JtQ291bnQgPSB0YXJnZXRBbGxvY2F0ZWRUcmFuc2Zvcm1Db3VudDsKICAgICAgICAgIHRyYW5zZm9ybXNQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2MoMjAgKiA0ICogYWxsb2NhdGVkVHJhbnNmb3JtQ291bnQpOwogICAgICB9CiAgICAgIHdhc21Nb2R1bGUuSEVBUEYzMi5zZXQoc29ydERhdGEucG9zaXRpb25zLCBwb3NpdGlvbnNQdHIgLyA0KTsKICAgICAgd2FzbU1vZHVsZS5IRUFQRjMyLnNldChzb3J0RGF0YS50cmFuc2Zvcm1zLCB0cmFuc2Zvcm1zUHRyIC8gNCk7CiAgICAgIHdhc21Nb2R1bGUuSEVBUFUzMi5zZXQoc29ydERhdGEudHJhbnNmb3JtSW5kaWNlcywgdHJhbnNmb3JtSW5kaWNlc1B0ciAvIDQpOwogICAgICBhbGxvY2F0aW5nID0gZmFsc2U7CiAgfTsKICBjb25zdCBydW5Tb3J0ID0gKHZpZXdQcm9qKSA9PiB7CiAgICAgIHdhc21Nb2R1bGUuSEVBUEYzMi5zZXQodmlld1Byb2ouYnVmZmVyLCB2aWV3UHJvalB0ciAvIDQpOwogICAgICB3YXNtTW9kdWxlLl9zb3J0KHZpZXdQcm9qUHRyLCB0cmFuc2Zvcm1zUHRyLCB0cmFuc2Zvcm1JbmRpY2VzUHRyLCBzb3J0RGF0YS52ZXJ0ZXhDb3VudCwgcG9zaXRpb25zUHRyLCBjaHVua3NQdHIsIGRlcHRoQnVmZmVyUHRyLCBkZXB0aEluZGV4UHRyLCBzdGFydHNQdHIsIGNvdW50c1B0cik7CiAgICAgIGNvbnN0IGRlcHRoSW5kZXggPSBuZXcgVWludDMyQXJyYXkod2FzbU1vZHVsZS5IRUFQVTMyLmJ1ZmZlciwgZGVwdGhJbmRleFB0ciwgc29ydERhdGEudmVydGV4Q291bnQpOwogICAgICBjb25zdCBkZXRhY2hlZERlcHRoSW5kZXggPSBuZXcgVWludDMyQXJyYXkoZGVwdGhJbmRleC5zbGljZSgpLmJ1ZmZlcik7CiAgICAgIGNvbnN0IGNodW5rcyA9IG5ldyBVaW50OEFycmF5KHdhc21Nb2R1bGUuSEVBUFU4LmJ1ZmZlciwgY2h1bmtzUHRyLCBzb3J0RGF0YS52ZXJ0ZXhDb3VudCk7CiAgICAgIGNvbnN0IGRldGFjaGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmtzLnNsaWNlKCkuYnVmZmVyKTsKICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IGRlcHRoSW5kZXg6IGRldGFjaGVkRGVwdGhJbmRleCwgY2h1bmtzOiBkZXRhY2hlZENodW5rcyB9LCBbCiAgICAgICAgICBkZXRhY2hlZERlcHRoSW5kZXguYnVmZmVyLAogICAgICAgICAgZGV0YWNoZWRDaHVua3MuYnVmZmVyLAogICAgICBdKTsKICB9OwogIGNvbnN0IHRocm90dGxlZFNvcnQgPSAoKSA9PiB7CiAgICAgIGlmICghcnVubmluZykgewogICAgICAgICAgcnVubmluZyA9IHRydWU7CiAgICAgICAgICBjb25zdCBsYXN0VmlldyA9IHZpZXdQcm9qOwogICAgICAgICAgcnVuU29ydChsYXN0Vmlldyk7CiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7CiAgICAgICAgICAgICAgaWYgKGxhc3RWaWV3ICE9PSB2aWV3UHJvaikgewogICAgICAgICAgICAgICAgICB0aHJvdHRsZWRTb3J0KCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfSwgMCk7CiAgICAgIH0KICB9OwogIHNlbGYub25tZXNzYWdlID0gKGUpID0+IHsKICAgICAgaWYgKGUuZGF0YS5zb3J0RGF0YSkgewogICAgICAgICAgc29ydERhdGEgPSBlLmRhdGEuc29ydERhdGE7CiAgICAgICAgICBhbGxvY2F0ZUJ1ZmZlcnMoKTsKICAgICAgfQogICAgICBpZiAoYWxsb2NhdGluZyB8fCAhc29ydERhdGEpCiAgICAgICAgICByZXR1cm47CiAgICAgIGlmIChlLmRhdGEudmlld1Byb2opIHsKICAgICAgICAgIHZpZXdQcm9qID0gZS5kYXRhLnZpZXdQcm9qOwogICAgICAgICAgdGhyb3R0bGVkU29ydCgpOwogICAgICB9CiAgfTsKCn0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPVNvcnRXb3JrZXIuanMubWFwCgo=", null, false);
var h = class {
  constructor(A2, Q2) {
    this._scene = null, this._camera = null, this._started = false, this._initialized = false, this._renderer = A2;
    const F2 = A2.gl;
    this._program = F2.createProgram(), this._passes = Q2 || [];
    const B2 = F2.createShader(F2.VERTEX_SHADER);
    F2.shaderSource(B2, this._getVertexSource()), F2.compileShader(B2), F2.getShaderParameter(B2, F2.COMPILE_STATUS) || console.error(F2.getShaderInfoLog(B2));
    const U2 = F2.createShader(F2.FRAGMENT_SHADER);
    F2.shaderSource(U2, this._getFragmentSource()), F2.compileShader(U2), F2.getShaderParameter(U2, F2.COMPILE_STATUS) || console.error(F2.getShaderInfoLog(U2)), F2.attachShader(this.program, B2), F2.attachShader(this.program, U2), F2.linkProgram(this.program), F2.getProgramParameter(this.program, F2.LINK_STATUS) || console.error(F2.getProgramInfoLog(this.program)), this.resize = () => {
      F2.useProgram(this._program), this._resize();
    }, this.initialize = () => {
      console.assert(!this._initialized, "ShaderProgram already initialized"), F2.useProgram(this._program), this._initialize();
      for (const A3 of this.passes)
        A3.initialize(this);
      this._initialized = true, this._started = true;
    }, this.render = (A3, Q3) => {
      F2.useProgram(this._program), this._scene === A3 && this._camera === Q3 || (this.dispose(), this._scene = A3, this._camera = Q3, this.initialize());
      for (const A4 of this.passes)
        A4.render();
      this._render();
    }, this.dispose = () => {
      if (this._initialized) {
        F2.useProgram(this._program);
        for (const A3 of this.passes)
          A3.dispose();
        this._dispose(), this._scene = null, this._camera = null, this._initialized = false;
      }
    };
  }
  get renderer() {
    return this._renderer;
  }
  get scene() {
    return this._scene;
  }
  get camera() {
    return this._camera;
  }
  get program() {
    return this._program;
  }
  get passes() {
    return this._passes;
  }
  get started() {
    return this._started;
  }
};
var s = c("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgdmFyIGxvYWRXYXNtID0gKCgpID0+IHsKICAgIAogICAgcmV0dXJuICgKICBmdW5jdGlvbihtb2R1bGVBcmcgPSB7fSkgewoKICB2YXIgTW9kdWxlPW1vZHVsZUFyZzt2YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSxyZWFkeVByb21pc2VSZWplY3Q7TW9kdWxlWyJyZWFkeSJdPW5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntyZWFkeVByb21pc2VSZXNvbHZlPXJlc29sdmU7cmVhZHlQcm9taXNlUmVqZWN0PXJlamVjdDt9KTt2YXIgbW9kdWxlT3ZlcnJpZGVzPU9iamVjdC5hc3NpZ24oe30sTW9kdWxlKTt2YXIgc2NyaXB0RGlyZWN0b3J5PSIiO2Z1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCl7aWYoTW9kdWxlWyJsb2NhdGVGaWxlIl0pe3JldHVybiBNb2R1bGVbImxvY2F0ZUZpbGUiXShwYXRoLHNjcmlwdERpcmVjdG9yeSl9cmV0dXJuIHNjcmlwdERpcmVjdG9yeStwYXRofXZhciByZWFkQmluYXJ5O3t7c2NyaXB0RGlyZWN0b3J5PXNlbGYubG9jYXRpb24uaHJlZjt9aWYoc2NyaXB0RGlyZWN0b3J5LmluZGV4T2YoImJsb2I6IikhPT0wKXtzY3JpcHREaXJlY3Rvcnk9c2NyaXB0RGlyZWN0b3J5LnN1YnN0cigwLHNjcmlwdERpcmVjdG9yeS5yZXBsYWNlKC9bPyNdLiovLCIiKS5sYXN0SW5kZXhPZigiLyIpKzEpO31lbHNlIHtzY3JpcHREaXJlY3Rvcnk9IiI7fXt7cmVhZEJpbmFyeT11cmw9Pnt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbigiR0VUIix1cmwsZmFsc2UpO3hoci5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIjt4aHIuc2VuZChudWxsKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKX07fX19TW9kdWxlWyJwcmludCJdfHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO3ZhciBlcnI9TW9kdWxlWyJwcmludEVyciJdfHxjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihNb2R1bGUsbW9kdWxlT3ZlcnJpZGVzKTttb2R1bGVPdmVycmlkZXM9bnVsbDtpZihNb2R1bGVbImFyZ3VtZW50cyJdKU1vZHVsZVsiYXJndW1lbnRzIl07aWYoTW9kdWxlWyJ0aGlzUHJvZ3JhbSJdKU1vZHVsZVsidGhpc1Byb2dyYW0iXTtpZihNb2R1bGVbInF1aXQiXSlNb2R1bGVbInF1aXQiXTt2YXIgd2FzbUJpbmFyeTtpZihNb2R1bGVbIndhc21CaW5hcnkiXSl3YXNtQmluYXJ5PU1vZHVsZVsid2FzbUJpbmFyeSJdO2lmKHR5cGVvZiBXZWJBc3NlbWJseSE9Im9iamVjdCIpe2Fib3J0KCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkIik7fWZ1bmN0aW9uIGludEFycmF5RnJvbUJhc2U2NChzKXt2YXIgZGVjb2RlZD1hdG9iKHMpO3ZhciBieXRlcz1uZXcgVWludDhBcnJheShkZWNvZGVkLmxlbmd0aCk7Zm9yKHZhciBpPTA7aTxkZWNvZGVkLmxlbmd0aDsrK2kpe2J5dGVzW2ldPWRlY29kZWQuY2hhckNvZGVBdChpKTt9cmV0dXJuIGJ5dGVzfWZ1bmN0aW9uIHRyeVBhcnNlQXNEYXRhVVJJKGZpbGVuYW1lKXtpZighaXNEYXRhVVJJKGZpbGVuYW1lKSl7cmV0dXJufXJldHVybiBpbnRBcnJheUZyb21CYXNlNjQoZmlsZW5hbWUuc2xpY2UoZGF0YVVSSVByZWZpeC5sZW5ndGgpKX12YXIgd2FzbU1lbW9yeTt2YXIgQUJPUlQ9ZmFsc2U7dmFyIEhFQVA4LEhFQVBVOCxIRUFQMTYsSEVBUFUxNixIRUFQMzIsSEVBUFUzMixIRUFQRjMyLEhFQVBGNjQ7ZnVuY3Rpb24gdXBkYXRlTWVtb3J5Vmlld3MoKXt2YXIgYj13YXNtTWVtb3J5LmJ1ZmZlcjtNb2R1bGVbIkhFQVA4Il09SEVBUDg9bmV3IEludDhBcnJheShiKTtNb2R1bGVbIkhFQVAxNiJdPUhFQVAxNj1uZXcgSW50MTZBcnJheShiKTtNb2R1bGVbIkhFQVBVOCJdPUhFQVBVOD1uZXcgVWludDhBcnJheShiKTtNb2R1bGVbIkhFQVBVMTYiXT1IRUFQVTE2PW5ldyBVaW50MTZBcnJheShiKTtNb2R1bGVbIkhFQVAzMiJdPUhFQVAzMj1uZXcgSW50MzJBcnJheShiKTtNb2R1bGVbIkhFQVBVMzIiXT1IRUFQVTMyPW5ldyBVaW50MzJBcnJheShiKTtNb2R1bGVbIkhFQVBGMzIiXT1IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkoYik7TW9kdWxlWyJIRUFQRjY0Il09SEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KGIpO312YXIgX19BVFBSRVJVTl9fPVtdO3ZhciBfX0FUSU5JVF9fPVtdO3ZhciBfX0FUUE9TVFJVTl9fPVtdO2Z1bmN0aW9uIHByZVJ1bigpe2lmKE1vZHVsZVsicHJlUnVuIl0pe2lmKHR5cGVvZiBNb2R1bGVbInByZVJ1biJdPT0iZnVuY3Rpb24iKU1vZHVsZVsicHJlUnVuIl09W01vZHVsZVsicHJlUnVuIl1dO3doaWxlKE1vZHVsZVsicHJlUnVuIl0ubGVuZ3RoKXthZGRPblByZVJ1bihNb2R1bGVbInByZVJ1biJdLnNoaWZ0KCkpO319Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBSRVJVTl9fKTt9ZnVuY3Rpb24gaW5pdFJ1bnRpbWUoKXtjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKTt9ZnVuY3Rpb24gcG9zdFJ1bigpe2lmKE1vZHVsZVsicG9zdFJ1biJdKXtpZih0eXBlb2YgTW9kdWxlWyJwb3N0UnVuIl09PSJmdW5jdGlvbiIpTW9kdWxlWyJwb3N0UnVuIl09W01vZHVsZVsicG9zdFJ1biJdXTt3aGlsZShNb2R1bGVbInBvc3RSdW4iXS5sZW5ndGgpe2FkZE9uUG9zdFJ1bihNb2R1bGVbInBvc3RSdW4iXS5zaGlmdCgpKTt9fWNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQT1NUUlVOX18pO31mdW5jdGlvbiBhZGRPblByZVJ1bihjYil7X19BVFBSRVJVTl9fLnVuc2hpZnQoY2IpO31mdW5jdGlvbiBhZGRPbkluaXQoY2Ipe19fQVRJTklUX18udW5zaGlmdChjYik7fWZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYil7X19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKTt9dmFyIHJ1bkRlcGVuZGVuY2llcz0wO3ZhciBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9bnVsbDtmdW5jdGlvbiBhZGRSdW5EZXBlbmRlbmN5KGlkKXtydW5EZXBlbmRlbmNpZXMrKztNb2R1bGVbIm1vbml0b3JSdW5EZXBlbmRlbmNpZXMiXT8uKHJ1bkRlcGVuZGVuY2llcyk7fWZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpe3J1bkRlcGVuZGVuY2llcy0tO01vZHVsZVsibW9uaXRvclJ1bkRlcGVuZGVuY2llcyJdPy4ocnVuRGVwZW5kZW5jaWVzKTtpZihydW5EZXBlbmRlbmNpZXM9PTApe2lmKGRlcGVuZGVuY2llc0Z1bGZpbGxlZCl7dmFyIGNhbGxiYWNrPWRlcGVuZGVuY2llc0Z1bGZpbGxlZDtkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9bnVsbDtjYWxsYmFjaygpO319fWZ1bmN0aW9uIGFib3J0KHdoYXQpe01vZHVsZVsib25BYm9ydCJdPy4od2hhdCk7d2hhdD0iQWJvcnRlZCgiK3doYXQrIikiO2Vycih3aGF0KTtBQk9SVD10cnVlO3doYXQrPSIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uIjt2YXIgZT1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHdoYXQpO3JlYWR5UHJvbWlzZVJlamVjdChlKTt0aHJvdyBlfXZhciBkYXRhVVJJUHJlZml4PSJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsIjt2YXIgaXNEYXRhVVJJPWZpbGVuYW1lPT5maWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpO3ZhciB3YXNtQmluYXJ5RmlsZTt3YXNtQmluYXJ5RmlsZT0iZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LEFHRnpiUUVBQUFBQlp3OWdCSDkvZjM4QVlBTi9mMzhBWUFWL2YzOS9md0JnQm45L2YzOS9md0JnQW45L0FHQUJmd0YvWUFOL2YzOEJmMkFCZndCZ0FBQmdCMzkvZjM5L2YzOEFZQUo5ZlFGL1lBUi9mMzUrQUdBQmZRRi9ZQXQvZjM5L2YzOS9mMzkvZndCZ0FuOS9BWDhDUFFvQllRRmhBQUVCWVFGaUFBSUJZUUZqQUFFQllRRmtBQVFCWVFGbEFBRUJZUUZtQUFrQllRRm5BQVVCWVFGb0FBUUJZUUZwQUFBQllRRnFBQVFER3hvR0JRb0hDQWNFQ0FzQkFBRUhEQVVOQXdNQ0FnQUFEZ1lHQlFRRkFYQUJFQkFGQndFQmdBS0FnQUlHQ0FGL0FVSEFuZ1FMQnhrR0FXc0NBQUZzQUE0QmJRQVpBVzRCQUFGdkFCZ0JjQUFQQ1JVQkFFRUJDdzhSSXcwV0ZpSU5JUm9jSHcwYkhSNEs2VkFhY1FFQmZ5QUNSUVJBSUFBb0FnUWdBU2dDQkVZUEN5QUFJQUZHQkVCQkFROExBa0FnQUNnQ0JDSUNMUUFBSWdCRklBQWdBU2dDQkNJQkxRQUFJZ05IY2cwQUEwQWdBUzBBQVNFRElBSXRBQUVpQUVVTkFTQUJRUUZxSVFFZ0FrRUJhaUVDSUFBZ0EwWU5BQXNMSUFBZ0EwWUxUd0VDZjBHNEdpZ0NBQ0lCSUFCQkIycEJlSEVpQW1vaEFBSkFJQUpCQUNBQUlBRk5HMFVFUUNBQVB3QkJFSFJORFFFZ0FCQUdEUUVMUWNnYVFUQTJBZ0JCZnc4TFFiZ2FJQUEyQWdBZ0FRc09BQ0FBRUJjZ0FSQVhRUkIwY2dzR0FDQUFFQThMS1FCQndCcEJBVFlDQUVIRUdrRUFOZ0lBRUJGQnhCcEJ2Qm9vQWdBMkFnQkJ2QnBCd0JvMkFnQUwwZ3NCQjM4Q1FDQUFSUTBBSUFCQkNHc2lBaUFBUVFScktBSUFJZ0ZCZUhFaUFHb2hCUUpBSUFGQkFYRU5BQ0FCUVFKeFJRMEJJQUlnQWlnQ0FDSUJheUlDUWR3YUtBSUFTUTBCSUFBZ0FXb2hBQUpBQWtCQjRCb29BZ0FnQWtjRVFDQUJRZjhCVFFSQUlBRkJBM1loQkNBQ0tBSU1JZ0VnQWlnQ0NDSURSZ1JBUWN3YVFjd2FLQUlBUVg0Z0JIZHhOZ0lBREFVTElBTWdBVFlDRENBQklBTTJBZ2dNQkFzZ0FpZ0NHQ0VHSUFJZ0FpZ0NEQ0lCUndSQUlBSW9BZ2dpQXlBQk5nSU1JQUVnQXpZQ0NBd0RDeUFDUVJScUlnUW9BZ0FpQTBVRVFDQUNLQUlRSWdORkRRSWdBa0VRYWlFRUN3TkFJQVFoQnlBRElnRkJGR29pQkNnQ0FDSUREUUFnQVVFUWFpRUVJQUVvQWhBaUF3MEFDeUFIUVFBMkFnQU1BZ3NnQlNnQ0JDSUJRUU54UVFOSERRSkIxQm9nQURZQ0FDQUZJQUZCZm5FMkFnUWdBaUFBUVFGeU5nSUVJQVVnQURZQ0FBOExRUUFoQVFzZ0JrVU5BQUpBSUFJb0Fod2lBMEVDZEVIOEhHb2lCQ2dDQUNBQ1JnUkFJQVFnQVRZQ0FDQUJEUUZCMEJwQjBCb29BZ0JCZmlBRGQzRTJBZ0FNQWdzZ0JrRVFRUlFnQmlnQ0VDQUNSaHRxSUFFMkFnQWdBVVVOQVFzZ0FTQUdOZ0lZSUFJb0FoQWlBd1JBSUFFZ0F6WUNFQ0FESUFFMkFoZ0xJQUlvQWhRaUEwVU5BQ0FCSUFNMkFoUWdBeUFCTmdJWUN5QUNJQVZQRFFBZ0JTZ0NCQ0lCUVFGeFJRMEFBa0FDUUFKQUFrQWdBVUVDY1VVRVFFSGtHaWdDQUNBRlJnUkFRZVFhSUFJMkFnQkIyQnBCMkJvb0FnQWdBR29pQURZQ0FDQUNJQUJCQVhJMkFnUWdBa0hnR2lnQ0FFY05Ca0hVR2tFQU5nSUFRZUFhUVFBMkFnQVBDMEhnR2lnQ0FDQUZSZ1JBUWVBYUlBSTJBZ0JCMUJwQjFCb29BZ0FnQUdvaUFEWUNBQ0FDSUFCQkFYSTJBZ1FnQUNBQ2FpQUFOZ0lBRHdzZ0FVRjRjU0FBYWlFQUlBRkIvd0ZOQkVBZ0FVRURkaUVFSUFVb0Fnd2lBU0FGS0FJSUlnTkdCRUJCekJwQnpCb29BZ0JCZmlBRWQzRTJBZ0FNQlFzZ0F5QUJOZ0lNSUFFZ0F6WUNDQXdFQ3lBRktBSVlJUVlnQlNBRktBSU1JZ0ZIQkVCQjNCb29BZ0FhSUFVb0FnZ2lBeUFCTmdJTUlBRWdBellDQ0F3REN5QUZRUlJxSWdRb0FnQWlBMFVFUUNBRktBSVFJZ05GRFFJZ0JVRVFhaUVFQ3dOQUlBUWhCeUFESWdGQkZHb2lCQ2dDQUNJRERRQWdBVUVRYWlFRUlBRW9BaEFpQXcwQUN5QUhRUUEyQWdBTUFnc2dCU0FCUVg1eE5nSUVJQUlnQUVFQmNqWUNCQ0FBSUFKcUlBQTJBZ0FNQXd0QkFDRUJDeUFHUlEwQUFrQWdCU2dDSENJRFFRSjBRZndjYWlJRUtBSUFJQVZHQkVBZ0JDQUJOZ0lBSUFFTkFVSFFHa0hRR2lnQ0FFRitJQU4zY1RZQ0FBd0NDeUFHUVJCQkZDQUdLQUlRSUFWR0cyb2dBVFlDQUNBQlJRMEJDeUFCSUFZMkFoZ2dCU2dDRUNJREJFQWdBU0FETmdJUUlBTWdBVFlDR0FzZ0JTZ0NGQ0lEUlEwQUlBRWdBellDRkNBRElBRTJBaGdMSUFJZ0FFRUJjallDQkNBQUlBSnFJQUEyQWdBZ0FrSGdHaWdDQUVjTkFFSFVHaUFBTmdJQUR3c2dBRUgvQVUwRVFDQUFRWGh4UWZRYWFpRUJBbjlCekJvb0FnQWlBMEVCSUFCQkEzWjBJZ0J4UlFSQVFjd2FJQUFnQTNJMkFnQWdBUXdCQ3lBQktBSUlDeUVBSUFFZ0FqWUNDQ0FBSUFJMkFnd2dBaUFCTmdJTUlBSWdBRFlDQ0E4TFFSOGhBeUFBUWYvLy93ZE5CRUFnQUVFbUlBQkJDSFpuSWdGcmRrRUJjU0FCUVFGMGEwRSthaUVEQ3lBQ0lBTTJBaHdnQWtJQU53SVFJQU5CQW5SQi9CeHFJUUVDUUFKQUFrQkIwQm9vQWdBaUJFRUJJQU4wSWdkeFJRUkFRZEFhSUFRZ0IzSTJBZ0FnQVNBQ05nSUFJQUlnQVRZQ0dBd0JDeUFBUVJrZ0EwRUJkbXRCQUNBRFFSOUhHM1FoQXlBQktBSUFJUUVEUUNBQklnUW9BZ1JCZUhFZ0FFWU5BaUFEUVIxMklRRWdBMEVCZENFRElBUWdBVUVFY1dvaUIwRVFhaWdDQUNJQkRRQUxJQWNnQWpZQ0VDQUNJQVEyQWhnTElBSWdBallDRENBQ0lBSTJBZ2dNQVFzZ0JDZ0NDQ0lBSUFJMkFnd2dCQ0FDTmdJSUlBSkJBRFlDR0NBQ0lBUTJBZ3dnQWlBQU5nSUlDMEhzR2tIc0dpZ0NBRUVCYXlJQVFYOGdBQnMyQWdBTEN5RUFJQUVFUUFOQUlBQkJBRG9BQUNBQVFRRnFJUUFnQVVFQmF5SUJEUUFMQ3d2aEF3QkI3QmRCbWdrUUNVSDRGMEc1Q0VFQlFRQVFDRUdFR0VHMENFRUJRWUIvUWY4QUVBRkJuQmhCclFoQkFVR0FmMEgvQUJBQlFaQVlRYXNJUVFGQkFFSC9BUkFCUWFnWVFZa0lRUUpCZ0lCK1FmLy9BUkFCUWJRWVFZQUlRUUpCQUVILy93TVFBVUhBR0VHWUNFRUVRWUNBZ0lCNFFmLy8vLzhIRUFGQnpCaEJqd2hCQkVFQVFYOFFBVUhZR0VIWENFRUVRWUNBZ0lCNFFmLy8vLzhIRUFGQjVCaEJ6Z2hCQkVFQVFYOFFBVUh3R0VHakNFS0FnSUNBZ0lDQWdJQi9Rdi8vLy8vLy8vLy8vd0FRRWtIOEdFR2lDRUlBUW44UUVrR0lHVUdjQ0VFRUVBUkJsQmxCa3dsQkNCQUVRWVFQUWVrSUVBTkJ6QTlCbHcwUUEwR1VFRUVFUWR3SUVBSkI0QkJCQWtIMUNCQUNRYXdSUVFSQmhBa1FBa0hJRVVHK0NCQUhRZkFSUVFCQjBnd1FBRUdZRWtFQVFiZ05FQUJCd0JKQkFVSHdEQkFBUWVnU1FRSkJud2tRQUVHUUUwRURRYjRKRUFCQnVCTkJCRUhtQ1JBQVFlQVRRUVZCZ3dvUUFFR0lGRUVFUWQwTkVBQkJzQlJCQlVIN0RSQUFRWmdTUVFCQjZRb1FBRUhBRWtFQlFjZ0tFQUJCNkJKQkFrR3JDeEFBUVpBVFFRTkJpUXNRQUVHNEUwRUVRYkVNRUFCQjRCTkJCVUdQREJBQVFkZ1VRUWhCN2dzUUFFR0FGVUVKUWN3TEVBQkJxQlZCQmtHcENoQUFRZEFWUVFkQm9nNFFBQXNjQUNBQUlBRkJDQ0FDcHlBQ1FpQ0lweUFEcHlBRFFpQ0lweEFGQ3lBQUFrQWdBQ2dDQkNBQlJ3MEFJQUFvQWh4QkFVWU5BQ0FBSUFJMkFod0xDNW9CQUNBQVFRRTZBRFVDUUNBQUtBSUVJQUpIRFFBZ0FFRUJPZ0EwQWtBZ0FDZ0NFQ0lDUlFSQUlBQkJBVFlDSkNBQUlBTTJBaGdnQUNBQk5nSVFJQU5CQVVjTkFpQUFLQUl3UVFGR0RRRU1BZ3NnQVNBQ1JnUkFJQUFvQWhnaUFrRUNSZ1JBSUFBZ0F6WUNHQ0FESVFJTElBQW9BakJCQVVjTkFpQUNRUUZHRFFFTUFnc2dBQ0FBS0FJa1FRRnFOZ0lrQ3lBQVFRRTZBRFlMQzEwQkFYOGdBQ2dDRUNJRFJRUkFJQUJCQVRZQ0pDQUFJQUkyQWhnZ0FDQUJOZ0lRRHdzQ1FDQUJJQU5HQkVBZ0FDZ0NHRUVDUncwQklBQWdBallDR0E4TElBQkJBVG9BTmlBQVFRSTJBaGdnQUNBQUtBSWtRUUZxTmdJa0N3c0NBQXQzQVFSL0lBQzhJZ1JCLy8vL0EzRWhBUUpBSUFSQkYzWkIvd0Z4SWdKRkRRQWdBa0h3QUUwRVFDQUJRWUNBZ0FSeVFmRUFJQUpyZGlFQkRBRUxJQUpCalFGTEJFQkJnUGdCSVFOQkFDRUJEQUVMSUFKQkNuUkJnSUFIYXlFREN5QURJQVJCRUhaQmdJQUNjWElnQVVFTmRuSkIvLzhEY1F2R0p3RU1meU1BUVJCcklnb2tBQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FBUWZRQlRRUkFRY3dhS0FJQUlnWkJFQ0FBUVF0cVFmZ0RjU0FBUVF0Skd5SUZRUU4ySWdCMklnRkJBM0VFUUFKQUlBRkJmM05CQVhFZ0FHb2lBa0VEZENJQlFmUWFhaUlBSUFGQi9CcHFLQUlBSWdFb0FnZ2lBMFlFUUVITUdpQUdRWDRnQW5keE5nSUFEQUVMSUFNZ0FEWUNEQ0FBSUFNMkFnZ0xJQUZCQ0dvaEFDQUJJQUpCQTNRaUFrRURjallDQkNBQklBSnFJZ0VnQVNnQ0JFRUJjallDQkF3S0N5QUZRZFFhS0FJQUlnZE5EUUVnQVFSQUFrQkJBaUFBZENJQ1FRQWdBbXR5SUFFZ0FIUnhhQ0lCUVFOMElnQkI5QnBxSWdJZ0FFSDhHbW9vQWdBaUFDZ0NDQ0lEUmdSQVFjd2FJQVpCZmlBQmQzRWlCallDQUF3QkN5QURJQUkyQWd3Z0FpQUROZ0lJQ3lBQUlBVkJBM0kyQWdRZ0FDQUZhaUlFSUFGQkEzUWlBU0FGYXlJRFFRRnlOZ0lFSUFBZ0FXb2dBellDQUNBSEJFQWdCMEY0Y1VIMEdtb2hBVUhnR2lnQ0FDRUNBbjhnQmtFQklBZEJBM1owSWdWeFJRUkFRY3dhSUFVZ0JuSTJBZ0FnQVF3QkN5QUJLQUlJQ3lFRklBRWdBallDQ0NBRklBSTJBZ3dnQWlBQk5nSU1JQUlnQlRZQ0NBc2dBRUVJYWlFQVFlQWFJQVEyQWdCQjFCb2dBellDQUF3S0MwSFFHaWdDQUNJTFJRMEJJQXRvUVFKMFFmd2NhaWdDQUNJQ0tBSUVRWGh4SUFWcklRUWdBaUVCQTBBQ1FDQUJLQUlRSWdCRkJFQWdBU2dDRkNJQVJRMEJDeUFBS0FJRVFYaHhJQVZySWdFZ0JDQUJJQVJKSWdFYklRUWdBQ0FDSUFFYklRSWdBQ0VCREFFTEN5QUNLQUlZSVFrZ0FpQUNLQUlNSWdOSEJFQkIzQm9vQWdBYUlBSW9BZ2dpQUNBRE5nSU1JQU1nQURZQ0NBd0pDeUFDUVJScUlnRW9BZ0FpQUVVRVFDQUNLQUlRSWdCRkRRTWdBa0VRYWlFQkN3TkFJQUVoQ0NBQUlnTkJGR29pQVNnQ0FDSUFEUUFnQTBFUWFpRUJJQU1vQWhBaUFBMEFDeUFJUVFBMkFnQU1DQXRCZnlFRklBQkJ2MzlMRFFBZ0FFRUxhaUlBUVhoeElRVkIwQm9vQWdBaUNFVU5BRUVBSUFWcklRUUNRQUpBQWtBQ2YwRUFJQVZCZ0FKSkRRQWFRUjhnQlVILy8vOEhTdzBBR2lBRlFTWWdBRUVJZG1jaUFHdDJRUUZ4SUFCQkFYUnJRVDVxQ3lJSFFRSjBRZndjYWlnQ0FDSUJSUVJBUVFBaEFBd0JDMEVBSVFBZ0JVRVpJQWRCQVhaclFRQWdCMEVmUnh0MElRSURRQUpBSUFFb0FnUkJlSEVnQldzaUJpQUVUdzBBSUFFaEF5QUdJZ1FOQUVFQUlRUWdBU0VBREFNTElBQWdBU2dDRkNJR0lBWWdBU0FDUVIxMlFRUnhhaWdDRUNJQlJoc2dBQ0FHR3lFQUlBSkJBWFFoQWlBQkRRQUxDeUFBSUFOeVJRUkFRUUFoQTBFQ0lBZDBJZ0JCQUNBQWEzSWdDSEVpQUVVTkF5QUFhRUVDZEVIOEhHb29BZ0FoQUFzZ0FFVU5BUXNEUUNBQUtBSUVRWGh4SUFWcklnSWdCRWtoQVNBQ0lBUWdBUnNoQkNBQUlBTWdBUnNoQXlBQUtBSVFJZ0VFZnlBQkJTQUFLQUlVQ3lJQURRQUxDeUFEUlEwQUlBUkIxQm9vQWdBZ0JXdFBEUUFnQXlnQ0dDRUhJQU1nQXlnQ0RDSUNSd1JBUWR3YUtBSUFHaUFES0FJSUlnQWdBallDRENBQ0lBQTJBZ2dNQndzZ0EwRVVhaUlCS0FJQUlnQkZCRUFnQXlnQ0VDSUFSUTBESUFOQkVHb2hBUXNEUUNBQklRWWdBQ0lDUVJScUlnRW9BZ0FpQUEwQUlBSkJFR29oQVNBQ0tBSVFJZ0FOQUFzZ0JrRUFOZ0lBREFZTElBVkIxQm9vQWdBaUEwMEVRRUhnR2lnQ0FDRUFBa0FnQXlBRmF5SUJRUkJQQkVBZ0FDQUZhaUlDSUFGQkFYSTJBZ1FnQUNBRGFpQUJOZ0lBSUFBZ0JVRURjallDQkF3QkN5QUFJQU5CQTNJMkFnUWdBQ0FEYWlJQklBRW9BZ1JCQVhJMkFnUkJBQ0VDUVFBaEFRdEIxQm9nQVRZQ0FFSGdHaUFDTmdJQUlBQkJDR29oQUF3SUN5QUZRZGdhS0FJQUlnSkpCRUJCMkJvZ0FpQUZheUlCTmdJQVFlUWFRZVFhS0FJQUlnQWdCV29pQWpZQ0FDQUNJQUZCQVhJMkFnUWdBQ0FGUVFOeU5nSUVJQUJCQ0dvaEFBd0lDMEVBSVFBZ0JVRXZhaUlFQW45QnBCNG9BZ0FFUUVHc0hpZ0NBQXdCQzBHd0hrSi9Od0lBUWFnZVFvQ2dnSUNBZ0FRM0FnQkJwQjRnQ2tFTWFrRndjVUhZcXRXcUJYTTJBZ0JCdUI1QkFEWUNBRUdJSGtFQU5nSUFRWUFnQ3lJQmFpSUdRUUFnQVdzaUNIRWlBU0FGVFEwSFFZUWVLQUlBSWdNRVFFSDhIU2dDQUNJSElBRnFJZ2tnQjAwZ0F5QUpTWElOQ0FzQ1FFR0lIaTBBQUVFRWNVVUVRQUpBQWtBQ1FBSkFRZVFhS0FJQUlnTUVRRUdNSGlFQUEwQWdBeUFBS0FJQUlnZFBCRUFnQnlBQUtBSUVhaUFEU3cwREN5QUFLQUlJSWdBTkFBc0xRUUFRQ3lJQ1FYOUdEUU1nQVNFR1FhZ2VLQUlBSWdCQkFXc2lBeUFDY1FSQUlBRWdBbXNnQWlBRGFrRUFJQUJyY1dvaEJnc2dCU0FHVHcwRFFZUWVLQUlBSWdBRVFFSDhIU2dDQUNJRElBWnFJZ2dnQTAwZ0FDQUlTWElOQkFzZ0JoQUxJZ0FnQWtjTkFRd0ZDeUFHSUFKcklBaHhJZ1lRQ3lJQ0lBQW9BZ0FnQUNnQ0JHcEdEUUVnQWlFQUN5QUFRWDlHRFFFZ0JVRXdhaUFHVFFSQUlBQWhBZ3dFQzBHc0hpZ0NBQ0lDSUFRZ0JtdHFRUUFnQW10eElnSVFDMEYvUmcwQklBSWdCbW9oQmlBQUlRSU1Bd3NnQWtGL1J3MENDMEdJSGtHSUhpZ0NBRUVFY2pZQ0FBc2dBUkFMSWdKQmYwWkJBQkFMSWdCQmYwWnlJQUFnQWsxeURRVWdBQ0FDYXlJR0lBVkJLR3BORFFVTFFmd2RRZndkS0FJQUlBWnFJZ0EyQWdCQmdCNG9BZ0FnQUVrRVFFR0FIaUFBTmdJQUN3SkFRZVFhS0FJQUlnUUVRRUdNSGlFQUEwQWdBaUFBS0FJQUlnRWdBQ2dDQkNJRGFrWU5BaUFBS0FJSUlnQU5BQXNNQkF0QjNCb29BZ0FpQUVFQUlBQWdBazBiUlFSQVFkd2FJQUkyQWdBTFFRQWhBRUdRSGlBR05nSUFRWXdlSUFJMkFnQkI3QnBCZnpZQ0FFSHdHa0drSGlnQ0FEWUNBRUdZSGtFQU5nSUFBMEFnQUVFRGRDSUJRZndhYWlBQlFmUWFhaUlETmdJQUlBRkJnQnRxSUFNMkFnQWdBRUVCYWlJQVFTQkhEUUFMUWRnYUlBWkJLR3NpQUVGNElBSnJRUWR4SWdGcklnTTJBZ0JCNUJvZ0FTQUNhaUlCTmdJQUlBRWdBMEVCY2pZQ0JDQUFJQUpxUVNnMkFnUkI2QnBCdEI0b0FnQTJBZ0FNQkFzZ0FpQUVUU0FCSUFSTGNnMENJQUFvQWd4QkNIRU5BaUFBSUFNZ0JtbzJBZ1JCNUJvZ0JFRjRJQVJyUVFkeElnQnFJZ0UyQWdCQjJCcEIyQm9vQWdBZ0Jtb2lBaUFBYXlJQU5nSUFJQUVnQUVFQmNqWUNCQ0FDSUFScVFTZzJBZ1JCNkJwQnRCNG9BZ0EyQWdBTUF3dEJBQ0VEREFVTFFRQWhBZ3dEQzBIY0dpZ0NBQ0FDU3dSQVFkd2FJQUkyQWdBTElBSWdCbW9oQVVHTUhpRUFBa0FDUUFKQUEwQWdBU0FBS0FJQVJ3UkFJQUFvQWdnaUFBMEJEQUlMQ3lBQUxRQU1RUWh4UlEwQkMwR01IaUVBQTBBQ1FDQUVJQUFvQWdBaUFVOEVRQ0FCSUFBb0FnUnFJZ01nQkVzTkFRc2dBQ2dDQ0NFQURBRUxDMEhZR2lBR1FTaHJJZ0JCZUNBQ2EwRUhjU0lCYXlJSU5nSUFRZVFhSUFFZ0Ftb2lBVFlDQUNBQklBaEJBWEkyQWdRZ0FDQUNha0VvTmdJRVFlZ2FRYlFlS0FJQU5nSUFJQVFnQTBFbklBTnJRUWR4YWtFdmF5SUFJQUFnQkVFUWFra2JJZ0ZCR3pZQ0JDQUJRWlFlS1FJQU53SVFJQUZCakI0cEFnQTNBZ2hCbEI0Z0FVRUlhallDQUVHUUhpQUdOZ0lBUVl3ZUlBSTJBZ0JCbUI1QkFEWUNBQ0FCUVJocUlRQURRQ0FBUVFjMkFnUWdBRUVJYWlFTUlBQkJCR29oQUNBTUlBTkpEUUFMSUFFZ0JFWU5BaUFCSUFFb0FnUkJmbkUyQWdRZ0JDQUJJQVJySWdKQkFYSTJBZ1FnQVNBQ05nSUFJQUpCL3dGTkJFQWdBa0Y0Y1VIMEdtb2hBQUovUWN3YUtBSUFJZ0ZCQVNBQ1FRTjJkQ0lDY1VVRVFFSE1HaUFCSUFKeU5nSUFJQUFNQVFzZ0FDZ0NDQXNoQVNBQUlBUTJBZ2dnQVNBRU5nSU1JQVFnQURZQ0RDQUVJQUUyQWdnTUF3dEJIeUVBSUFKQi8vLy9CMDBFUUNBQ1FTWWdBa0VJZG1jaUFHdDJRUUZ4SUFCQkFYUnJRVDVxSVFBTElBUWdBRFlDSENBRVFnQTNBaEFnQUVFQ2RFSDhIR29oQVFKQVFkQWFLQUlBSWdOQkFTQUFkQ0lHY1VVRVFFSFFHaUFESUFaeU5nSUFJQUVnQkRZQ0FBd0JDeUFDUVJrZ0FFRUJkbXRCQUNBQVFSOUhHM1FoQUNBQktBSUFJUU1EUUNBRElnRW9BZ1JCZUhFZ0FrWU5BeUFBUVIxMklRTWdBRUVCZENFQUlBRWdBMEVFY1dvaUJpZ0NFQ0lERFFBTElBWWdCRFlDRUFzZ0JDQUJOZ0lZSUFRZ0JEWUNEQ0FFSUFRMkFnZ01BZ3NnQUNBQ05nSUFJQUFnQUNnQ0JDQUdhallDQkNBQ1FYZ2dBbXRCQjNGcUlnY2dCVUVEY2pZQ0JDQUJRWGdnQVd0QkIzRnFJZ1FnQlNBSGFpSUZheUVHQWtCQjVCb29BZ0FnQkVZRVFFSGtHaUFGTmdJQVFkZ2FRZGdhS0FJQUlBWnFJZ0EyQWdBZ0JTQUFRUUZ5TmdJRURBRUxRZUFhS0FJQUlBUkdCRUJCNEJvZ0JUWUNBRUhVR2tIVUdpZ0NBQ0FHYWlJQU5nSUFJQVVnQUVFQmNqWUNCQ0FBSUFWcUlBQTJBZ0FNQVFzZ0JDZ0NCQ0lDUVFOeFFRRkdCRUFnQWtGNGNTRUpBa0FnQWtIL0FVMEVRQ0FFS0FJTUlnQWdCQ2dDQ0NJQlJnUkFRY3dhUWN3YUtBSUFRWDRnQWtFRGRuZHhOZ0lBREFJTElBRWdBRFlDRENBQUlBRTJBZ2dNQVFzZ0JDZ0NHQ0VJQWtBZ0JDQUVLQUlNSWdCSEJFQkIzQm9vQWdBYUlBUW9BZ2dpQVNBQU5nSU1JQUFnQVRZQ0NBd0JDd0pBSUFSQkZHb2lBU2dDQUNJQ1JRUkFJQVFvQWhBaUFrVU5BU0FFUVJCcUlRRUxBMEFnQVNFRElBSWlBRUVVYWlJQktBSUFJZ0lOQUNBQVFSQnFJUUVnQUNnQ0VDSUNEUUFMSUFOQkFEWUNBQXdCQzBFQUlRQUxJQWhGRFFBQ1FDQUVLQUljSWdGQkFuUkIvQnhxSWdJb0FnQWdCRVlFUUNBQ0lBQTJBZ0FnQUEwQlFkQWFRZEFhS0FJQVFYNGdBWGR4TmdJQURBSUxJQWhCRUVFVUlBZ29BaEFnQkVZYmFpQUFOZ0lBSUFCRkRRRUxJQUFnQ0RZQ0dDQUVLQUlRSWdFRVFDQUFJQUUyQWhBZ0FTQUFOZ0lZQ3lBRUtBSVVJZ0ZGRFFBZ0FDQUJOZ0lVSUFFZ0FEWUNHQXNnQmlBSmFpRUdJQVFnQ1dvaUJDZ0NCQ0VDQ3lBRUlBSkJmbkUyQWdRZ0JTQUdRUUZ5TmdJRUlBVWdCbW9nQmpZQ0FDQUdRZjhCVFFSQUlBWkJlSEZCOUJwcUlRQUNmMEhNR2lnQ0FDSUJRUUVnQmtFRGRuUWlBbkZGQkVCQnpCb2dBU0FDY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJUUVnQUNBRk5nSUlJQUVnQlRZQ0RDQUZJQUEyQWd3Z0JTQUJOZ0lJREFFTFFSOGhBaUFHUWYvLy93ZE5CRUFnQmtFbUlBWkJDSFpuSWdCcmRrRUJjU0FBUVFGMGEwRSthaUVDQ3lBRklBSTJBaHdnQlVJQU53SVFJQUpCQW5SQi9CeHFJUUVDUUFKQVFkQWFLQUlBSWdCQkFTQUNkQ0lEY1VVRVFFSFFHaUFBSUFOeU5nSUFJQUVnQlRZQ0FBd0JDeUFHUVJrZ0FrRUJkbXRCQUNBQ1FSOUhHM1FoQWlBQktBSUFJUUFEUUNBQUlnRW9BZ1JCZUhFZ0JrWU5BaUFDUVIxMklRQWdBa0VCZENFQ0lBRWdBRUVFY1dvaUF5Z0NFQ0lBRFFBTElBTWdCVFlDRUFzZ0JTQUJOZ0lZSUFVZ0JUWUNEQ0FGSUFVMkFnZ01BUXNnQVNnQ0NDSUFJQVUyQWd3Z0FTQUZOZ0lJSUFWQkFEWUNHQ0FGSUFFMkFnd2dCU0FBTmdJSUN5QUhRUWhxSVFBTUJRc2dBU2dDQ0NJQUlBUTJBZ3dnQVNBRU5nSUlJQVJCQURZQ0dDQUVJQUUyQWd3Z0JDQUFOZ0lJQzBIWUdpZ0NBQ0lBSUFWTkRRQkIyQm9nQUNBRmF5SUJOZ0lBUWVRYVFlUWFLQUlBSWdBZ0JXb2lBallDQUNBQ0lBRkJBWEkyQWdRZ0FDQUZRUU55TmdJRUlBQkJDR29oQUF3REMwSElHa0V3TmdJQVFRQWhBQXdDQ3dKQUlBZEZEUUFDUUNBREtBSWNJZ0JCQW5SQi9CeHFJZ0VvQWdBZ0EwWUVRQ0FCSUFJMkFnQWdBZzBCUWRBYUlBaEJmaUFBZDNFaUNEWUNBQXdDQ3lBSFFSQkJGQ0FIS0FJUUlBTkdHMm9nQWpZQ0FDQUNSUTBCQ3lBQ0lBYzJBaGdnQXlnQ0VDSUFCRUFnQWlBQU5nSVFJQUFnQWpZQ0dBc2dBeWdDRkNJQVJRMEFJQUlnQURZQ0ZDQUFJQUkyQWhnTEFrQWdCRUVQVFFSQUlBTWdCQ0FGYWlJQVFRTnlOZ0lFSUFBZ0Eyb2lBQ0FBS0FJRVFRRnlOZ0lFREFFTElBTWdCVUVEY2pZQ0JDQURJQVZxSWdJZ0JFRUJjallDQkNBQ0lBUnFJQVEyQWdBZ0JFSC9BVTBFUUNBRVFYaHhRZlFhYWlFQUFuOUJ6Qm9vQWdBaUFVRUJJQVJCQTNaMElnVnhSUVJBUWN3YUlBRWdCWEkyQWdBZ0FBd0JDeUFBS0FJSUN5RUJJQUFnQWpZQ0NDQUJJQUkyQWd3Z0FpQUFOZ0lNSUFJZ0FUWUNDQXdCQzBFZklRQWdCRUgvLy84SFRRUkFJQVJCSmlBRVFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb2hBQXNnQWlBQU5nSWNJQUpDQURjQ0VDQUFRUUowUWZ3Y2FpRUJBa0FDUUNBSVFRRWdBSFFpQlhGRkJFQkIwQm9nQlNBSWNqWUNBQ0FCSUFJMkFnQU1BUXNnQkVFWklBQkJBWFpyUVFBZ0FFRWZSeHQwSVFBZ0FTZ0NBQ0VGQTBBZ0JTSUJLQUlFUVhoeElBUkdEUUlnQUVFZGRpRUZJQUJCQVhRaEFDQUJJQVZCQkhGcUlnWW9BaEFpQlEwQUN5QUdJQUkyQWhBTElBSWdBVFlDR0NBQ0lBSTJBZ3dnQWlBQ05nSUlEQUVMSUFFb0FnZ2lBQ0FDTmdJTUlBRWdBallDQ0NBQ1FRQTJBaGdnQWlBQk5nSU1JQUlnQURZQ0NBc2dBMEVJYWlFQURBRUxBa0FnQ1VVTkFBSkFJQUlvQWh3aUFFRUNkRUg4SEdvaUFTZ0NBQ0FDUmdSQUlBRWdBellDQUNBRERRRkIwQm9nQzBGK0lBQjNjVFlDQUF3Q0N5QUpRUkJCRkNBSktBSVFJQUpHRzJvZ0F6WUNBQ0FEUlEwQkN5QURJQWsyQWhnZ0FpZ0NFQ0lBQkVBZ0F5QUFOZ0lRSUFBZ0F6WUNHQXNnQWlnQ0ZDSUFSUTBBSUFNZ0FEWUNGQ0FBSUFNMkFoZ0xBa0FnQkVFUFRRUkFJQUlnQkNBRmFpSUFRUU55TmdJRUlBQWdBbW9pQUNBQUtBSUVRUUZ5TmdJRURBRUxJQUlnQlVFRGNqWUNCQ0FDSUFWcUlnTWdCRUVCY2pZQ0JDQURJQVJxSUFRMkFnQWdCd1JBSUFkQmVIRkI5QnBxSVFCQjRCb29BZ0FoQVFKL1FRRWdCMEVEZG5RaUJTQUdjVVVFUUVITUdpQUZJQVp5TmdJQUlBQU1BUXNnQUNnQ0NBc2hCU0FBSUFFMkFnZ2dCU0FCTmdJTUlBRWdBRFlDRENBQklBVTJBZ2dMUWVBYUlBTTJBZ0JCMUJvZ0JEWUNBQXNnQWtFSWFpRUFDeUFLUVJCcUpBQWdBQXUrQ3dJTGZ3bDlJd0JCb0FGcklnc2tBQ0FMUVRCcVFTUVFFQU5BSUFFZ0RVY0VRQ0FDSUExQkEyd2lERUVDYWtFQ2RDSU9haW9DQUNFWElBSWdERUVCYWtFQ2RDSVBhaW9DQUNFWUlBZ2dERUVDZENJUWFpQUNJQkJxS2dJQUloazRBZ0FnQ0NBUGFpQVlPQUlBSUFnZ0Rtb2dGemdDQUNBSElBMUJCWFJxSWd3Z0dEZ0NCQ0FNSUJrNEFnQWdEQ0FYT0FJSUlBeEJBRFlDREFKQUlBQkZCRUFnQmlBTmFpMEFBRVVOQVFzZ0RFR0FnSUFJTmdJTUN5QUhJQTFCQlhRaUVVRWNjbW9nQlNBTlFRSjBJZ3hCQVhJaUVtb3RBQUJCQ0hRZ0JTQU1haTBBQUhJZ0JTQU1RUUp5SWhOcUxRQUFRUkIwY2lBRklBeEJBM0lpREdvdEFBQkJHSFJ5TmdJQUlBc2dBeUFTUVFKMEloSnFLZ0lBSWhjNEFwQUJJQXNnQXlBVFFRSjBJaE5xS2dJQUloZzRBcFFCSUFzZ0F5QU1RUUowSWhScUtnSUFJaGs0QXBnQklBc2dBeUFOUVFSMEloVnFLZ0lBakNJYU9BS2NBU0FMUWVBQWFpSU1JQXNxQXBnQkloWkRBQUFBd0pRZ0ZwUWdDeW9DbEFFaUZrTUFBQURBbENBV2xFTUFBSUEva3BJNEFnQWdEQ0FMS2dLUUFTSVdJQmFTSUFzcUFwUUJsQ0FMS2dLWUFVTUFBQURBbENBTEtnS2NBWlNTT0FJRUlBd2dDeW9Da0FFaUZpQVdraUFMS2dLWUFaUWdDeW9DbEFFaUZpQVdraUFMS2dLY0FaU1NPQUlJSUF3Z0N5b0NrQUVpRmlBV2tpQUxLZ0tVQVpRZ0N5b0NtQUVpRmlBV2tpQUxLZ0tjQVpTU09BSU1JQXdnQ3lvQ21BRWlGa01BQUFEQWxDQVdsQ0FMS2dLUUFTSVdRd0FBQU1DVUlCYVVRd0FBZ0QrU2tqZ0NFQ0FNSUFzcUFwUUJJaFlnRnBJZ0N5b0NtQUdVSUFzcUFwQUJRd0FBQU1DVUlBc3FBcHdCbEpJNEFoUWdEQ0FMS2dLUUFTSVdJQmFTSUFzcUFwZ0JsQ0FMS2dLVUFVTUFBQURBbENBTEtnS2NBWlNTT0FJWUlBd2dDeW9DbEFFaUZpQVdraUFMS2dLWUFaUWdDeW9Da0FFaUZpQVdraUFMS2dLY0FaU1NPQUljSUF3Z0N5b0NsQUVpRmtNQUFBREFsQ0FXbENBTEtnS1FBU0lXUXdBQUFNQ1VJQmFVUXdBQWdEK1NramdDSUNBSklCVnFJQmM0QWdBZ0NTQVNhaUFZT0FJQUlBa2dFMm9nR1RnQ0FDQUpJQlJxSUJvNEFnQWdDeUFFSUJCcUtnSUFJaGM0QWpBZ0N5QUVJQTlxS2dJQUloZzRBa0FnQ3lBRUlBNXFLZ0lBSWhrNEFsQWdDaUFRYWlBWE9BSUFJQW9nRDJvZ0dEZ0NBQ0FLSUE1cUlCazRBZ0FnQ3lBTUtnSVlJQXNxQWppVUlBd3FBZ0FnQ3lvQ01KUWdEQ29DRENBTEtnSTBsSktTT0FJQUlBc2dEQ29DSENBTEtnSTRsQ0FNS2dJRUlBc3FBakNVSUF3cUFoQWdDeW9DTkpTU2tqZ0NCQ0FMSUF3cUFpQWdDeW9DT0pRZ0RDb0NDQ0FMS2dJd2xDQU1LZ0lVSUFzcUFqU1VrcEk0QWdnZ0N5QU1LZ0lZSUFzcUFrU1VJQXdxQWdBZ0N5b0NQSlFnRENvQ0RDQUxLZ0pBbEpLU09BSU1JQXNnRENvQ0hDQUxLZ0pFbENBTUtnSUVJQXNxQWp5VUlBd3FBaEFnQ3lvQ1FKU1NramdDRUNBTElBd3FBaUFnQ3lvQ1JKUWdEQ29DQ0NBTEtnSThsQ0FNS2dJVUlBc3FBa0NVa3BJNEFoUWdDeUFNS2dJWUlBc3FBbENVSUF3cUFnQWdDeW9DU0pRZ0RDb0NEQ0FMS2dKTWxKS1NPQUlZSUFzZ0RDb0NIQ0FMS2dKUWxDQU1LZ0lFSUFzcUFraVVJQXdxQWhBZ0N5b0NUSlNTa2pnQ0hDQUxJQXdxQWlBZ0N5b0NVSlFnRENvQ0NDQUxLZ0pJbENBTUtnSVVJQXNxQWt5VWtwSTRBaUFnQ3lvQ0lDRVhJQXNxQWdnaEdDQUxLZ0lVSVJrZ0J5QVJRUkJ5YWlBTEtnSVlJaG9nR3BRZ0N5b0NBQ0lXSUJhVUlBc3FBZ3dpR3lBYmxKS1NRd0FBZ0VDVUlCb2dDeW9DSENJY2xDQVdJQXNxQWdRaUhaUWdHeUFMS2dJUUloNlVrcEpEQUFDQVFKUVFERFlDQUNBSElCRkJGSEpxSUJvZ0Y1UWdGaUFZbENBYklCbVVrcEpEQUFDQVFKUWdIQ0FjbENBZElCMlVJQjRnSHBTU2trTUFBSUJBbEJBTU5nSUFJQWNnRVVFWWNtb2dIQ0FYbENBZElCaVVJQjRnR1pTU2trTUFBSUJBbENBWElCZVVJQmdnR0pRZ0dTQVpsSktTUXdBQWdFQ1VFQXcyQWdBZ0RVRUJhaUVOREFFTEN5QUxRYUFCYWlRQUN4b0FJQUFnQVNnQ0NDQUZFQW9FUUNBQklBSWdBeUFFRUJRTEN6Y0FJQUFnQVNnQ0NDQUZFQW9FUUNBQklBSWdBeUFFRUJRUEN5QUFLQUlJSWdBZ0FTQUNJQU1nQkNBRklBQW9BZ0FvQWhRUkF3QUxrUUVBSUFBZ0FTZ0NDQ0FFRUFvRVFDQUJJQUlnQXhBVER3c0NRQ0FBSUFFb0FnQWdCQkFLUlEwQUFrQWdBaUFCS0FJUVJ3UkFJQUVvQWhRZ0FrY05BUXNnQTBFQlJ3MEJJQUZCQVRZQ0lBOExJQUVnQWpZQ0ZDQUJJQU0yQWlBZ0FTQUJLQUlvUVFGcU5nSW9Ba0FnQVNnQ0pFRUJSdzBBSUFFb0FoaEJBa2NOQUNBQlFRRTZBRFlMSUFGQkJEWUNMQXNMOGdFQUlBQWdBU2dDQ0NBRUVBb0VRQ0FCSUFJZ0F4QVREd3NDUUNBQUlBRW9BZ0FnQkJBS0JFQUNRQ0FDSUFFb0FoQkhCRUFnQVNnQ0ZDQUNSdzBCQ3lBRFFRRkhEUUlnQVVFQk5nSWdEd3NnQVNBRE5nSWdBa0FnQVNnQ0xFRUVSZzBBSUFGQkFEc0JOQ0FBS0FJSUlnQWdBU0FDSUFKQkFTQUVJQUFvQWdBb0FoUVJBd0FnQVMwQU5RUkFJQUZCQXpZQ0xDQUJMUUEwUlEwQkRBTUxJQUZCQkRZQ0xBc2dBU0FDTmdJVUlBRWdBU2dDS0VFQmFqWUNLQ0FCS0FJa1FRRkhEUUVnQVNnQ0dFRUNSdzBCSUFGQkFUb0FOZzhMSUFBb0FnZ2lBQ0FCSUFJZ0F5QUVJQUFvQWdBb0FoZ1JBZ0FMQ3pFQUlBQWdBU2dDQ0VFQUVBb0VRQ0FCSUFJZ0F4QVZEd3NnQUNnQ0NDSUFJQUVnQWlBRElBQW9BZ0FvQWh3UkFBQUxHQUFnQUNBQktBSUlRUUFRQ2dSQUlBRWdBaUFERUJVTEM0QURBUVIvSXdCQjhBQnJJZ0lrQUNBQUtBSUFJZ05CQkdzb0FnQWhCQ0FEUVFocktBSUFJUVVnQWtJQU53SlFJQUpDQURjQ1dDQUNRZ0EzQW1BZ0FrSUFOd0JuSUFKQ0FEY0NTQ0FDUVFBMkFrUWdBa0g4RlRZQ1FDQUNJQUEyQWp3Z0FpQUJOZ0k0SUFBZ0JXb2hBd0pBSUFRZ0FVRUFFQW9FUUVFQUlBTWdCUnNoQUF3QkN5QUFJQU5PQkVBZ0FrSUFOd0F2SUFKQ0FEY0NHQ0FDUWdBM0FpQWdBa0lBTndJb0lBSkNBRGNDRUNBQ1FRQTJBZ3dnQWlBQk5nSUlJQUlnQURZQ0JDQUNJQVEyQWdBZ0FrRUJOZ0l3SUFRZ0FpQURJQU5CQVVFQUlBUW9BZ0FvQWhRUkF3QWdBaWdDR0EwQkMwRUFJUUFnQkNBQ1FUaHFJQU5CQVVFQUlBUW9BZ0FvQWhnUkFnQUNRQUpBSUFJb0Fsd09BZ0FCQWdzZ0FpZ0NURUVBSUFJb0FsaEJBVVliUVFBZ0FpZ0NWRUVCUmh0QkFDQUNLQUpnUVFGR0d5RUFEQUVMSUFJb0FsQkJBVWNFUUNBQ0tBSmdEUUVnQWlnQ1ZFRUJSdzBCSUFJb0FsaEJBVWNOQVFzZ0FpZ0NTQ0VBQ3lBQ1FmQUFhaVFBSUFBTG1RRUJBbjhqQUVGQWFpSURKQUFDZjBFQklBQWdBVUVBRUFvTkFCcEJBQ0FCUlEwQUdrRUFJQUZCckJZUUlDSUJSUTBBR2lBRFFReHFRVFFRRUNBRFFRRTJBamdnQTBGL05nSVVJQU1nQURZQ0VDQURJQUUyQWdnZ0FTQURRUWhxSUFJb0FnQkJBU0FCS0FJQUtBSWNFUUFBSUFNb0FpQWlBRUVCUmdSQUlBSWdBeWdDR0RZQ0FBc2dBRUVCUmdzaEJDQURRVUJySkFBZ0JBc0tBQ0FBSUFGQkFCQUtDd1FBSUFBTEM4Y1NBZ0JCZ0FnTHRoSjFibk5wWjI1bFpDQnphRzl5ZEFCMWJuTnBaMjVsWkNCcGJuUUFabXh2WVhRQWRXbHVkRFkwWDNRQWRXNXphV2R1WldRZ1kyaGhjZ0JpYjI5c0FHVnRjMk55YVhCMFpXNDZPblpoYkFCMWJuTnBaMjVsWkNCc2IyNW5BSE4wWkRvNmQzTjBjbWx1WndCemRHUTZPbk4wY21sdVp3QnpkR1E2T25VeE5uTjBjbWx1WndCemRHUTZPblV6TW5OMGNtbHVad0JrYjNWaWJHVUFkbTlwWkFCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkenh6YUc5eWRENEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGRXNXphV2R1WldRZ2MyaHZjblErQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQR2x1ZEQ0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4ZFc1emFXZHVaV1FnYVc1MFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4bWJHOWhkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhkV2x1ZERoZmRENEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGFXNTBPRjkwUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkengxYVc1ME1UWmZkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhhVzUwTVRaZmRENEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGRXbHVkRFkwWDNRK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEdsdWREWTBYM1ErQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQSFZwYm5Rek1sOTBQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eHBiblF6TWw5MFBnQmxiWE5qY21sd2RHVnVPanB0WlcxdmNubGZkbWxsZHp4amFHRnlQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eDFibk5wWjI1bFpDQmphR0Z5UGdCemRHUTZPbUpoYzJsalgzTjBjbWx1Wnp4MWJuTnBaMjVsWkNCamFHRnlQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eHphV2R1WldRZ1kyaGhjajRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhiRzl1Wno0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4ZFc1emFXZHVaV1FnYkc5dVp6NEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOFpHOTFZbXhsUGdCT1UzUXpYMTh5TVRKaVlYTnBZMTl6ZEhKcGJtZEpZMDVUWHpFeFkyaGhjbDkwY21GcGRITkpZMFZGVGxOZk9XRnNiRzlqWVhSdmNrbGpSVVZGUlFBQUFBQ2tEQUFBUWdjQUFFNVRkRE5mWHpJeE1tSmhjMmxqWDNOMGNtbHVaMGxvVGxOZk1URmphR0Z5WDNSeVlXbDBjMGxvUlVWT1UxODVZV3hzYjJOaGRHOXlTV2hGUlVWRkFBQ2tEQUFBakFjQUFFNVRkRE5mWHpJeE1tSmhjMmxqWDNOMGNtbHVaMGwzVGxOZk1URmphR0Z5WDNSeVlXbDBjMGwzUlVWT1UxODVZV3hzYjJOaGRHOXlTWGRGUlVWRkFBQ2tEQUFBMUFjQUFFNVRkRE5mWHpJeE1tSmhjMmxqWDNOMGNtbHVaMGxFYzA1VFh6RXhZMmhoY2w5MGNtRnBkSE5KUkhORlJVNVRYemxoYkd4dlkyRjBiM0pKUkhORlJVVkZBQUFBcEF3QUFCd0lBQUJPVTNRelgxOHlNVEppWVhOcFkxOXpkSEpwYm1kSlJHbE9VMTh4TVdOb1lYSmZkSEpoYVhSelNVUnBSVVZPVTE4NVlXeHNiMk5oZEc5eVNVUnBSVVZGUlFBQUFLUU1BQUJvQ0FBQVRqRXdaVzF6WTNKcGNIUmxiak4yWVd4RkFBQ2tEQUFBdEFnQUFFNHhNR1Z0YzJOeWFYQjBaVzR4TVcxbGJXOXllVjkyYVdWM1NXTkZSUUFBcEF3QUFOQUlBQUJPTVRCbGJYTmpjbWx3ZEdWdU1URnRaVzF2Y25sZmRtbGxkMGxoUlVVQUFLUU1BQUQ0Q0FBQVRqRXdaVzF6WTNKcGNIUmxiakV4YldWdGIzSjVYM1pwWlhkSmFFVkZBQUNrREFBQUlBa0FBRTR4TUdWdGMyTnlhWEIwWlc0eE1XMWxiVzl5ZVY5MmFXVjNTWE5GUlFBQXBBd0FBRWdKQUFCT01UQmxiWE5qY21sd2RHVnVNVEZ0WlcxdmNubGZkbWxsZDBsMFJVVUFBS1FNQUFCd0NRQUFUakV3WlcxelkzSnBjSFJsYmpFeGJXVnRiM0o1WDNacFpYZEphVVZGQUFDa0RBQUFtQWtBQUU0eE1HVnRjMk55YVhCMFpXNHhNVzFsYlc5eWVWOTJhV1YzU1dwRlJRQUFwQXdBQU1BSkFBQk9NVEJsYlhOamNtbHdkR1Z1TVRGdFpXMXZjbmxmZG1sbGQwbHNSVVVBQUtRTUFBRG9DUUFBVGpFd1pXMXpZM0pwY0hSbGJqRXhiV1Z0YjNKNVgzWnBaWGRKYlVWRkFBQ2tEQUFBRUFvQUFFNHhNR1Z0YzJOeWFYQjBaVzR4TVcxbGJXOXllVjkyYVdWM1NYaEZSUUFBcEF3QUFEZ0tBQUJPTVRCbGJYTmpjbWx3ZEdWdU1URnRaVzF2Y25sZmRtbGxkMGw1UlVVQUFLUU1BQUJnQ2dBQVRqRXdaVzF6WTNKcGNIUmxiakV4YldWdGIzSjVYM1pwWlhkSlprVkZBQUNrREFBQWlBb0FBRTR4TUdWdGMyTnlhWEIwWlc0eE1XMWxiVzl5ZVY5MmFXVjNTV1JGUlFBQXBBd0FBTEFLQUFCT01UQmZYMk40ZUdGaWFYWXhNVFpmWDNOb2FXMWZkSGx3WlY5cGJtWnZSUUFBQUFETURBQUEyQW9BQURBTkFBQk9NVEJmWDJONGVHRmlhWFl4TVRkZlgyTnNZWE56WDNSNWNHVmZhVzVtYjBVQUFBRE1EQUFBQ0FzQUFQd0tBQUJPTVRCZlgyTjRlR0ZpYVhZeE1UZGZYM0JpWVhObFgzUjVjR1ZmYVc1bWIwVUFBQURNREFBQU9Bc0FBUHdLQUFCT01UQmZYMk40ZUdGaWFYWXhNVGxmWDNCdmFXNTBaWEpmZEhsd1pWOXBibVp2UlFETURBQUFhQXNBQUZ3TEFBQUFBQUFBM0FzQUFBSUFBQUFEQUFBQUJBQUFBQVVBQUFBR0FBQUFUakV3WDE5amVIaGhZbWwyTVRJelgxOW1kVzVrWVcxbGJuUmhiRjkwZVhCbFgybHVabTlGQU13TUFBQzBDd0FBL0FvQUFIWUFBQUNnQ3dBQTZBc0FBR0lBQUFDZ0N3QUE5QXNBQUdNQUFBQ2dDd0FBQUF3QUFHZ0FBQUNnQ3dBQURBd0FBR0VBQUFDZ0N3QUFHQXdBQUhNQUFBQ2dDd0FBSkF3QUFIUUFBQUNnQ3dBQU1Bd0FBR2tBQUFDZ0N3QUFQQXdBQUdvQUFBQ2dDd0FBU0F3QUFHd0FBQUNnQ3dBQVZBd0FBRzBBQUFDZ0N3QUFZQXdBQUhnQUFBQ2dDd0FBYkF3QUFIa0FBQUNnQ3dBQWVBd0FBR1lBQUFDZ0N3QUFoQXdBQUdRQUFBQ2dDd0FBa0F3QUFBQUFBQUFzQ3dBQUFnQUFBQWNBQUFBRUFBQUFCUUFBQUFnQUFBQUpBQUFBQ2dBQUFBc0FBQUFBQUFBQUZBMEFBQUlBQUFBTUFBQUFCQUFBQUFVQUFBQUlBQUFBRFFBQUFBNEFBQUFQQUFBQVRqRXdYMTlqZUhoaFltbDJNVEl3WDE5emFWOWpiR0Z6YzE5MGVYQmxYMmx1Wm05RkFBQUFBTXdNQUFEc0RBQUFMQXNBQUZOME9YUjVjR1ZmYVc1bWJ3QUFBQUNrREFBQUlBMEFRYmdhQ3dOQUR3RT0iO2lmKCFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpKXt3YXNtQmluYXJ5RmlsZT1sb2NhdGVGaWxlKHdhc21CaW5hcnlGaWxlKTt9ZnVuY3Rpb24gZ2V0QmluYXJ5U3luYyhmaWxlKXtpZihmaWxlPT13YXNtQmluYXJ5RmlsZSYmd2FzbUJpbmFyeSl7cmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpfXZhciBiaW5hcnk9dHJ5UGFyc2VBc0RhdGFVUkkoZmlsZSk7aWYoYmluYXJ5KXtyZXR1cm4gYmluYXJ5fWlmKHJlYWRCaW5hcnkpe3JldHVybiByZWFkQmluYXJ5KGZpbGUpfXRocm93ICJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZCJ9ZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+Z2V0QmluYXJ5U3luYyhiaW5hcnlGaWxlKSl9ZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLGltcG9ydHMscmVjZWl2ZXIpe3JldHVybiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpLnRoZW4oYmluYXJ5PT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnksaW1wb3J0cykpLnRoZW4oaW5zdGFuY2U9Pmluc3RhbmNlKS50aGVuKHJlY2VpdmVyLHJlYXNvbj0+e2VycihgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHtyZWFzb259YCk7YWJvcnQocmVhc29uKTt9KX1mdW5jdGlvbiBpbnN0YW50aWF0ZUFzeW5jKGJpbmFyeSxiaW5hcnlGaWxlLGltcG9ydHMsY2FsbGJhY2spe3JldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsaW1wb3J0cyxjYWxsYmFjayl9ZnVuY3Rpb24gY3JlYXRlV2FzbSgpe3ZhciBpbmZvPXsiYSI6d2FzbUltcG9ydHN9O2Z1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSxtb2R1bGUpe3dhc21FeHBvcnRzPWluc3RhbmNlLmV4cG9ydHM7d2FzbU1lbW9yeT13YXNtRXhwb3J0c1siayJdO3VwZGF0ZU1lbW9yeVZpZXdzKCk7YWRkT25Jbml0KHdhc21FeHBvcnRzWyJsIl0pO3JlbW92ZVJ1bkRlcGVuZGVuY3koKTtyZXR1cm4gd2FzbUV4cG9ydHN9YWRkUnVuRGVwZW5kZW5jeSgpO2Z1bmN0aW9uIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KHJlc3VsdCl7cmVjZWl2ZUluc3RhbmNlKHJlc3VsdFsiaW5zdGFuY2UiXSk7fWlmKE1vZHVsZVsiaW5zdGFudGlhdGVXYXNtIl0pe3RyeXtyZXR1cm4gTW9kdWxlWyJpbnN0YW50aWF0ZVdhc20iXShpbmZvLHJlY2VpdmVJbnN0YW5jZSl9Y2F0Y2goZSl7ZXJyKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke2V9YCk7cmVhZHlQcm9taXNlUmVqZWN0KGUpO319aW5zdGFudGlhdGVBc3luYyh3YXNtQmluYXJ5LHdhc21CaW5hcnlGaWxlLGluZm8scmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQpLmNhdGNoKHJlYWR5UHJvbWlzZVJlamVjdCk7cmV0dXJuIHt9fXZhciBjYWxsUnVudGltZUNhbGxiYWNrcz1jYWxsYmFja3M9Pnt3aGlsZShjYWxsYmFja3MubGVuZ3RoPjApe2NhbGxiYWNrcy5zaGlmdCgpKE1vZHVsZSk7fX07TW9kdWxlWyJub0V4aXRSdW50aW1lIl18fHRydWU7dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2JpZ2ludD0ocHJpbWl0aXZlVHlwZSxuYW1lLHNpemUsbWluUmFuZ2UsbWF4UmFuZ2UpPT57fTt2YXIgZW1iaW5kX2luaXRfY2hhckNvZGVzPSgpPT57dmFyIGNvZGVzPW5ldyBBcnJheSgyNTYpO2Zvcih2YXIgaT0wO2k8MjU2OysraSl7Y29kZXNbaV09U3RyaW5nLmZyb21DaGFyQ29kZShpKTt9ZW1iaW5kX2NoYXJDb2Rlcz1jb2Rlczt9O3ZhciBlbWJpbmRfY2hhckNvZGVzO3ZhciByZWFkTGF0aW4xU3RyaW5nPXB0cj0+e3ZhciByZXQ9IiI7dmFyIGM9cHRyO3doaWxlKEhFQVBVOFtjXSl7cmV0Kz1lbWJpbmRfY2hhckNvZGVzW0hFQVBVOFtjKytdXTt9cmV0dXJuIHJldH07dmFyIGF3YWl0aW5nRGVwZW5kZW5jaWVzPXt9O3ZhciByZWdpc3RlcmVkVHlwZXM9e307dmFyIEJpbmRpbmdFcnJvcjt2YXIgdGhyb3dCaW5kaW5nRXJyb3I9bWVzc2FnZT0+e3Rocm93IG5ldyBCaW5kaW5nRXJyb3IobWVzc2FnZSl9O2Z1bmN0aW9uIHNoYXJlZFJlZ2lzdGVyVHlwZShyYXdUeXBlLHJlZ2lzdGVyZWRJbnN0YW5jZSxvcHRpb25zPXt9KXt2YXIgbmFtZT1yZWdpc3RlcmVkSW5zdGFuY2UubmFtZTtpZighcmF3VHlwZSl7dGhyb3dCaW5kaW5nRXJyb3IoYHR5cGUgIiR7bmFtZX0iIG11c3QgaGF2ZSBhIHBvc2l0aXZlIGludGVnZXIgdHlwZWlkIHBvaW50ZXJgKTt9aWYocmVnaXN0ZXJlZFR5cGVzLmhhc093blByb3BlcnR5KHJhd1R5cGUpKXtpZihvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZVJlZ2lzdHJhdGlvbnMpe3JldHVybn1lbHNlIHt0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHJlZ2lzdGVyIHR5cGUgJyR7bmFtZX0nIHR3aWNlYCk7fX1yZWdpc3RlcmVkVHlwZXNbcmF3VHlwZV09cmVnaXN0ZXJlZEluc3RhbmNlO2lmKGF3YWl0aW5nRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHJhd1R5cGUpKXt2YXIgY2FsbGJhY2tzPWF3YWl0aW5nRGVwZW5kZW5jaWVzW3Jhd1R5cGVdO2RlbGV0ZSBhd2FpdGluZ0RlcGVuZGVuY2llc1tyYXdUeXBlXTtjYWxsYmFja3MuZm9yRWFjaChjYj0+Y2IoKSk7fX1mdW5jdGlvbiByZWdpc3RlclR5cGUocmF3VHlwZSxyZWdpc3RlcmVkSW5zdGFuY2Usb3B0aW9ucz17fSl7aWYoISgiYXJnUGFja0FkdmFuY2UiaW4gcmVnaXN0ZXJlZEluc3RhbmNlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcigicmVnaXN0ZXJUeXBlIHJlZ2lzdGVyZWRJbnN0YW5jZSByZXF1aXJlcyBhcmdQYWNrQWR2YW5jZSIpfXJldHVybiBzaGFyZWRSZWdpc3RlclR5cGUocmF3VHlwZSxyZWdpc3RlcmVkSW5zdGFuY2Usb3B0aW9ucyl9dmFyIEdlbmVyaWNXaXJlVHlwZVNpemU9ODt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfYm9vbD0ocmF3VHlwZSxuYW1lLHRydWVWYWx1ZSxmYWxzZVZhbHVlKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLCJmcm9tV2lyZVR5cGUiOmZ1bmN0aW9uKHd0KXtyZXR1cm4gISF3dH0sInRvV2lyZVR5cGUiOmZ1bmN0aW9uKGRlc3RydWN0b3JzLG8pe3JldHVybiBvP3RydWVWYWx1ZTpmYWxzZVZhbHVlfSwiYXJnUGFja0FkdmFuY2UiOkdlbmVyaWNXaXJlVHlwZVNpemUsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjpmdW5jdGlvbihwb2ludGVyKXtyZXR1cm4gdGhpc1siZnJvbVdpcmVUeXBlIl0oSEVBUFU4W3BvaW50ZXJdKX0sZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KTt9O2Z1bmN0aW9uIGhhbmRsZUFsbG9jYXRvckluaXQoKXtPYmplY3QuYXNzaWduKEhhbmRsZUFsbG9jYXRvci5wcm90b3R5cGUse2dldChpZCl7cmV0dXJuIHRoaXMuYWxsb2NhdGVkW2lkXX0saGFzKGlkKXtyZXR1cm4gdGhpcy5hbGxvY2F0ZWRbaWRdIT09dW5kZWZpbmVkfSxhbGxvY2F0ZShoYW5kbGUpe3ZhciBpZD10aGlzLmZyZWVsaXN0LnBvcCgpfHx0aGlzLmFsbG9jYXRlZC5sZW5ndGg7dGhpcy5hbGxvY2F0ZWRbaWRdPWhhbmRsZTtyZXR1cm4gaWR9LGZyZWUoaWQpe3RoaXMuYWxsb2NhdGVkW2lkXT11bmRlZmluZWQ7dGhpcy5mcmVlbGlzdC5wdXNoKGlkKTt9fSk7fWZ1bmN0aW9uIEhhbmRsZUFsbG9jYXRvcigpe3RoaXMuYWxsb2NhdGVkPVt1bmRlZmluZWRdO3RoaXMuZnJlZWxpc3Q9W107fXZhciBlbXZhbF9oYW5kbGVzPW5ldyBIYW5kbGVBbGxvY2F0b3I7dmFyIF9fZW12YWxfZGVjcmVmPWhhbmRsZT0+e2lmKGhhbmRsZT49ZW12YWxfaGFuZGxlcy5yZXNlcnZlZCYmMD09PS0tZW12YWxfaGFuZGxlcy5nZXQoaGFuZGxlKS5yZWZjb3VudCl7ZW12YWxfaGFuZGxlcy5mcmVlKGhhbmRsZSk7fX07dmFyIGNvdW50X2VtdmFsX2hhbmRsZXM9KCk9Pnt2YXIgY291bnQ9MDtmb3IodmFyIGk9ZW12YWxfaGFuZGxlcy5yZXNlcnZlZDtpPGVtdmFsX2hhbmRsZXMuYWxsb2NhdGVkLmxlbmd0aDsrK2kpe2lmKGVtdmFsX2hhbmRsZXMuYWxsb2NhdGVkW2ldIT09dW5kZWZpbmVkKXsrK2NvdW50O319cmV0dXJuIGNvdW50fTt2YXIgaW5pdF9lbXZhbD0oKT0+e2VtdmFsX2hhbmRsZXMuYWxsb2NhdGVkLnB1c2goe3ZhbHVlOnVuZGVmaW5lZH0se3ZhbHVlOm51bGx9LHt2YWx1ZTp0cnVlfSx7dmFsdWU6ZmFsc2V9KTtlbXZhbF9oYW5kbGVzLnJlc2VydmVkPWVtdmFsX2hhbmRsZXMuYWxsb2NhdGVkLmxlbmd0aDtNb2R1bGVbImNvdW50X2VtdmFsX2hhbmRsZXMiXT1jb3VudF9lbXZhbF9oYW5kbGVzO307dmFyIEVtdmFsPXt0b1ZhbHVlOmhhbmRsZT0+e2lmKCFoYW5kbGUpe3Rocm93QmluZGluZ0Vycm9yKCJDYW5ub3QgdXNlIGRlbGV0ZWQgdmFsLiBoYW5kbGUgPSAiK2hhbmRsZSk7fXJldHVybiBlbXZhbF9oYW5kbGVzLmdldChoYW5kbGUpLnZhbHVlfSx0b0hhbmRsZTp2YWx1ZT0+e3N3aXRjaCh2YWx1ZSl7Y2FzZSB1bmRlZmluZWQ6cmV0dXJuIDE7Y2FzZSBudWxsOnJldHVybiAyO2Nhc2UgdHJ1ZTpyZXR1cm4gMztjYXNlIGZhbHNlOnJldHVybiA0O2RlZmF1bHQ6e3JldHVybiBlbXZhbF9oYW5kbGVzLmFsbG9jYXRlKHtyZWZjb3VudDoxLHZhbHVlOnZhbHVlfSl9fX19O2Z1bmN0aW9uIHNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyKHBvaW50ZXIpe3JldHVybiB0aGlzWyJmcm9tV2lyZVR5cGUiXShIRUFQMzJbcG9pbnRlcj4+Ml0pfXZhciBfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbD0ocmF3VHlwZSxuYW1lKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLCJmcm9tV2lyZVR5cGUiOmhhbmRsZT0+e3ZhciBydj1FbXZhbC50b1ZhbHVlKGhhbmRsZSk7X19lbXZhbF9kZWNyZWYoaGFuZGxlKTtyZXR1cm4gcnZ9LCJ0b1dpcmVUeXBlIjooZGVzdHJ1Y3RvcnMsdmFsdWUpPT5FbXZhbC50b0hhbmRsZSh2YWx1ZSksImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6c2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIsZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KTt9O3ZhciBmbG9hdFJlYWRWYWx1ZUZyb21Qb2ludGVyPShuYW1lLHdpZHRoKT0+e3N3aXRjaCh3aWR0aCl7Y2FzZSA0OnJldHVybiBmdW5jdGlvbihwb2ludGVyKXtyZXR1cm4gdGhpc1siZnJvbVdpcmVUeXBlIl0oSEVBUEYzMltwb2ludGVyPj4yXSl9O2Nhc2UgODpyZXR1cm4gZnVuY3Rpb24ocG9pbnRlcil7cmV0dXJuIHRoaXNbImZyb21XaXJlVHlwZSJdKEhFQVBGNjRbcG9pbnRlcj4+M10pfTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgZmxvYXQgd2lkdGggKCR7d2lkdGh9KTogJHtuYW1lfWApfX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0PShyYXdUeXBlLG5hbWUsc2l6ZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjp2YWx1ZT0+dmFsdWUsInRvV2lyZVR5cGUiOihkZXN0cnVjdG9ycyx2YWx1ZSk9PnZhbHVlLCJhcmdQYWNrQWR2YW5jZSI6R2VuZXJpY1dpcmVUeXBlU2l6ZSwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOmZsb2F0UmVhZFZhbHVlRnJvbVBvaW50ZXIobmFtZSxzaXplKSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pO307dmFyIGludGVnZXJSZWFkVmFsdWVGcm9tUG9pbnRlcj0obmFtZSx3aWR0aCxzaWduZWQpPT57c3dpdGNoKHdpZHRoKXtjYXNlIDE6cmV0dXJuIHNpZ25lZD9wb2ludGVyPT5IRUFQOFtwb2ludGVyPj4wXTpwb2ludGVyPT5IRUFQVThbcG9pbnRlcj4+MF07Y2FzZSAyOnJldHVybiBzaWduZWQ/cG9pbnRlcj0+SEVBUDE2W3BvaW50ZXI+PjFdOnBvaW50ZXI9PkhFQVBVMTZbcG9pbnRlcj4+MV07Y2FzZSA0OnJldHVybiBzaWduZWQ/cG9pbnRlcj0+SEVBUDMyW3BvaW50ZXI+PjJdOnBvaW50ZXI9PkhFQVBVMzJbcG9pbnRlcj4+Ml07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGludGVnZXIgd2lkdGggKCR7d2lkdGh9KTogJHtuYW1lfWApfX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXI9KHByaW1pdGl2ZVR5cGUsbmFtZSxzaXplLG1pblJhbmdlLG1heFJhbmdlKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTt2YXIgZnJvbVdpcmVUeXBlPXZhbHVlPT52YWx1ZTtpZihtaW5SYW5nZT09PTApe3ZhciBiaXRzaGlmdD0zMi04KnNpemU7ZnJvbVdpcmVUeXBlPXZhbHVlPT52YWx1ZTw8Yml0c2hpZnQ+Pj5iaXRzaGlmdDt9dmFyIGlzVW5zaWduZWRUeXBlPW5hbWUuaW5jbHVkZXMoInVuc2lnbmVkIik7dmFyIGNoZWNrQXNzZXJ0aW9ucz0odmFsdWUsdG9UeXBlTmFtZSk9Pnt9O3ZhciB0b1dpcmVUeXBlO2lmKGlzVW5zaWduZWRUeXBlKXt0b1dpcmVUeXBlPWZ1bmN0aW9uKGRlc3RydWN0b3JzLHZhbHVlKXtjaGVja0Fzc2VydGlvbnModmFsdWUsdGhpcy5uYW1lKTtyZXR1cm4gdmFsdWU+Pj4wfTt9ZWxzZSB7dG9XaXJlVHlwZT1mdW5jdGlvbihkZXN0cnVjdG9ycyx2YWx1ZSl7Y2hlY2tBc3NlcnRpb25zKHZhbHVlLHRoaXMubmFtZSk7cmV0dXJuIHZhbHVlfTt9cmVnaXN0ZXJUeXBlKHByaW1pdGl2ZVR5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjpmcm9tV2lyZVR5cGUsInRvV2lyZVR5cGUiOnRvV2lyZVR5cGUsImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6aW50ZWdlclJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsc2l6ZSxtaW5SYW5nZSE9PTApLGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSk7fTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXc9KHJhd1R5cGUsZGF0YVR5cGVJbmRleCxuYW1lKT0+e3ZhciB0eXBlTWFwcGluZz1bSW50OEFycmF5LFVpbnQ4QXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXldO3ZhciBUQT10eXBlTWFwcGluZ1tkYXRhVHlwZUluZGV4XTtmdW5jdGlvbiBkZWNvZGVNZW1vcnlWaWV3KGhhbmRsZSl7dmFyIHNpemU9SEVBUFUzMltoYW5kbGU+PjJdO3ZhciBkYXRhPUhFQVBVMzJbaGFuZGxlKzQ+PjJdO3JldHVybiBuZXcgVEEoSEVBUDguYnVmZmVyLGRhdGEsc2l6ZSl9bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsImZyb21XaXJlVHlwZSI6ZGVjb2RlTWVtb3J5VmlldywiYXJnUGFja0FkdmFuY2UiOkdlbmVyaWNXaXJlVHlwZVNpemUsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjpkZWNvZGVNZW1vcnlWaWV3fSx7aWdub3JlRHVwbGljYXRlUmVnaXN0cmF0aW9uczp0cnVlfSk7fTtmdW5jdGlvbiByZWFkUG9pbnRlcihwb2ludGVyKXtyZXR1cm4gdGhpc1siZnJvbVdpcmVUeXBlIl0oSEVBUFUzMltwb2ludGVyPj4yXSl9dmFyIHN0cmluZ1RvVVRGOEFycmF5PShzdHIsaGVhcCxvdXRJZHgsbWF4Qnl0ZXNUb1dyaXRlKT0+e2lmKCEobWF4Qnl0ZXNUb1dyaXRlPjApKXJldHVybiAwO3ZhciBzdGFydElkeD1vdXRJZHg7dmFyIGVuZElkeD1vdXRJZHgrbWF4Qnl0ZXNUb1dyaXRlLTE7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIHU9c3RyLmNoYXJDb2RlQXQoaSk7aWYodT49NTUyOTYmJnU8PTU3MzQzKXt2YXIgdTE9c3RyLmNoYXJDb2RlQXQoKytpKTt1PTY1NTM2KygodSYxMDIzKTw8MTApfHUxJjEwMjM7fWlmKHU8PTEyNyl7aWYob3V0SWR4Pj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109dTt9ZWxzZSBpZih1PD0yMDQ3KXtpZihvdXRJZHgrMT49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPTE5Mnx1Pj42O2hlYXBbb3V0SWR4KytdPTEyOHx1JjYzO31lbHNlIGlmKHU8PTY1NTM1KXtpZihvdXRJZHgrMj49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPTIyNHx1Pj4xMjtoZWFwW291dElkeCsrXT0xMjh8dT4+NiY2MztoZWFwW291dElkeCsrXT0xMjh8dSY2Mzt9ZWxzZSB7aWYob3V0SWR4KzM+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT0yNDB8dT4+MTg7aGVhcFtvdXRJZHgrK109MTI4fHU+PjEyJjYzO2hlYXBbb3V0SWR4KytdPTEyOHx1Pj42JjYzO2hlYXBbb3V0SWR4KytdPTEyOHx1JjYzO319aGVhcFtvdXRJZHhdPTA7cmV0dXJuIG91dElkeC1zdGFydElkeH07dmFyIHN0cmluZ1RvVVRGOD0oc3RyLG91dFB0cixtYXhCeXRlc1RvV3JpdGUpPT5zdHJpbmdUb1VURjhBcnJheShzdHIsSEVBUFU4LG91dFB0cixtYXhCeXRlc1RvV3JpdGUpO3ZhciBsZW5ndGhCeXRlc1VURjg9c3RyPT57dmFyIGxlbj0wO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciBjPXN0ci5jaGFyQ29kZUF0KGkpO2lmKGM8PTEyNyl7bGVuKys7fWVsc2UgaWYoYzw9MjA0Nyl7bGVuKz0yO31lbHNlIGlmKGM+PTU1Mjk2JiZjPD01NzM0Myl7bGVuKz00OysraTt9ZWxzZSB7bGVuKz0zO319cmV0dXJuIGxlbn07dmFyIFVURjhEZWNvZGVyPXR5cGVvZiBUZXh0RGVjb2RlciE9InVuZGVmaW5lZCI/bmV3IFRleHREZWNvZGVyKCJ1dGY4Iik6dW5kZWZpbmVkO3ZhciBVVEY4QXJyYXlUb1N0cmluZz0oaGVhcE9yQXJyYXksaWR4LG1heEJ5dGVzVG9SZWFkKT0+e3ZhciBlbmRJZHg9aWR4K21heEJ5dGVzVG9SZWFkO3ZhciBlbmRQdHI9aWR4O3doaWxlKGhlYXBPckFycmF5W2VuZFB0cl0mJiEoZW5kUHRyPj1lbmRJZHgpKSsrZW5kUHRyO2lmKGVuZFB0ci1pZHg+MTYmJmhlYXBPckFycmF5LmJ1ZmZlciYmVVRGOERlY29kZXIpe3JldHVybiBVVEY4RGVjb2Rlci5kZWNvZGUoaGVhcE9yQXJyYXkuc3ViYXJyYXkoaWR4LGVuZFB0cikpfXZhciBzdHI9IiI7d2hpbGUoaWR4PGVuZFB0cil7dmFyIHUwPWhlYXBPckFycmF5W2lkeCsrXTtpZighKHUwJjEyOCkpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7Y29udGludWV9dmFyIHUxPWhlYXBPckFycmF5W2lkeCsrXSY2MztpZigodTAmMjI0KT09MTkyKXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKHUwJjMxKTw8Nnx1MSk7Y29udGludWV9dmFyIHUyPWhlYXBPckFycmF5W2lkeCsrXSY2MztpZigodTAmMjQwKT09MjI0KXt1MD0odTAmMTUpPDwxMnx1MTw8Nnx1Mjt9ZWxzZSB7dTA9KHUwJjcpPDwxOHx1MTw8MTJ8dTI8PDZ8aGVhcE9yQXJyYXlbaWR4KytdJjYzO31pZih1MDw2NTUzNil7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTt9ZWxzZSB7dmFyIGNoPXUwLTY1NTM2O3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxjaD4+MTAsNTYzMjB8Y2gmMTAyMyk7fX1yZXR1cm4gc3RyfTt2YXIgVVRGOFRvU3RyaW5nPShwdHIsbWF4Qnl0ZXNUb1JlYWQpPT5wdHI/VVRGOEFycmF5VG9TdHJpbmcoSEVBUFU4LHB0cixtYXhCeXRlc1RvUmVhZCk6IiI7dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmc9KHJhd1R5cGUsbmFtZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7dmFyIHN0ZFN0cmluZ0lzVVRGOD1uYW1lPT09InN0ZDo6c3RyaW5nIjtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLCJmcm9tV2lyZVR5cGUiKHZhbHVlKXt2YXIgbGVuZ3RoPUhFQVBVMzJbdmFsdWU+PjJdO3ZhciBwYXlsb2FkPXZhbHVlKzQ7dmFyIHN0cjtpZihzdGRTdHJpbmdJc1VURjgpe3ZhciBkZWNvZGVTdGFydFB0cj1wYXlsb2FkO2Zvcih2YXIgaT0wO2k8PWxlbmd0aDsrK2kpe3ZhciBjdXJyZW50Qnl0ZVB0cj1wYXlsb2FkK2k7aWYoaT09bGVuZ3RofHxIRUFQVThbY3VycmVudEJ5dGVQdHJdPT0wKXt2YXIgbWF4UmVhZD1jdXJyZW50Qnl0ZVB0ci1kZWNvZGVTdGFydFB0cjt2YXIgc3RyaW5nU2VnbWVudD1VVEY4VG9TdHJpbmcoZGVjb2RlU3RhcnRQdHIsbWF4UmVhZCk7aWYoc3RyPT09dW5kZWZpbmVkKXtzdHI9c3RyaW5nU2VnbWVudDt9ZWxzZSB7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDApO3N0cis9c3RyaW5nU2VnbWVudDt9ZGVjb2RlU3RhcnRQdHI9Y3VycmVudEJ5dGVQdHIrMTt9fX1lbHNlIHt2YXIgYT1uZXcgQXJyYXkobGVuZ3RoKTtmb3IodmFyIGk9MDtpPGxlbmd0aDsrK2kpe2FbaV09U3RyaW5nLmZyb21DaGFyQ29kZShIRUFQVThbcGF5bG9hZCtpXSk7fXN0cj1hLmpvaW4oIiIpO31fZnJlZSh2YWx1ZSk7cmV0dXJuIHN0cn0sInRvV2lyZVR5cGUiKGRlc3RydWN0b3JzLHZhbHVlKXtpZih2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXt2YWx1ZT1uZXcgVWludDhBcnJheSh2YWx1ZSk7fXZhciBsZW5ndGg7dmFyIHZhbHVlSXNPZlR5cGVTdHJpbmc9dHlwZW9mIHZhbHVlPT0ic3RyaW5nIjtpZighKHZhbHVlSXNPZlR5cGVTdHJpbmd8fHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheXx8dmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheXx8dmFsdWUgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpKXt0aHJvd0JpbmRpbmdFcnJvcigiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZyIpO31pZihzdGRTdHJpbmdJc1VURjgmJnZhbHVlSXNPZlR5cGVTdHJpbmcpe2xlbmd0aD1sZW5ndGhCeXRlc1VURjgodmFsdWUpO31lbHNlIHtsZW5ndGg9dmFsdWUubGVuZ3RoO312YXIgYmFzZT1fbWFsbG9jKDQrbGVuZ3RoKzEpO3ZhciBwdHI9YmFzZSs0O0hFQVBVMzJbYmFzZT4+Ml09bGVuZ3RoO2lmKHN0ZFN0cmluZ0lzVVRGOCYmdmFsdWVJc09mVHlwZVN0cmluZyl7c3RyaW5nVG9VVEY4KHZhbHVlLHB0cixsZW5ndGgrMSk7fWVsc2Uge2lmKHZhbHVlSXNPZlR5cGVTdHJpbmcpe2Zvcih2YXIgaT0wO2k8bGVuZ3RoOysraSl7dmFyIGNoYXJDb2RlPXZhbHVlLmNoYXJDb2RlQXQoaSk7aWYoY2hhckNvZGU+MjU1KXtfZnJlZShwdHIpO3Rocm93QmluZGluZ0Vycm9yKCJTdHJpbmcgaGFzIFVURi0xNiBjb2RlIHVuaXRzIHRoYXQgZG8gbm90IGZpdCBpbiA4IGJpdHMiKTt9SEVBUFU4W3B0citpXT1jaGFyQ29kZTt9fWVsc2Uge2Zvcih2YXIgaT0wO2k8bGVuZ3RoOysraSl7SEVBUFU4W3B0citpXT12YWx1ZVtpXTt9fX1pZihkZXN0cnVjdG9ycyE9PW51bGwpe2Rlc3RydWN0b3JzLnB1c2goX2ZyZWUsYmFzZSk7fXJldHVybiBiYXNlfSwiYXJnUGFja0FkdmFuY2UiOkdlbmVyaWNXaXJlVHlwZVNpemUsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjpyZWFkUG9pbnRlcixkZXN0cnVjdG9yRnVuY3Rpb24ocHRyKXtfZnJlZShwdHIpO319KTt9O3ZhciBVVEYxNkRlY29kZXI9dHlwZW9mIFRleHREZWNvZGVyIT0idW5kZWZpbmVkIj9uZXcgVGV4dERlY29kZXIoInV0Zi0xNmxlIik6dW5kZWZpbmVkO3ZhciBVVEYxNlRvU3RyaW5nPShwdHIsbWF4Qnl0ZXNUb1JlYWQpPT57dmFyIGVuZFB0cj1wdHI7dmFyIGlkeD1lbmRQdHI+PjE7dmFyIG1heElkeD1pZHgrbWF4Qnl0ZXNUb1JlYWQvMjt3aGlsZSghKGlkeD49bWF4SWR4KSYmSEVBUFUxNltpZHhdKSsraWR4O2VuZFB0cj1pZHg8PDE7aWYoZW5kUHRyLXB0cj4zMiYmVVRGMTZEZWNvZGVyKXJldHVybiBVVEYxNkRlY29kZXIuZGVjb2RlKEhFQVBVOC5zdWJhcnJheShwdHIsZW5kUHRyKSk7dmFyIHN0cj0iIjtmb3IodmFyIGk9MDshKGk+PW1heEJ5dGVzVG9SZWFkLzIpOysraSl7dmFyIGNvZGVVbml0PUhFQVAxNltwdHIraSoyPj4xXTtpZihjb2RlVW5pdD09MClicmVhaztzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVVuaXQpO31yZXR1cm4gc3RyfTt2YXIgc3RyaW5nVG9VVEYxNj0oc3RyLG91dFB0cixtYXhCeXRlc1RvV3JpdGUpPT57bWF4Qnl0ZXNUb1dyaXRlPz89MjE0NzQ4MzY0NztpZihtYXhCeXRlc1RvV3JpdGU8MilyZXR1cm4gMDttYXhCeXRlc1RvV3JpdGUtPTI7dmFyIHN0YXJ0UHRyPW91dFB0cjt2YXIgbnVtQ2hhcnNUb1dyaXRlPW1heEJ5dGVzVG9Xcml0ZTxzdHIubGVuZ3RoKjI/bWF4Qnl0ZXNUb1dyaXRlLzI6c3RyLmxlbmd0aDtmb3IodmFyIGk9MDtpPG51bUNoYXJzVG9Xcml0ZTsrK2kpe3ZhciBjb2RlVW5pdD1zdHIuY2hhckNvZGVBdChpKTtIRUFQMTZbb3V0UHRyPj4xXT1jb2RlVW5pdDtvdXRQdHIrPTI7fUhFQVAxNltvdXRQdHI+PjFdPTA7cmV0dXJuIG91dFB0ci1zdGFydFB0cn07dmFyIGxlbmd0aEJ5dGVzVVRGMTY9c3RyPT5zdHIubGVuZ3RoKjI7dmFyIFVURjMyVG9TdHJpbmc9KHB0cixtYXhCeXRlc1RvUmVhZCk9Pnt2YXIgaT0wO3ZhciBzdHI9IiI7d2hpbGUoIShpPj1tYXhCeXRlc1RvUmVhZC80KSl7dmFyIHV0ZjMyPUhFQVAzMltwdHIraSo0Pj4yXTtpZih1dGYzMj09MClicmVhazsrK2k7aWYodXRmMzI+PTY1NTM2KXt2YXIgY2g9dXRmMzItNjU1MzY7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGNoPj4xMCw1NjMyMHxjaCYxMDIzKTt9ZWxzZSB7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHV0ZjMyKTt9fXJldHVybiBzdHJ9O3ZhciBzdHJpbmdUb1VURjMyPShzdHIsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSk9PnttYXhCeXRlc1RvV3JpdGU/Pz0yMTQ3NDgzNjQ3O2lmKG1heEJ5dGVzVG9Xcml0ZTw0KXJldHVybiAwO3ZhciBzdGFydFB0cj1vdXRQdHI7dmFyIGVuZFB0cj1zdGFydFB0cittYXhCeXRlc1RvV3JpdGUtNDtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgY29kZVVuaXQ9c3RyLmNoYXJDb2RlQXQoaSk7aWYoY29kZVVuaXQ+PTU1Mjk2JiZjb2RlVW5pdDw9NTczNDMpe3ZhciB0cmFpbFN1cnJvZ2F0ZT1zdHIuY2hhckNvZGVBdCgrK2kpO2NvZGVVbml0PTY1NTM2KygoY29kZVVuaXQmMTAyMyk8PDEwKXx0cmFpbFN1cnJvZ2F0ZSYxMDIzO31IRUFQMzJbb3V0UHRyPj4yXT1jb2RlVW5pdDtvdXRQdHIrPTQ7aWYob3V0UHRyKzQ+ZW5kUHRyKWJyZWFrfUhFQVAzMltvdXRQdHI+PjJdPTA7cmV0dXJuIG91dFB0ci1zdGFydFB0cn07dmFyIGxlbmd0aEJ5dGVzVVRGMzI9c3RyPT57dmFyIGxlbj0wO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciBjb2RlVW5pdD1zdHIuY2hhckNvZGVBdChpKTtpZihjb2RlVW5pdD49NTUyOTYmJmNvZGVVbml0PD01NzM0MykrK2k7bGVuKz00O31yZXR1cm4gbGVufTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmc9KHJhd1R5cGUsY2hhclNpemUsbmFtZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7dmFyIGRlY29kZVN0cmluZyxlbmNvZGVTdHJpbmcsZ2V0SGVhcCxsZW5ndGhCeXRlc1VURixzaGlmdDtpZihjaGFyU2l6ZT09PTIpe2RlY29kZVN0cmluZz1VVEYxNlRvU3RyaW5nO2VuY29kZVN0cmluZz1zdHJpbmdUb1VURjE2O2xlbmd0aEJ5dGVzVVRGPWxlbmd0aEJ5dGVzVVRGMTY7Z2V0SGVhcD0oKT0+SEVBUFUxNjtzaGlmdD0xO31lbHNlIGlmKGNoYXJTaXplPT09NCl7ZGVjb2RlU3RyaW5nPVVURjMyVG9TdHJpbmc7ZW5jb2RlU3RyaW5nPXN0cmluZ1RvVVRGMzI7bGVuZ3RoQnl0ZXNVVEY9bGVuZ3RoQnl0ZXNVVEYzMjtnZXRIZWFwPSgpPT5IRUFQVTMyO3NoaWZ0PTI7fXJlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsImZyb21XaXJlVHlwZSI6dmFsdWU9Pnt2YXIgbGVuZ3RoPUhFQVBVMzJbdmFsdWU+PjJdO3ZhciBIRUFQPWdldEhlYXAoKTt2YXIgc3RyO3ZhciBkZWNvZGVTdGFydFB0cj12YWx1ZSs0O2Zvcih2YXIgaT0wO2k8PWxlbmd0aDsrK2kpe3ZhciBjdXJyZW50Qnl0ZVB0cj12YWx1ZSs0K2kqY2hhclNpemU7aWYoaT09bGVuZ3RofHxIRUFQW2N1cnJlbnRCeXRlUHRyPj5zaGlmdF09PTApe3ZhciBtYXhSZWFkQnl0ZXM9Y3VycmVudEJ5dGVQdHItZGVjb2RlU3RhcnRQdHI7dmFyIHN0cmluZ1NlZ21lbnQ9ZGVjb2RlU3RyaW5nKGRlY29kZVN0YXJ0UHRyLG1heFJlYWRCeXRlcyk7aWYoc3RyPT09dW5kZWZpbmVkKXtzdHI9c3RyaW5nU2VnbWVudDt9ZWxzZSB7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDApO3N0cis9c3RyaW5nU2VnbWVudDt9ZGVjb2RlU3RhcnRQdHI9Y3VycmVudEJ5dGVQdHIrY2hhclNpemU7fX1fZnJlZSh2YWx1ZSk7cmV0dXJuIHN0cn0sInRvV2lyZVR5cGUiOihkZXN0cnVjdG9ycyx2YWx1ZSk9PntpZighKHR5cGVvZiB2YWx1ZT09InN0cmluZyIpKXt0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBDKysgc3RyaW5nIHR5cGUgJHtuYW1lfWApO312YXIgbGVuZ3RoPWxlbmd0aEJ5dGVzVVRGKHZhbHVlKTt2YXIgcHRyPV9tYWxsb2MoNCtsZW5ndGgrY2hhclNpemUpO0hFQVBVMzJbcHRyPj4yXT1sZW5ndGg+PnNoaWZ0O2VuY29kZVN0cmluZyh2YWx1ZSxwdHIrNCxsZW5ndGgrY2hhclNpemUpO2lmKGRlc3RydWN0b3JzIT09bnVsbCl7ZGVzdHJ1Y3RvcnMucHVzaChfZnJlZSxwdHIpO31yZXR1cm4gcHRyfSwiYXJnUGFja0FkdmFuY2UiOkdlbmVyaWNXaXJlVHlwZVNpemUsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjpzaW1wbGVSZWFkVmFsdWVGcm9tUG9pbnRlcixkZXN0cnVjdG9yRnVuY3Rpb24ocHRyKXtfZnJlZShwdHIpO319KTt9O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl92b2lkPShyYXdUeXBlLG5hbWUpPT57bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtpc1ZvaWQ6dHJ1ZSxuYW1lOm5hbWUsImFyZ1BhY2tBZHZhbmNlIjowLCJmcm9tV2lyZVR5cGUiOigpPT51bmRlZmluZWQsInRvV2lyZVR5cGUiOihkZXN0cnVjdG9ycyxvKT0+dW5kZWZpbmVkfSk7fTt2YXIgZ2V0SGVhcE1heD0oKT0+MjE0NzQ4MzY0ODt2YXIgZ3Jvd01lbW9yeT1zaXplPT57dmFyIGI9d2FzbU1lbW9yeS5idWZmZXI7dmFyIHBhZ2VzPShzaXplLWIuYnl0ZUxlbmd0aCs2NTUzNSkvNjU1MzY7dHJ5e3dhc21NZW1vcnkuZ3JvdyhwYWdlcyk7dXBkYXRlTWVtb3J5Vmlld3MoKTtyZXR1cm4gMX1jYXRjaChlKXt9fTt2YXIgX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXA9cmVxdWVzdGVkU2l6ZT0+e3ZhciBvbGRTaXplPUhFQVBVOC5sZW5ndGg7cmVxdWVzdGVkU2l6ZT4+Pj0wO3ZhciBtYXhIZWFwU2l6ZT1nZXRIZWFwTWF4KCk7aWYocmVxdWVzdGVkU2l6ZT5tYXhIZWFwU2l6ZSl7cmV0dXJuIGZhbHNlfXZhciBhbGlnblVwPSh4LG11bHRpcGxlKT0+eCsobXVsdGlwbGUteCVtdWx0aXBsZSklbXVsdGlwbGU7Zm9yKHZhciBjdXREb3duPTE7Y3V0RG93bjw9NDtjdXREb3duKj0yKXt2YXIgb3Zlckdyb3duSGVhcFNpemU9b2xkU2l6ZSooMSsuMi9jdXREb3duKTtvdmVyR3Jvd25IZWFwU2l6ZT1NYXRoLm1pbihvdmVyR3Jvd25IZWFwU2l6ZSxyZXF1ZXN0ZWRTaXplKzEwMDY2MzI5Nik7dmFyIG5ld1NpemU9TWF0aC5taW4obWF4SGVhcFNpemUsYWxpZ25VcChNYXRoLm1heChyZXF1ZXN0ZWRTaXplLG92ZXJHcm93bkhlYXBTaXplKSw2NTUzNikpO3ZhciByZXBsYWNlbWVudD1ncm93TWVtb3J5KG5ld1NpemUpO2lmKHJlcGxhY2VtZW50KXtyZXR1cm4gdHJ1ZX19cmV0dXJuIGZhbHNlfTtlbWJpbmRfaW5pdF9jaGFyQ29kZXMoKTtCaW5kaW5nRXJyb3I9TW9kdWxlWyJCaW5kaW5nRXJyb3IiXT1jbGFzcyBCaW5kaW5nRXJyb3IgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihtZXNzYWdlKXtzdXBlcihtZXNzYWdlKTt0aGlzLm5hbWU9IkJpbmRpbmdFcnJvciI7fX07TW9kdWxlWyJJbnRlcm5hbEVycm9yIl09Y2xhc3MgSW50ZXJuYWxFcnJvciBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKG1lc3NhZ2Upe3N1cGVyKG1lc3NhZ2UpO3RoaXMubmFtZT0iSW50ZXJuYWxFcnJvciI7fX07aGFuZGxlQWxsb2NhdG9ySW5pdCgpO2luaXRfZW12YWwoKTt2YXIgd2FzbUltcG9ydHM9e2Y6X19lbWJpbmRfcmVnaXN0ZXJfYmlnaW50LGk6X19lbWJpbmRfcmVnaXN0ZXJfYm9vbCxoOl9fZW1iaW5kX3JlZ2lzdGVyX2VtdmFsLGU6X19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQsYjpfX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyLGE6X19lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcsZDpfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nLGM6X19lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmcsajpfX2VtYmluZF9yZWdpc3Rlcl92b2lkLGc6X2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXB9O3ZhciB3YXNtRXhwb3J0cz1jcmVhdGVXYXNtKCk7TW9kdWxlWyJfcGFjayJdPShhMCxhMSxhMixhMyxhNCxhNSxhNixhNyxhOCxhOSxhMTApPT4oTW9kdWxlWyJfcGFjayJdPXdhc21FeHBvcnRzWyJtIl0pKGEwLGExLGEyLGEzLGE0LGE1LGE2LGE3LGE4LGE5LGExMCk7dmFyIF9tYWxsb2M9TW9kdWxlWyJfbWFsbG9jIl09YTA9PihfbWFsbG9jPU1vZHVsZVsiX21hbGxvYyJdPXdhc21FeHBvcnRzWyJvIl0pKGEwKTt2YXIgX2ZyZWU9TW9kdWxlWyJfZnJlZSJdPWEwPT4oX2ZyZWU9TW9kdWxlWyJfZnJlZSJdPXdhc21FeHBvcnRzWyJwIl0pKGEwKTt2YXIgY2FsbGVkUnVuO2RlcGVuZGVuY2llc0Z1bGZpbGxlZD1mdW5jdGlvbiBydW5DYWxsZXIoKXtpZighY2FsbGVkUnVuKXJ1bigpO2lmKCFjYWxsZWRSdW4pZGVwZW5kZW5jaWVzRnVsZmlsbGVkPXJ1bkNhbGxlcjt9O2Z1bmN0aW9uIHJ1bigpe2lmKHJ1bkRlcGVuZGVuY2llcz4wKXtyZXR1cm59cHJlUnVuKCk7aWYocnVuRGVwZW5kZW5jaWVzPjApe3JldHVybn1mdW5jdGlvbiBkb1J1bigpe2lmKGNhbGxlZFJ1bilyZXR1cm47Y2FsbGVkUnVuPXRydWU7TW9kdWxlWyJjYWxsZWRSdW4iXT10cnVlO2lmKEFCT1JUKXJldHVybjtpbml0UnVudGltZSgpO3JlYWR5UHJvbWlzZVJlc29sdmUoTW9kdWxlKTtpZihNb2R1bGVbIm9uUnVudGltZUluaXRpYWxpemVkIl0pTW9kdWxlWyJvblJ1bnRpbWVJbml0aWFsaXplZCJdKCk7cG9zdFJ1bigpO31pZihNb2R1bGVbInNldFN0YXR1cyJdKXtNb2R1bGVbInNldFN0YXR1cyJdKCJSdW5uaW5nLi4uIik7c2V0VGltZW91dChmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtNb2R1bGVbInNldFN0YXR1cyJdKCIiKTt9LDEpO2RvUnVuKCk7fSwxKTt9ZWxzZSB7ZG9SdW4oKTt9fWlmKE1vZHVsZVsicHJlSW5pdCJdKXtpZih0eXBlb2YgTW9kdWxlWyJwcmVJbml0Il09PSJmdW5jdGlvbiIpTW9kdWxlWyJwcmVJbml0Il09W01vZHVsZVsicHJlSW5pdCJdXTt3aGlsZShNb2R1bGVbInByZUluaXQiXS5sZW5ndGg+MCl7TW9kdWxlWyJwcmVJbml0Il0ucG9wKCkoKTt9fXJ1bigpOwoKCiAgICByZXR1cm4gbW9kdWxlQXJnLnJlYWR5CiAgfQogICk7CiAgfSkoKTsKCiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkKICBsZXQgd2FzbU1vZHVsZTsKICBhc3luYyBmdW5jdGlvbiBpbml0V2FzbSgpIHsKICAgICAgd2FzbU1vZHVsZSA9IGF3YWl0IGxvYWRXYXNtKCk7CiAgfQogIGxldCBhbGxvY2F0ZWRWZXJ0ZXhDb3VudCA9IDA7CiAgY29uc3QgdXBkYXRlUXVldWUgPSBuZXcgQXJyYXkoKTsKICBsZXQgcnVubmluZyA9IGZhbHNlOwogIGxldCBsb2FkaW5nID0gZmFsc2U7CiAgbGV0IHBvc2l0aW9uc1B0cjsKICBsZXQgcm90YXRpb25zUHRyOwogIGxldCBzY2FsZXNQdHI7CiAgbGV0IGNvbG9yc1B0cjsKICBsZXQgc2VsZWN0aW9uUHRyOwogIGxldCBkYXRhUHRyOwogIGxldCB3b3JsZFBvc2l0aW9uc1B0cjsKICBsZXQgd29ybGRSb3RhdGlvbnNQdHI7CiAgbGV0IHdvcmxkU2NhbGVzUHRyOwogIGNvbnN0IHBhY2sgPSBhc3luYyAoc3BsYXQpID0+IHsKICAgICAgd2hpbGUgKGxvYWRpbmcpIHsKICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDApKTsKICAgICAgfQogICAgICBpZiAoIXdhc21Nb2R1bGUpIHsKICAgICAgICAgIGxvYWRpbmcgPSB0cnVlOwogICAgICAgICAgYXdhaXQgaW5pdFdhc20oKTsKICAgICAgICAgIGxvYWRpbmcgPSBmYWxzZTsKICAgICAgfQogICAgICBjb25zdCB0YXJnZXRBbGxvY2F0ZWRWZXJ0ZXhDb3VudCA9IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIoc3BsYXQudmVydGV4Q291bnQpKSk7CiAgICAgIGlmICh0YXJnZXRBbGxvY2F0ZWRWZXJ0ZXhDb3VudCA+IGFsbG9jYXRlZFZlcnRleENvdW50KSB7CiAgICAgICAgICBpZiAoYWxsb2NhdGVkVmVydGV4Q291bnQgPiAwKSB7CiAgICAgICAgICAgICAgd2FzbU1vZHVsZS5fZnJlZShwb3NpdGlvbnNQdHIpOwogICAgICAgICAgICAgIHdhc21Nb2R1bGUuX2ZyZWUocm90YXRpb25zUHRyKTsKICAgICAgICAgICAgICB3YXNtTW9kdWxlLl9mcmVlKHNjYWxlc1B0cik7CiAgICAgICAgICAgICAgd2FzbU1vZHVsZS5fZnJlZShjb2xvcnNQdHIpOwogICAgICAgICAgICAgIHdhc21Nb2R1bGUuX2ZyZWUoc2VsZWN0aW9uUHRyKTsKICAgICAgICAgICAgICB3YXNtTW9kdWxlLl9mcmVlKGRhdGFQdHIpOwogICAgICAgICAgICAgIHdhc21Nb2R1bGUuX2ZyZWUod29ybGRQb3NpdGlvbnNQdHIpOwogICAgICAgICAgICAgIHdhc21Nb2R1bGUuX2ZyZWUod29ybGRSb3RhdGlvbnNQdHIpOwogICAgICAgICAgICAgIHdhc21Nb2R1bGUuX2ZyZWUod29ybGRTY2FsZXNQdHIpOwogICAgICAgICAgfQogICAgICAgICAgYWxsb2NhdGVkVmVydGV4Q291bnQgPSB0YXJnZXRBbGxvY2F0ZWRWZXJ0ZXhDb3VudDsKICAgICAgICAgIHBvc2l0aW9uc1B0ciA9IHdhc21Nb2R1bGUuX21hbGxvYygzICogYWxsb2NhdGVkVmVydGV4Q291bnQgKiA0KTsKICAgICAgICAgIHJvdGF0aW9uc1B0ciA9IHdhc21Nb2R1bGUuX21hbGxvYyg0ICogYWxsb2NhdGVkVmVydGV4Q291bnQgKiA0KTsKICAgICAgICAgIHNjYWxlc1B0ciA9IHdhc21Nb2R1bGUuX21hbGxvYygzICogYWxsb2NhdGVkVmVydGV4Q291bnQgKiA0KTsKICAgICAgICAgIGNvbG9yc1B0ciA9IHdhc21Nb2R1bGUuX21hbGxvYyg0ICogYWxsb2NhdGVkVmVydGV4Q291bnQpOwogICAgICAgICAgc2VsZWN0aW9uUHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKGFsbG9jYXRlZFZlcnRleENvdW50KTsKICAgICAgICAgIGRhdGFQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2MoOCAqIGFsbG9jYXRlZFZlcnRleENvdW50ICogNCk7CiAgICAgICAgICB3b3JsZFBvc2l0aW9uc1B0ciA9IHdhc21Nb2R1bGUuX21hbGxvYygzICogYWxsb2NhdGVkVmVydGV4Q291bnQgKiA0KTsKICAgICAgICAgIHdvcmxkUm90YXRpb25zUHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKDQgKiBhbGxvY2F0ZWRWZXJ0ZXhDb3VudCAqIDQpOwogICAgICAgICAgd29ybGRTY2FsZXNQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2MoMyAqIGFsbG9jYXRlZFZlcnRleENvdW50ICogNCk7CiAgICAgIH0KICAgICAgd2FzbU1vZHVsZS5IRUFQRjMyLnNldChzcGxhdC5wb3NpdGlvbnMsIHBvc2l0aW9uc1B0ciAvIDQpOwogICAgICB3YXNtTW9kdWxlLkhFQVBGMzIuc2V0KHNwbGF0LnJvdGF0aW9ucywgcm90YXRpb25zUHRyIC8gNCk7CiAgICAgIHdhc21Nb2R1bGUuSEVBUEYzMi5zZXQoc3BsYXQuc2NhbGVzLCBzY2FsZXNQdHIgLyA0KTsKICAgICAgd2FzbU1vZHVsZS5IRUFQVTguc2V0KHNwbGF0LmNvbG9ycywgY29sb3JzUHRyKTsKICAgICAgd2FzbU1vZHVsZS5IRUFQVTguc2V0KHNwbGF0LnNlbGVjdGlvbiwgc2VsZWN0aW9uUHRyKTsKICAgICAgd2FzbU1vZHVsZS5fcGFjayhzcGxhdC5zZWxlY3RlZCwgc3BsYXQudmVydGV4Q291bnQsIHBvc2l0aW9uc1B0ciwgcm90YXRpb25zUHRyLCBzY2FsZXNQdHIsIGNvbG9yc1B0ciwgc2VsZWN0aW9uUHRyLCBkYXRhUHRyLCB3b3JsZFBvc2l0aW9uc1B0ciwgd29ybGRSb3RhdGlvbnNQdHIsIHdvcmxkU2NhbGVzUHRyKTsKICAgICAgY29uc3Qgb3V0RGF0YSA9IG5ldyBVaW50MzJBcnJheSh3YXNtTW9kdWxlLkhFQVBVMzIuYnVmZmVyLCBkYXRhUHRyLCBzcGxhdC52ZXJ0ZXhDb3VudCAqIDgpOwogICAgICBjb25zdCBkZXRhY2hlZERhdGEgPSBuZXcgVWludDMyQXJyYXkob3V0RGF0YS5zbGljZSgpLmJ1ZmZlcik7CiAgICAgIGNvbnN0IHdvcmxkUG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSh3YXNtTW9kdWxlLkhFQVBGMzIuYnVmZmVyLCB3b3JsZFBvc2l0aW9uc1B0ciwgc3BsYXQudmVydGV4Q291bnQgKiAzKTsKICAgICAgY29uc3QgZGV0YWNoZWRXb3JsZFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkod29ybGRQb3NpdGlvbnMuc2xpY2UoKS5idWZmZXIpOwogICAgICBjb25zdCB3b3JsZFJvdGF0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkod2FzbU1vZHVsZS5IRUFQRjMyLmJ1ZmZlciwgd29ybGRSb3RhdGlvbnNQdHIsIHNwbGF0LnZlcnRleENvdW50ICogNCk7CiAgICAgIGNvbnN0IGRldGFjaGVkV29ybGRSb3RhdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHdvcmxkUm90YXRpb25zLnNsaWNlKCkuYnVmZmVyKTsKICAgICAgY29uc3Qgd29ybGRTY2FsZXMgPSBuZXcgRmxvYXQzMkFycmF5KHdhc21Nb2R1bGUuSEVBUEYzMi5idWZmZXIsIHdvcmxkU2NhbGVzUHRyLCBzcGxhdC52ZXJ0ZXhDb3VudCAqIDMpOwogICAgICBjb25zdCBkZXRhY2hlZFdvcmxkU2NhbGVzID0gbmV3IEZsb2F0MzJBcnJheSh3b3JsZFNjYWxlcy5zbGljZSgpLmJ1ZmZlcik7CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gewogICAgICAgICAgZGF0YTogZGV0YWNoZWREYXRhLAogICAgICAgICAgd29ybGRQb3NpdGlvbnM6IGRldGFjaGVkV29ybGRQb3NpdGlvbnMsCiAgICAgICAgICB3b3JsZFJvdGF0aW9uczogZGV0YWNoZWRXb3JsZFJvdGF0aW9ucywKICAgICAgICAgIHdvcmxkU2NhbGVzOiBkZXRhY2hlZFdvcmxkU2NhbGVzLAogICAgICAgICAgb2Zmc2V0OiBzcGxhdC5vZmZzZXQsCiAgICAgICAgICB2ZXJ0ZXhDb3VudDogc3BsYXQudmVydGV4Q291bnQsCiAgICAgICAgICBwb3NpdGlvbnM6IHNwbGF0LnBvc2l0aW9ucy5idWZmZXIsCiAgICAgICAgICByb3RhdGlvbnM6IHNwbGF0LnJvdGF0aW9ucy5idWZmZXIsCiAgICAgICAgICBzY2FsZXM6IHNwbGF0LnNjYWxlcy5idWZmZXIsCiAgICAgICAgICBjb2xvcnM6IHNwbGF0LmNvbG9ycy5idWZmZXIsCiAgICAgICAgICBzZWxlY3Rpb246IHNwbGF0LnNlbGVjdGlvbi5idWZmZXIsCiAgICAgIH07CiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyByZXNwb25zZTogcmVzcG9uc2UgfSwgWwogICAgICAgICAgcmVzcG9uc2UuZGF0YS5idWZmZXIsCiAgICAgICAgICByZXNwb25zZS53b3JsZFBvc2l0aW9ucy5idWZmZXIsCiAgICAgICAgICByZXNwb25zZS53b3JsZFJvdGF0aW9ucy5idWZmZXIsCiAgICAgICAgICByZXNwb25zZS53b3JsZFNjYWxlcy5idWZmZXIsCiAgICAgICAgICByZXNwb25zZS5wb3NpdGlvbnMsCiAgICAgICAgICByZXNwb25zZS5yb3RhdGlvbnMsCiAgICAgICAgICByZXNwb25zZS5zY2FsZXMsCiAgICAgICAgICByZXNwb25zZS5jb2xvcnMsCiAgICAgICAgICByZXNwb25zZS5zZWxlY3Rpb24sCiAgICAgIF0pOwogICAgICBydW5uaW5nID0gZmFsc2U7CiAgfTsKICBjb25zdCBwYWNrVGhyb3R0bGVkID0gKCkgPT4gewogICAgICBpZiAodXBkYXRlUXVldWUubGVuZ3RoID09PSAwKQogICAgICAgICAgcmV0dXJuOwogICAgICBpZiAoIXJ1bm5pbmcpIHsKICAgICAgICAgIHJ1bm5pbmcgPSB0cnVlOwogICAgICAgICAgY29uc3Qgc3BsYXQgPSB1cGRhdGVRdWV1ZS5zaGlmdCgpOwogICAgICAgICAgcGFjayhzcGxhdCk7CiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7CiAgICAgICAgICAgICAgcGFja1Rocm90dGxlZCgpOwogICAgICAgICAgfSwgMCk7CiAgICAgIH0KICB9OwogIHNlbGYub25tZXNzYWdlID0gKGUpID0+IHsKICAgICAgaWYgKGUuZGF0YS5zcGxhdCkgewogICAgICAgICAgY29uc3Qgc3BsYXQgPSBlLmRhdGEuc3BsYXQ7CiAgICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgZXhpc3RpbmddIG9mIHVwZGF0ZVF1ZXVlLmVudHJpZXMoKSkgewogICAgICAgICAgICAgIGlmIChleGlzdGluZy5vZmZzZXQgPT09IHNwbGF0Lm9mZnNldCkgewogICAgICAgICAgICAgICAgICB1cGRhdGVRdWV1ZVtpbmRleF0gPSBzcGxhdDsKICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHVwZGF0ZVF1ZXVlLnB1c2goc3BsYXQpOwogICAgICAgICAgcGFja1Rocm90dGxlZCgpOwogICAgICB9CiAgfTsKCn0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFXb3JrZXIuanMubWFwCgo=", null, false);
var o = function(A2 = {}) {
  var Q2, F2, B2 = A2;
  B2.ready = new Promise((A3, B3) => {
    Q2 = A3, F2 = B3;
  });
  var U2, l2 = Object.assign({}, B2), t2 = "";
  t2 = 0 !== (t2 = self.location.href).indexOf("blob:") ? t2.substr(0, t2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", U2 = (A3) => {
    var Q3 = new XMLHttpRequest();
    return Q3.open("GET", A3, false), Q3.responseType = "arraybuffer", Q3.send(null), new Uint8Array(Q3.response);
  }, B2.print || console.log.bind(console);
  var d2, n2, V2 = B2.printErr || console.error.bind(console);
  function Z2(A3) {
    if (X2(A3))
      return function(A4) {
        for (var Q3 = atob(A4), F3 = new Uint8Array(Q3.length), B3 = 0; B3 < Q3.length; ++B3)
          F3[B3] = Q3.charCodeAt(B3);
        return F3;
      }(A3.slice(G2.length));
  }
  Object.assign(B2, l2), l2 = null, B2.arguments && B2.arguments, B2.thisProgram && B2.thisProgram, B2.quit && B2.quit, B2.wasmBinary && (d2 = B2.wasmBinary), "object" != typeof WebAssembly && E2("no native wasm support detected");
  var e2, I2, R2, a2, g2, i2, W2, c2, C2 = false;
  function h2() {
    var A3 = n2.buffer;
    B2.HEAP8 = e2 = new Int8Array(A3), B2.HEAP16 = R2 = new Int16Array(A3), B2.HEAPU8 = I2 = new Uint8Array(A3), B2.HEAPU16 = a2 = new Uint16Array(A3), B2.HEAP32 = g2 = new Int32Array(A3), B2.HEAPU32 = i2 = new Uint32Array(A3), B2.HEAPF32 = W2 = new Float32Array(A3), B2.HEAPF64 = c2 = new Float64Array(A3);
  }
  var s2 = [], o2 = [], J2 = [], b2 = 0, r2 = null;
  function E2(A3) {
    var _a;
    (_a = B2.onAbort) == null ? void 0 : _a.call(B2, A3), V2(A3 = "Aborted(" + A3 + ")"), C2 = true, A3 += ". Build with -sASSERTIONS for more info.";
    var Q3 = new WebAssembly.RuntimeError(A3);
    throw F2(Q3), Q3;
  }
  var m2, N2, G2 = "data:application/octet-stream;base64,", X2 = (A3) => A3.startsWith(G2);
  function Y2(A3) {
    return Promise.resolve().then(() => function(A4) {
      if (A4 == m2 && d2)
        return new Uint8Array(d2);
      var Q3 = Z2(A4);
      if (Q3)
        return Q3;
      if (U2)
        return U2(A4);
      throw "both async and sync fetching of the wasm failed";
    }(A3));
  }
  function y2(A3, Q3, F3, B3) {
    return function(A4, Q4, F4) {
      return Y2(A4).then((A5) => WebAssembly.instantiate(A5, Q4)).then((A5) => A5).then(F4, (A5) => {
        V2(`failed to asynchronously prepare wasm: ${A5}`), E2(A5);
      });
    }(Q3, F3, B3);
  }
  X2(m2 = "data:application/octet-stream;base64,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bXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDY0X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDY0X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPgBzdGQ6OmJhc2ljX3N0cmluZzx1bnNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgBOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQAAAACkDAAAQgcAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0loTlNfMTFjaGFyX3RyYWl0c0loRUVOU185YWxsb2NhdG9ySWhFRUVFAACkDAAAjAcAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0l3TlNfMTFjaGFyX3RyYWl0c0l3RUVOU185YWxsb2NhdG9ySXdFRUVFAACkDAAA1AcAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEc05TXzExY2hhcl90cmFpdHNJRHNFRU5TXzlhbGxvY2F0b3JJRHNFRUVFAAAApAwAABwIAABOU3QzX18yMTJiYXNpY19zdHJpbmdJRGlOU18xMWNoYXJfdHJhaXRzSURpRUVOU185YWxsb2NhdG9ySURpRUVFRQAAAKQMAABoCAAATjEwZW1zY3JpcHRlbjN2YWxFAACkDAAAtAgAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWNFRQAApAwAANAIAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lhRUUAAKQMAAD4CAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaEVFAACkDAAAIAkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXNFRQAApAwAAEgJAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l0RUUAAKQMAABwCQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaUVFAACkDAAAmAkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWpFRQAApAwAAMAJAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lsRUUAAKQMAADoCQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbUVFAACkDAAAEAoAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXhFRQAApAwAADgKAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l5RUUAAKQMAABgCgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAACkDAAAiAoAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWRFRQAApAwAALAKAABOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAADMDAAA2AoAADANAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAADMDAAACAsAAPwKAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAADMDAAAOAsAAPwKAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQDMDAAAaAsAAFwLAAAAAAAA3AsAAAIAAAADAAAABAAAAAUAAAAGAAAATjEwX19jeHhhYml2MTIzX19mdW5kYW1lbnRhbF90eXBlX2luZm9FAMwMAAC0CwAA/AoAAHYAAACgCwAA6AsAAGIAAACgCwAA9AsAAGMAAACgCwAAAAwAAGgAAACgCwAADAwAAGEAAACgCwAAGAwAAHMAAACgCwAAJAwAAHQAAACgCwAAMAwAAGkAAACgCwAAPAwAAGoAAACgCwAASAwAAGwAAACgCwAAVAwAAG0AAACgCwAAYAwAAHgAAACgCwAAbAwAAHkAAACgCwAAeAwAAGYAAACgCwAAhAwAAGQAAACgCwAAkAwAAAAAAAAsCwAAAgAAAAcAAAAEAAAABQAAAAgAAAAJAAAACgAAAAsAAAAAAAAAFA0AAAIAAAAMAAAABAAAAAUAAAAIAAAADQAAAA4AAAAPAAAATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAAAAAMwMAADsDAAALAsAAFN0OXR5cGVfaW5mbwAAAACkDAAAIA0AQbgaCwNADwE=") || (N2 = m2, m2 = B2.locateFile ? B2.locateFile(N2, t2) : t2 + N2);
  var p = (A3) => {
    for (; A3.length > 0; )
      A3.shift()(B2);
  };
  B2.noExitRuntime;
  var S, k, u = (A3) => {
    for (var Q3 = "", F3 = A3; I2[F3]; )
      Q3 += S[I2[F3++]];
    return Q3;
  }, T = {}, D = {}, H = (A3) => {
    throw new k(A3);
  };
  function w(A3, Q3, F3 = {}) {
    if (!("argPackAdvance" in Q3))
      throw new TypeError("registerType registeredInstance requires argPackAdvance");
    return function(A4, Q4, F4 = {}) {
      var B3 = Q4.name;
      if (A4 || H(`type "${B3}" must have a positive integer typeid pointer`), D.hasOwnProperty(A4)) {
        if (F4.ignoreDuplicateRegistrations)
          return;
        H(`Cannot register type '${B3}' twice`);
      }
      if (D[A4] = Q4, T.hasOwnProperty(A4)) {
        var U3 = T[A4];
        delete T[A4], U3.forEach((A5) => A5());
      }
    }(A3, Q3, F3);
  }
  function x() {
    this.allocated = [void 0], this.freelist = [];
  }
  var f = new x(), M = () => {
    for (var A3 = 0, Q3 = f.reserved; Q3 < f.allocated.length; ++Q3)
      void 0 !== f.allocated[Q3] && ++A3;
    return A3;
  }, z = (A3) => (A3 || H("Cannot use deleted val. handle = " + A3), f.get(A3).value), v = (A3) => {
    switch (A3) {
      case void 0:
        return 1;
      case null:
        return 2;
      case true:
        return 3;
      case false:
        return 4;
      default:
        return f.allocate({ refcount: 1, value: A3 });
    }
  };
  function K(A3) {
    return this.fromWireType(g2[A3 >> 2]);
  }
  var j = (A3, Q3) => {
    switch (Q3) {
      case 4:
        return function(A4) {
          return this.fromWireType(W2[A4 >> 2]);
        };
      case 8:
        return function(A4) {
          return this.fromWireType(c2[A4 >> 3]);
        };
      default:
        throw new TypeError(`invalid float width (${Q3}): ${A3}`);
    }
  }, O = (A3, Q3, F3) => {
    switch (Q3) {
      case 1:
        return F3 ? (A4) => e2[A4 >> 0] : (A4) => I2[A4 >> 0];
      case 2:
        return F3 ? (A4) => R2[A4 >> 1] : (A4) => a2[A4 >> 1];
      case 4:
        return F3 ? (A4) => g2[A4 >> 2] : (A4) => i2[A4 >> 2];
      default:
        throw new TypeError(`invalid integer width (${Q3}): ${A3}`);
    }
  };
  function L(A3) {
    return this.fromWireType(i2[A3 >> 2]);
  }
  var P = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, _ = (A3, Q3) => A3 ? ((A4, Q4, F3) => {
    for (var B3 = Q4 + F3, U3 = Q4; A4[U3] && !(U3 >= B3); )
      ++U3;
    if (U3 - Q4 > 16 && A4.buffer && P)
      return P.decode(A4.subarray(Q4, U3));
    for (var l3 = ""; Q4 < U3; ) {
      var t3 = A4[Q4++];
      if (128 & t3) {
        var d3 = 63 & A4[Q4++];
        if (192 != (224 & t3)) {
          var n3 = 63 & A4[Q4++];
          if ((t3 = 224 == (240 & t3) ? (15 & t3) << 12 | d3 << 6 | n3 : (7 & t3) << 18 | d3 << 12 | n3 << 6 | 63 & A4[Q4++]) < 65536)
            l3 += String.fromCharCode(t3);
          else {
            var V3 = t3 - 65536;
            l3 += String.fromCharCode(55296 | V3 >> 10, 56320 | 1023 & V3);
          }
        } else
          l3 += String.fromCharCode((31 & t3) << 6 | d3);
      } else
        l3 += String.fromCharCode(t3);
    }
    return l3;
  })(I2, A3, Q3) : "", q = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0, $ = (A3, Q3) => {
    for (var F3 = A3, B3 = F3 >> 1, U3 = B3 + Q3 / 2; !(B3 >= U3) && a2[B3]; )
      ++B3;
    if ((F3 = B3 << 1) - A3 > 32 && q)
      return q.decode(I2.subarray(A3, F3));
    for (var l3 = "", t3 = 0; !(t3 >= Q3 / 2); ++t3) {
      var d3 = R2[A3 + 2 * t3 >> 1];
      if (0 == d3)
        break;
      l3 += String.fromCharCode(d3);
    }
    return l3;
  }, AA = (A3, Q3, F3) => {
    if (F3 ?? (F3 = 2147483647), F3 < 2)
      return 0;
    for (var B3 = Q3, U3 = (F3 -= 2) < 2 * A3.length ? F3 / 2 : A3.length, l3 = 0; l3 < U3; ++l3) {
      var t3 = A3.charCodeAt(l3);
      R2[Q3 >> 1] = t3, Q3 += 2;
    }
    return R2[Q3 >> 1] = 0, Q3 - B3;
  }, QA = (A3) => 2 * A3.length, FA = (A3, Q3) => {
    for (var F3 = 0, B3 = ""; !(F3 >= Q3 / 4); ) {
      var U3 = g2[A3 + 4 * F3 >> 2];
      if (0 == U3)
        break;
      if (++F3, U3 >= 65536) {
        var l3 = U3 - 65536;
        B3 += String.fromCharCode(55296 | l3 >> 10, 56320 | 1023 & l3);
      } else
        B3 += String.fromCharCode(U3);
    }
    return B3;
  }, BA = (A3, Q3, F3) => {
    if (F3 ?? (F3 = 2147483647), F3 < 4)
      return 0;
    for (var B3 = Q3, U3 = B3 + F3 - 4, l3 = 0; l3 < A3.length; ++l3) {
      var t3 = A3.charCodeAt(l3);
      if (t3 >= 55296 && t3 <= 57343 && (t3 = 65536 + ((1023 & t3) << 10) | 1023 & A3.charCodeAt(++l3)), g2[Q3 >> 2] = t3, (Q3 += 4) + 4 > U3)
        break;
    }
    return g2[Q3 >> 2] = 0, Q3 - B3;
  }, UA = (A3) => {
    for (var Q3 = 0, F3 = 0; F3 < A3.length; ++F3) {
      var B3 = A3.charCodeAt(F3);
      B3 >= 55296 && B3 <= 57343 && ++F3, Q3 += 4;
    }
    return Q3;
  }, lA = (A3) => {
    var Q3 = (A3 - n2.buffer.byteLength + 65535) / 65536;
    try {
      return n2.grow(Q3), h2(), 1;
    } catch (A4) {
    }
  };
  (() => {
    for (var A3 = new Array(256), Q3 = 0; Q3 < 256; ++Q3)
      A3[Q3] = String.fromCharCode(Q3);
    S = A3;
  })(), k = B2.BindingError = class extends Error {
    constructor(A3) {
      super(A3), this.name = "BindingError";
    }
  }, B2.InternalError = class extends Error {
    constructor(A3) {
      super(A3), this.name = "InternalError";
    }
  }, Object.assign(x.prototype, { get(A3) {
    return this.allocated[A3];
  }, has(A3) {
    return void 0 !== this.allocated[A3];
  }, allocate(A3) {
    var Q3 = this.freelist.pop() || this.allocated.length;
    return this.allocated[Q3] = A3, Q3;
  }, free(A3) {
    this.allocated[A3] = void 0, this.freelist.push(A3);
  } }), f.allocated.push({ value: void 0 }, { value: null }, { value: true }, { value: false }), f.reserved = f.allocated.length, B2.count_emval_handles = M;
  var tA = { f: (A3, Q3, F3, B3, U3) => {
  }, i: (A3, Q3, F3, B3) => {
    w(A3, { name: Q3 = u(Q3), fromWireType: function(A4) {
      return !!A4;
    }, toWireType: function(A4, Q4) {
      return Q4 ? F3 : B3;
    }, argPackAdvance: 8, readValueFromPointer: function(A4) {
      return this.fromWireType(I2[A4]);
    }, destructorFunction: null });
  }, h: (A3, Q3) => {
    w(A3, { name: Q3 = u(Q3), fromWireType: (A4) => {
      var Q4 = z(A4);
      return ((A5) => {
        A5 >= f.reserved && 0 == --f.get(A5).refcount && f.free(A5);
      })(A4), Q4;
    }, toWireType: (A4, Q4) => v(Q4), argPackAdvance: 8, readValueFromPointer: K, destructorFunction: null });
  }, e: (A3, Q3, F3) => {
    w(A3, { name: Q3 = u(Q3), fromWireType: (A4) => A4, toWireType: (A4, Q4) => Q4, argPackAdvance: 8, readValueFromPointer: j(Q3, F3), destructorFunction: null });
  }, b: (A3, Q3, F3, B3, U3) => {
    Q3 = u(Q3);
    var l3 = (A4) => A4;
    if (0 === B3) {
      var t3 = 32 - 8 * F3;
      l3 = (A4) => A4 << t3 >>> t3;
    }
    var d3 = Q3.includes("unsigned");
    w(A3, { name: Q3, fromWireType: l3, toWireType: d3 ? function(A4, Q4) {
      return this.name, Q4 >>> 0;
    } : function(A4, Q4) {
      return this.name, Q4;
    }, argPackAdvance: 8, readValueFromPointer: O(Q3, F3, 0 !== B3), destructorFunction: null });
  }, a: (A3, Q3, F3) => {
    var B3 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][Q3];
    function U3(A4) {
      var Q4 = i2[A4 >> 2], F4 = i2[A4 + 4 >> 2];
      return new B3(e2.buffer, F4, Q4);
    }
    w(A3, { name: F3 = u(F3), fromWireType: U3, argPackAdvance: 8, readValueFromPointer: U3 }, { ignoreDuplicateRegistrations: true });
  }, d: (A3, Q3) => {
    var F3 = "std::string" === (Q3 = u(Q3));
    w(A3, { name: Q3, fromWireType(A4) {
      var Q4, B3 = i2[A4 >> 2], U3 = A4 + 4;
      if (F3)
        for (var l3 = U3, t3 = 0; t3 <= B3; ++t3) {
          var d3 = U3 + t3;
          if (t3 == B3 || 0 == I2[d3]) {
            var n3 = _(l3, d3 - l3);
            void 0 === Q4 ? Q4 = n3 : (Q4 += String.fromCharCode(0), Q4 += n3), l3 = d3 + 1;
          }
        }
      else {
        var V3 = new Array(B3);
        for (t3 = 0; t3 < B3; ++t3)
          V3[t3] = String.fromCharCode(I2[U3 + t3]);
        Q4 = V3.join("");
      }
      return ZA(A4), Q4;
    }, toWireType(A4, Q4) {
      var B3;
      Q4 instanceof ArrayBuffer && (Q4 = new Uint8Array(Q4));
      var U3 = "string" == typeof Q4;
      U3 || Q4 instanceof Uint8Array || Q4 instanceof Uint8ClampedArray || Q4 instanceof Int8Array || H("Cannot pass non-string to std::string"), B3 = F3 && U3 ? ((A5) => {
        for (var Q5 = 0, F4 = 0; F4 < A5.length; ++F4) {
          var B4 = A5.charCodeAt(F4);
          B4 <= 127 ? Q5++ : B4 <= 2047 ? Q5 += 2 : B4 >= 55296 && B4 <= 57343 ? (Q5 += 4, ++F4) : Q5 += 3;
        }
        return Q5;
      })(Q4) : Q4.length;
      var l3 = VA(4 + B3 + 1), t3 = l3 + 4;
      if (i2[l3 >> 2] = B3, F3 && U3)
        ((A5, Q5, F4, B4) => {
          if (!(B4 > 0))
            return 0;
          for (var U4 = F4 + B4 - 1, l4 = 0; l4 < A5.length; ++l4) {
            var t4 = A5.charCodeAt(l4);
            if (t4 >= 55296 && t4 <= 57343 && (t4 = 65536 + ((1023 & t4) << 10) | 1023 & A5.charCodeAt(++l4)), t4 <= 127) {
              if (F4 >= U4)
                break;
              Q5[F4++] = t4;
            } else if (t4 <= 2047) {
              if (F4 + 1 >= U4)
                break;
              Q5[F4++] = 192 | t4 >> 6, Q5[F4++] = 128 | 63 & t4;
            } else if (t4 <= 65535) {
              if (F4 + 2 >= U4)
                break;
              Q5[F4++] = 224 | t4 >> 12, Q5[F4++] = 128 | t4 >> 6 & 63, Q5[F4++] = 128 | 63 & t4;
            } else {
              if (F4 + 3 >= U4)
                break;
              Q5[F4++] = 240 | t4 >> 18, Q5[F4++] = 128 | t4 >> 12 & 63, Q5[F4++] = 128 | t4 >> 6 & 63, Q5[F4++] = 128 | 63 & t4;
            }
          }
          Q5[F4] = 0;
        })(Q4, I2, t3, B3 + 1);
      else if (U3)
        for (var d3 = 0; d3 < B3; ++d3) {
          var n3 = Q4.charCodeAt(d3);
          n3 > 255 && (ZA(t3), H("String has UTF-16 code units that do not fit in 8 bits")), I2[t3 + d3] = n3;
        }
      else
        for (d3 = 0; d3 < B3; ++d3)
          I2[t3 + d3] = Q4[d3];
      return null !== A4 && A4.push(ZA, l3), l3;
    }, argPackAdvance: 8, readValueFromPointer: L, destructorFunction(A4) {
      ZA(A4);
    } });
  }, c: (A3, Q3, F3) => {
    var B3, U3, l3, t3, d3;
    F3 = u(F3), 2 === Q3 ? (B3 = $, U3 = AA, t3 = QA, l3 = () => a2, d3 = 1) : 4 === Q3 && (B3 = FA, U3 = BA, t3 = UA, l3 = () => i2, d3 = 2), w(A3, { name: F3, fromWireType: (A4) => {
      for (var F4, U4 = i2[A4 >> 2], t4 = l3(), n3 = A4 + 4, V3 = 0; V3 <= U4; ++V3) {
        var Z3 = A4 + 4 + V3 * Q3;
        if (V3 == U4 || 0 == t4[Z3 >> d3]) {
          var e3 = B3(n3, Z3 - n3);
          void 0 === F4 ? F4 = e3 : (F4 += String.fromCharCode(0), F4 += e3), n3 = Z3 + Q3;
        }
      }
      return ZA(A4), F4;
    }, toWireType: (A4, B4) => {
      "string" != typeof B4 && H(`Cannot pass non-string to C++ string type ${F3}`);
      var l4 = t3(B4), n3 = VA(4 + l4 + Q3);
      return i2[n3 >> 2] = l4 >> d3, U3(B4, n3 + 4, l4 + Q3), null !== A4 && A4.push(ZA, n3), n3;
    }, argPackAdvance: 8, readValueFromPointer: K, destructorFunction(A4) {
      ZA(A4);
    } });
  }, j: (A3, Q3) => {
    w(A3, { isVoid: true, name: Q3 = u(Q3), argPackAdvance: 0, fromWireType: () => {
    }, toWireType: (A4, Q4) => {
    } });
  }, g: (A3) => {
    var Q3 = I2.length, F3 = 2147483648;
    if ((A3 >>>= 0) > F3)
      return false;
    for (var B3, U3, l3 = 1; l3 <= 4; l3 *= 2) {
      var t3 = Q3 * (1 + 0.2 / l3);
      t3 = Math.min(t3, A3 + 100663296);
      var d3 = Math.min(F3, (B3 = Math.max(A3, t3)) + ((U3 = 65536) - B3 % U3) % U3);
      if (lA(d3))
        return true;
    }
    return false;
  } }, dA = function() {
    var _a;
    var A3 = { a: tA };
    function Q3(A4, Q4) {
      var F3;
      return dA = A4.exports, n2 = dA.k, h2(), F3 = dA.l, o2.unshift(F3), function(A5) {
        var _a2;
        if (b2--, (_a2 = B2.monitorRunDependencies) == null ? void 0 : _a2.call(B2, b2), 0 == b2 && r2) {
          var Q5 = r2;
          r2 = null, Q5();
        }
      }(), dA;
    }
    if (b2++, (_a = B2.monitorRunDependencies) == null ? void 0 : _a.call(B2, b2), B2.instantiateWasm)
      try {
        return B2.instantiateWasm(A3, Q3);
      } catch (A4) {
        V2(`Module.instantiateWasm callback failed with error: ${A4}`), F2(A4);
      }
    return y2(0, m2, A3, function(A4) {
      Q3(A4.instance);
    }).catch(F2), {};
  }();
  B2._pack = (A3, Q3, F3, U3, l3, t3, d3, n3, V3, Z3, e3) => (B2._pack = dA.m)(A3, Q3, F3, U3, l3, t3, d3, n3, V3, Z3, e3);
  var nA, VA = B2._malloc = (A3) => (VA = B2._malloc = dA.o)(A3), ZA = B2._free = (A3) => (ZA = B2._free = dA.p)(A3);
  function eA() {
    function A3() {
      nA || (nA = true, B2.calledRun = true, C2 || (p(o2), Q2(B2), B2.onRuntimeInitialized && B2.onRuntimeInitialized(), function() {
        if (B2.postRun)
          for ("function" == typeof B2.postRun && (B2.postRun = [B2.postRun]); B2.postRun.length; )
            A4 = B2.postRun.shift(), J2.unshift(A4);
        var A4;
        p(J2);
      }()));
    }
    b2 > 0 || (function() {
      if (B2.preRun)
        for ("function" == typeof B2.preRun && (B2.preRun = [B2.preRun]); B2.preRun.length; )
          A4 = B2.preRun.shift(), s2.unshift(A4);
      var A4;
      p(s2);
    }(), b2 > 0 || (B2.setStatus ? (B2.setStatus("Running..."), setTimeout(function() {
      setTimeout(function() {
        B2.setStatus("");
      }, 1), A3();
    }, 1)) : A3()));
  }
  if (r2 = function A3() {
    nA || eA(), nA || (r2 = A3);
  }, B2.preInit)
    for ("function" == typeof B2.preInit && (B2.preInit = [B2.preInit]); B2.preInit.length > 0; )
      B2.preInit.pop()();
  return eA(), A2.ready;
};
var J = class {
  constructor(A2) {
    this.dataChanged = false, this.transformsChanged = false, this._updating = /* @__PURE__ */ new Set(), this._dirty = /* @__PURE__ */ new Set();
    let Q2 = 0, F2 = 0;
    this._splatIndices = /* @__PURE__ */ new Map(), this._offsets = /* @__PURE__ */ new Map();
    const B2 = /* @__PURE__ */ new Map();
    for (const U3 of A2.objects)
      U3 instanceof Z && (this._splatIndices.set(U3, F2), this._offsets.set(U3, Q2), B2.set(Q2, U3), Q2 += U3.data.vertexCount, F2++);
    this._vertexCount = Q2, this._width = 2048, this._height = Math.ceil(2 * this.vertexCount / this.width), this._data = new Uint32Array(this.width * this.height * 4), this._transformsWidth = 5, this._transformsHeight = B2.size, this._transforms = new Float32Array(this._transformsWidth * this._transformsHeight * 4), this._transformIndicesWidth = 1024, this._transformIndicesHeight = Math.ceil(this.vertexCount / this._transformIndicesWidth), this._transformIndices = new Uint32Array(this._transformIndicesWidth * this._transformIndicesHeight), this._positions = new Float32Array(3 * this.vertexCount), this._rotations = new Float32Array(4 * this.vertexCount), this._scales = new Float32Array(3 * this.vertexCount), this._worker = new s();
    const U2 = (A3) => {
      const Q3 = this._splatIndices.get(A3);
      this._transforms.set(A3.transform.buffer, 20 * Q3), this._transforms[20 * Q3 + 16] = A3.selected ? 1 : 0, A3.positionChanged = false, A3.rotationChanged = false, A3.scaleChanged = false, A3.selectedChanged = false, this.transformsChanged = true;
    };
    let l2;
    this._worker.onmessage = (A3) => {
      if (A3.data.response) {
        const Q3 = A3.data.response, F3 = B2.get(Q3.offset);
        U2(F3);
        const l3 = this._splatIndices.get(F3);
        for (let A4 = 0; A4 < F3.data.vertexCount; A4++)
          this._transformIndices[Q3.offset + A4] = l3;
        this._data.set(Q3.data, 8 * Q3.offset), F3.data.reattach(Q3.positions, Q3.rotations, Q3.scales, Q3.colors, Q3.selection), this._positions.set(Q3.worldPositions, 3 * Q3.offset), this._rotations.set(Q3.worldRotations, 4 * Q3.offset), this._scales.set(Q3.worldScales, 3 * Q3.offset), this._updating.delete(F3), F3.selectedChanged = false, this.dataChanged = true;
      }
    }, async function() {
      l2 = await o();
    }();
    const t2 = (A3) => {
      if (!l2)
        return void async function() {
          for (; !l2; )
            await new Promise((A4) => setTimeout(A4, 0));
        }().then(() => {
          t2(A3);
        });
      U2(A3);
      const Q3 = l2._malloc(3 * A3.data.vertexCount * 4), F3 = l2._malloc(4 * A3.data.vertexCount * 4), B3 = l2._malloc(3 * A3.data.vertexCount * 4), d3 = l2._malloc(4 * A3.data.vertexCount), n2 = l2._malloc(A3.data.vertexCount), V2 = l2._malloc(8 * A3.data.vertexCount * 4), Z2 = l2._malloc(3 * A3.data.vertexCount * 4), e2 = l2._malloc(4 * A3.data.vertexCount * 4), I2 = l2._malloc(3 * A3.data.vertexCount * 4);
      l2.HEAPF32.set(A3.data.positions, Q3 / 4), l2.HEAPF32.set(A3.data.rotations, F3 / 4), l2.HEAPF32.set(A3.data.scales, B3 / 4), l2.HEAPU8.set(A3.data.colors, d3), l2.HEAPU8.set(A3.data.selection, n2), l2._pack(A3.selected, A3.data.vertexCount, Q3, F3, B3, d3, n2, V2, Z2, e2, I2);
      const R2 = new Uint32Array(l2.HEAPU32.buffer, V2, 8 * A3.data.vertexCount), a2 = new Float32Array(l2.HEAPF32.buffer, Z2, 3 * A3.data.vertexCount), g2 = new Float32Array(l2.HEAPF32.buffer, e2, 4 * A3.data.vertexCount), i2 = new Float32Array(l2.HEAPF32.buffer, I2, 3 * A3.data.vertexCount), W2 = this._splatIndices.get(A3), c2 = this._offsets.get(A3);
      for (let Q4 = 0; Q4 < A3.data.vertexCount; Q4++)
        this._transformIndices[c2 + Q4] = W2;
      this._data.set(R2, 8 * c2), this._positions.set(a2, 3 * c2), this._rotations.set(g2, 4 * c2), this._scales.set(i2, 3 * c2), l2._free(Q3), l2._free(F3), l2._free(B3), l2._free(d3), l2._free(n2), l2._free(V2), l2._free(Z2), l2._free(e2), l2._free(I2), this.dataChanged = true;
    }, d2 = (A3) => {
      if ((A3.positionChanged || A3.rotationChanged || A3.scaleChanged || A3.selectedChanged) && U2(A3), !A3.data.changed || A3.data.detached)
        return;
      const Q3 = { position: new Float32Array(A3.position.flat()), rotation: new Float32Array(A3.rotation.flat()), scale: new Float32Array(A3.scale.flat()), selected: A3.selected, vertexCount: A3.data.vertexCount, positions: A3.data.positions, rotations: A3.data.rotations, scales: A3.data.scales, colors: A3.data.colors, selection: A3.data.selection, offset: this._offsets.get(A3) };
      this._worker.postMessage({ splat: Q3 }, [Q3.position.buffer, Q3.rotation.buffer, Q3.scale.buffer, Q3.positions.buffer, Q3.rotations.buffer, Q3.scales.buffer, Q3.colors.buffer, Q3.selection.buffer]), this._updating.add(A3), A3.data.detached = true;
    };
    this.getSplat = (A3) => {
      let Q3 = null;
      for (const [F3, B3] of this._offsets) {
        if (!(A3 >= B3))
          break;
        Q3 = F3;
      }
      return Q3;
    }, this.getLocalIndex = (A3, Q3) => Q3 - this._offsets.get(A3), this.markDirty = (A3) => {
      this._dirty.add(A3);
    }, this.rebuild = () => {
      for (const A3 of this._dirty)
        d2(A3);
      this._dirty.clear();
    }, this.dispose = () => {
      this._worker.terminate();
    };
    for (const A3 of this._splatIndices.keys())
      t2(A3);
  }
  get offsets() {
    return this._offsets;
  }
  get data() {
    return this._data;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get transforms() {
    return this._transforms;
  }
  get transformsWidth() {
    return this._transformsWidth;
  }
  get transformsHeight() {
    return this._transformsHeight;
  }
  get transformIndices() {
    return this._transformIndices;
  }
  get transformIndicesWidth() {
    return this._transformIndicesWidth;
  }
  get transformIndicesHeight() {
    return this._transformIndicesHeight;
  }
  get positions() {
    return this._positions;
  }
  get rotations() {
    return this._rotations;
  }
  get scales() {
    return this._scales;
  }
  get vertexCount() {
    return this._vertexCount;
  }
  get needsRebuild() {
    return this._dirty.size > 0;
  }
  get updating() {
    return this._updating.size > 0;
  }
};
var b = class {
  constructor(A2 = 0, Q2 = 0, F2 = 0, B2 = 255) {
    this.r = A2, this.g = Q2, this.b = F2, this.a = B2;
  }
  flat() {
    return [this.r, this.g, this.b, this.a];
  }
  flatNorm() {
    return [this.r / 255, this.g / 255, this.b / 255, this.a / 255];
  }
  toHexString() {
    return "#" + this.flat().map((A2) => A2.toString(16).padStart(2, "0")).join("");
  }
  toString() {
    return `[${this.flat().join(", ")}]`;
  }
};
var r = class extends h {
  constructor(A2, Q2) {
    super(A2, Q2), this._outlineThickness = 10, this._outlineColor = new b(255, 165, 0, 255), this._renderData = null, this._depthIndex = null, this._chunks = null, this._splatTexture = null;
    const F2 = A2.canvas, B2 = A2.gl;
    let U2, l2, t2, d2, n2, V2, e2, I2, R2, a2, g2, i2, W2, c2, h2, s2;
    this._resize = () => {
      this._camera && (this._camera.data.setSize(F2.width, F2.height), this._camera.update(), l2 = B2.getUniformLocation(this.program, "projection"), B2.uniformMatrix4fv(l2, false, this._camera.data.projectionMatrix.buffer), t2 = B2.getUniformLocation(this.program, "viewport"), B2.uniform2fv(t2, new Float32Array([F2.width, F2.height])));
    };
    const o2 = () => {
      U2 = new C(), U2.onmessage = (A3) => {
        if (A3.data.depthIndex) {
          const { depthIndex: Q3, chunks: F3 } = A3.data;
          this._depthIndex = Q3, this._chunks = F3, B2.bindBuffer(B2.ARRAY_BUFFER, s2), B2.bufferData(B2.ARRAY_BUFFER, Q3, B2.STATIC_DRAW);
        }
      };
    };
    this._initialize = () => {
      if (this._scene && this._camera) {
        this._resize(), this._scene.addEventListener("objectAdded", r2), this._scene.addEventListener("objectRemoved", E2);
        for (const A3 of this._scene.objects)
          A3 instanceof Z && A3.addEventListener("objectChanged", m2);
        this._renderData = new J(this._scene), d2 = B2.getUniformLocation(this.program, "focal"), B2.uniform2fv(d2, new Float32Array([this._camera.data.fx, this._camera.data.fy])), n2 = B2.getUniformLocation(this.program, "view"), B2.uniformMatrix4fv(n2, false, this._camera.data.viewMatrix.buffer), R2 = B2.getUniformLocation(this.program, "outlineThickness"), B2.uniform1f(R2, this.outlineThickness), a2 = B2.getUniformLocation(this.program, "outlineColor"), B2.uniform4fv(a2, new Float32Array(this.outlineColor.flatNorm())), this._splatTexture = B2.createTexture(), V2 = B2.getUniformLocation(this.program, "u_texture"), B2.uniform1i(V2, 0), W2 = B2.createTexture(), e2 = B2.getUniformLocation(this.program, "u_transforms"), B2.uniform1i(e2, 1), c2 = B2.createTexture(), I2 = B2.getUniformLocation(this.program, "u_transformIndices"), B2.uniform1i(I2, 2), h2 = B2.createBuffer(), B2.bindBuffer(B2.ARRAY_BUFFER, h2), B2.bufferData(B2.ARRAY_BUFFER, new Float32Array([-2, -2, 2, -2, 2, 2, -2, 2]), B2.STATIC_DRAW), g2 = B2.getAttribLocation(this.program, "position"), B2.enableVertexAttribArray(g2), B2.vertexAttribPointer(g2, 2, B2.FLOAT, false, 0, 0), s2 = B2.createBuffer(), i2 = B2.getAttribLocation(this.program, "index"), B2.enableVertexAttribArray(i2), B2.bindBuffer(B2.ARRAY_BUFFER, s2), o2();
      } else
        console.error("Cannot render without scene and camera");
    };
    const r2 = (A3) => {
      const Q3 = A3;
      Q3.object instanceof Z && Q3.object.addEventListener("objectChanged", m2), this.dispose();
    }, E2 = (A3) => {
      const Q3 = A3;
      Q3.object instanceof Z && Q3.object.removeEventListener("objectChanged", m2), this.dispose();
    }, m2 = (A3) => {
      const Q3 = A3;
      Q3.object instanceof Z && this._renderData && this._renderData.markDirty(Q3.object);
    };
    this._render = () => {
      if (this._scene && this._camera && this.renderData) {
        if (this._camera.update(), U2.postMessage({ viewProj: this._camera.data.viewProj }), this.renderData.needsRebuild && this.renderData.rebuild(), this.renderData.dataChanged || this.renderData.transformsChanged) {
          this.renderData.dataChanged && (B2.activeTexture(B2.TEXTURE0), B2.bindTexture(B2.TEXTURE_2D, this.splatTexture), B2.texParameteri(B2.TEXTURE_2D, B2.TEXTURE_WRAP_S, B2.CLAMP_TO_EDGE), B2.texParameteri(B2.TEXTURE_2D, B2.TEXTURE_WRAP_T, B2.CLAMP_TO_EDGE), B2.texParameteri(B2.TEXTURE_2D, B2.TEXTURE_MIN_FILTER, B2.NEAREST), B2.texParameteri(B2.TEXTURE_2D, B2.TEXTURE_MAG_FILTER, B2.NEAREST), B2.texImage2D(B2.TEXTURE_2D, 0, B2.RGBA32UI, this.renderData.width, this.renderData.height, 0, B2.RGBA_INTEGER, B2.UNSIGNED_INT, this.renderData.data)), this.renderData.transformsChanged && (B2.activeTexture(B2.TEXTURE1), B2.bindTexture(B2.TEXTURE_2D, W2), B2.texParameteri(B2.TEXTURE_2D, B2.TEXTURE_WRAP_S, B2.CLAMP_TO_EDGE), B2.texParameteri(B2.TEXTURE_2D, B2.TEXTURE_WRAP_T, B2.CLAMP_TO_EDGE), B2.texParameteri(B2.TEXTURE_2D, B2.TEXTURE_MIN_FILTER, B2.NEAREST), B2.texParameteri(B2.TEXTURE_2D, B2.TEXTURE_MAG_FILTER, B2.NEAREST), B2.texImage2D(B2.TEXTURE_2D, 0, B2.RGBA32F, this.renderData.transformsWidth, this.renderData.transformsHeight, 0, B2.RGBA, B2.FLOAT, this.renderData.transforms), B2.activeTexture(B2.TEXTURE2), B2.bindTexture(B2.TEXTURE_2D, c2), B2.texParameteri(B2.TEXTURE_2D, B2.TEXTURE_WRAP_S, B2.CLAMP_TO_EDGE), B2.texParameteri(B2.TEXTURE_2D, B2.TEXTURE_WRAP_T, B2.CLAMP_TO_EDGE), B2.texParameteri(B2.TEXTURE_2D, B2.TEXTURE_MIN_FILTER, B2.NEAREST), B2.texParameteri(B2.TEXTURE_2D, B2.TEXTURE_MAG_FILTER, B2.NEAREST), B2.texImage2D(B2.TEXTURE_2D, 0, B2.R32UI, this.renderData.transformIndicesWidth, this.renderData.transformIndicesHeight, 0, B2.RED_INTEGER, B2.UNSIGNED_INT, this.renderData.transformIndices));
          const A3 = new Float32Array(this.renderData.positions.slice().buffer), Q3 = new Float32Array(this.renderData.transforms.slice().buffer), F3 = new Uint32Array(this.renderData.transformIndices.slice().buffer);
          U2.postMessage({ sortData: { positions: A3, transforms: Q3, transformIndices: F3, vertexCount: this.renderData.vertexCount } }, [A3.buffer, Q3.buffer, F3.buffer]), this.renderData.dataChanged = false, this.renderData.transformsChanged = false;
        }
        B2.viewport(0, 0, F2.width, F2.height), B2.clearColor(0, 0, 0, 0), B2.clear(B2.COLOR_BUFFER_BIT), B2.disable(B2.DEPTH_TEST), B2.enable(B2.BLEND), B2.blendFuncSeparate(B2.ONE_MINUS_DST_ALPHA, B2.ONE, B2.ONE_MINUS_DST_ALPHA, B2.ONE), B2.blendEquationSeparate(B2.FUNC_ADD, B2.FUNC_ADD), B2.uniformMatrix4fv(l2, false, this._camera.data.projectionMatrix.buffer), B2.uniformMatrix4fv(n2, false, this._camera.data.viewMatrix.buffer), B2.bindBuffer(B2.ARRAY_BUFFER, h2), B2.vertexAttribPointer(g2, 2, B2.FLOAT, false, 0, 0), B2.bindBuffer(B2.ARRAY_BUFFER, s2), B2.vertexAttribIPointer(i2, 1, B2.INT, 0, 0), B2.vertexAttribDivisor(i2, 1), B2.drawArraysInstanced(B2.TRIANGLE_FAN, 0, 4, this.renderData.vertexCount);
      } else
        console.error("Cannot render without scene and camera");
    }, this._dispose = () => {
      if (this._scene && this._camera && this.renderData) {
        this._scene.removeEventListener("objectAdded", r2), this._scene.removeEventListener("objectRemoved", E2);
        for (const A3 of this._scene.objects)
          A3 instanceof Z && A3.removeEventListener("objectChanged", m2);
        U2.terminate(), this.renderData.dispose(), B2.deleteTexture(this.splatTexture), B2.deleteTexture(W2), B2.deleteTexture(c2), B2.deleteBuffer(s2), B2.deleteBuffer(h2);
      } else
        console.error("Cannot dispose without scene and camera");
    }, this._setOutlineThickness = (A3) => {
      this._outlineThickness = A3, this._initialized && B2.uniform1f(R2, A3);
    }, this._setOutlineColor = (A3) => {
      this._outlineColor = A3, this._initialized && B2.uniform4fv(a2, new Float32Array(A3.flatNorm()));
    };
  }
  get renderData() {
    return this._renderData;
  }
  get depthIndex() {
    return this._depthIndex;
  }
  get chunks() {
    return this._chunks;
  }
  get splatTexture() {
    return this._splatTexture;
  }
  get outlineThickness() {
    return this._outlineThickness;
  }
  set outlineThickness(A2) {
    this._setOutlineThickness(A2);
  }
  get outlineColor() {
    return this._outlineColor;
  }
  set outlineColor(A2) {
    this._setOutlineColor(A2);
  }
  _getVertexSource() {
    return "#version 300 es\nprecision highp float;\nprecision highp int;\n\nuniform highp usampler2D u_texture;\nuniform highp sampler2D u_transforms;\nuniform highp usampler2D u_transformIndices;\nuniform mat4 projection, view;\nuniform vec2 focal;\nuniform vec2 viewport;\n\nuniform bool useDepthFade;\nuniform float depthFade;\n\nin vec2 position;\nin int index;\n\nout vec4 vColor;\nout vec2 vPosition;\nout float vSize;\nout float vSelected;\n\nvoid main () {\n    uvec4 cen = texelFetch(u_texture, ivec2((uint(index) & 0x3ffu) << 1, uint(index) >> 10), 0);\n    float selected = float((cen.w >> 24) & 0xffu);\n\n    uint transformIndex = texelFetch(u_transformIndices, ivec2(uint(index) & 0x3ffu, uint(index) >> 10), 0).x;\n    mat4 transform = mat4(\n        texelFetch(u_transforms, ivec2(0, transformIndex), 0),\n        texelFetch(u_transforms, ivec2(1, transformIndex), 0),\n        texelFetch(u_transforms, ivec2(2, transformIndex), 0),\n        texelFetch(u_transforms, ivec2(3, transformIndex), 0)\n    );\n\n    if (selected < 0.5) {\n        selected = texelFetch(u_transforms, ivec2(4, transformIndex), 0).x;\n    }\n\n    mat4 viewTransform = view * transform;\n\n    vec4 cam = viewTransform * vec4(uintBitsToFloat(cen.xyz), 1);\n    vec4 pos2d = projection * cam;\n\n    float clip = 1.2 * pos2d.w;\n    if (pos2d.z < -pos2d.w || pos2d.x < -clip || pos2d.x > clip || pos2d.y < -clip || pos2d.y > clip) {\n        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n        return;\n    }\n\n    uvec4 cov = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 1) | 1u, uint(index) >> 10), 0);\n    vec2 u1 = unpackHalf2x16(cov.x), u2 = unpackHalf2x16(cov.y), u3 = unpackHalf2x16(cov.z);\n    mat3 Vrk = mat3(u1.x, u1.y, u2.x, u1.y, u2.y, u3.x, u2.x, u3.x, u3.y);\n\n    mat3 J = mat3(\n        focal.x / cam.z, 0., -(focal.x * cam.x) / (cam.z * cam.z), \n        0., -focal.y / cam.z, (focal.y * cam.y) / (cam.z * cam.z), \n        0., 0., 0.\n    );\n\n    mat3 T = transpose(mat3(viewTransform)) * J;\n    mat3 cov2d = transpose(T) * Vrk * T;\n\n    float mid = (cov2d[0][0] + cov2d[1][1]) / 2.0;\n    float radius = length(vec2((cov2d[0][0] - cov2d[1][1]) / 2.0, cov2d[0][1]));\n    float lambda1 = mid + radius, lambda2 = mid - radius;\n\n    if (lambda2 < 0.0) return;\n    vec2 diagonalVector = normalize(vec2(cov2d[0][1], lambda1 - cov2d[0][0]));\n    vec2 majorAxis = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;\n    vec2 minorAxis = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);\n\n    vColor = vec4((cov.w) & 0xffu, (cov.w >> 8) & 0xffu, (cov.w >> 16) & 0xffu, (cov.w >> 24) & 0xffu) / 255.0;\n    vPosition = position;\n    vSize = length(majorAxis);\n    vSelected = selected;\n\n    float scalingFactor = 1.0;\n\n    if (useDepthFade) {\n        float depthNorm = (pos2d.z / pos2d.w + 1.0) / 2.0;\n        float near = 0.1; float far = 100.0;\n        float normalizedDepth = (2.0 * near) / (far + near - depthNorm * (far - near));\n        float start = max(normalizedDepth - 0.1, 0.0);\n        float end = min(normalizedDepth + 0.1, 1.0);\n        scalingFactor = clamp((depthFade - start) / (end - start), 0.0, 1.0);\n    }\n\n    vec2 vCenter = vec2(pos2d) / pos2d.w;\n    gl_Position = vec4(\n        vCenter \n        + position.x * majorAxis * scalingFactor / viewport\n        + position.y * minorAxis * scalingFactor / viewport, 0.0, 1.0);\n}\n";
  }
  _getFragmentSource() {
    return "#version 300 es\nprecision highp float;\n\nuniform float outlineThickness;\nuniform vec4 outlineColor;\n\nin vec4 vColor;\nin vec2 vPosition;\nin float vSize;\nin float vSelected;\n\nout vec4 fragColor;\n\nvoid main () {\n    float A = -dot(vPosition, vPosition);\n\n    if (A < -4.0) discard;\n\n    if (vSelected < 0.5) {\n        float B = exp(A) * vColor.a;\n        fragColor = vec4(B * vColor.rgb, B);\n        return;\n    }\n\n    float outlineThreshold = -4.0 + (outlineThickness / vSize);\n\n    if (A < outlineThreshold) {\n        fragColor = outlineColor;\n    } \n    else {\n        float B = exp(A) * vColor.a;\n        fragColor = vec4(B * vColor.rgb, B);\n    }\n}\n";
  }
};
var E = class {
  constructor(A2 = 1) {
    let Q2, F2, B2, U2, l2 = 0, t2 = false;
    this.initialize = (A3) => {
      if (!(A3 instanceof r))
        throw new Error("FadeInPass requires a RenderProgram");
      l2 = A3.started ? 1 : 0, t2 = true, Q2 = A3, F2 = A3.renderer.gl, B2 = F2.getUniformLocation(Q2.program, "useDepthFade"), F2.uniform1i(B2, 1), U2 = F2.getUniformLocation(Q2.program, "depthFade"), F2.uniform1f(U2, l2);
    }, this.render = () => {
      var d2;
      t2 && !(null === (d2 = Q2.renderData) || void 0 === d2 ? void 0 : d2.updating) && (F2.useProgram(Q2.program), l2 = Math.min(l2 + 0.01 * A2, 1), l2 >= 1 && (t2 = false, F2.uniform1i(B2, 0)), F2.uniform1f(U2, l2));
    };
  }
  dispose() {
  }
};
var m = class {
  constructor(A2 = null, Q2 = null) {
    this._backgroundColor = new b();
    const F2 = A2 || document.createElement("canvas");
    A2 || (F2.style.display = "block", F2.style.boxSizing = "border-box", F2.style.width = "100%", F2.style.height = "100%", F2.style.margin = "0", F2.style.padding = "0", document.body.appendChild(F2)), F2.style.background = this._backgroundColor.toHexString(), this._canvas = F2, this._gl = F2.getContext("webgl2", { antialias: false });
    const B2 = Q2 || [];
    Q2 || B2.push(new E()), this._renderProgram = new r(this, B2);
    const U2 = [this._renderProgram];
    this.resize = () => {
      const A3 = F2.clientWidth, Q3 = F2.clientHeight;
      F2.width === A3 && F2.height === Q3 || this.setSize(A3, Q3);
    }, this.setSize = (A3, Q3) => {
      F2.width = A3, F2.height = Q3, this._gl.viewport(0, 0, F2.width, F2.height);
      for (const A4 of U2)
        A4.resize();
    }, this.render = (A3, Q3) => {
      for (const F3 of U2)
        F3.render(A3, Q3);
    }, this.dispose = () => {
      for (const A3 of U2)
        A3.dispose();
    }, this.addProgram = (A3) => {
      U2.push(A3);
    }, this.removeProgram = (A3) => {
      const Q3 = U2.indexOf(A3);
      if (Q3 < 0)
        throw new Error("Program not found");
      U2.splice(Q3, 1);
    }, this.resize();
  }
  get canvas() {
    return this._canvas;
  }
  get gl() {
    return this._gl;
  }
  get renderProgram() {
    return this._renderProgram;
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(A2) {
    this._backgroundColor = A2, this._canvas.style.background = A2.toHexString();
  }
};
var N = class {
  constructor(F2, B2, U2 = 0.5, l2 = 0.5, t2 = 5, d2 = true, V2 = new A()) {
    this.minAngle = -90, this.maxAngle = 90, this.minZoom = 0.1, this.maxZoom = 30, this.orbitSpeed = 1, this.panSpeed = 1, this.zoomSpeed = 1, this.dampening = 0.12, this.setCameraTarget = () => {
    };
    let Z2 = V2.clone(), e2 = Z2.clone(), I2 = U2, R2 = l2, a2 = t2, g2 = false, i2 = false, W2 = 0, c2 = 0, C2 = 0;
    const h2 = {};
    let s2 = false;
    F2.addEventListener("objectChanged", () => {
      if (s2)
        return;
      const Q2 = F2.rotation.toEuler();
      I2 = -Q2.y, R2 = -Q2.x;
      const B3 = F2.position.x - a2 * Math.sin(I2) * Math.cos(R2), U3 = F2.position.y + a2 * Math.sin(R2), l3 = F2.position.z + a2 * Math.cos(I2) * Math.cos(R2);
      e2 = new A(B3, U3, l3);
    }), this.setCameraTarget = (Q2) => {
      const B3 = Q2.x - F2.position.x, U3 = Q2.y - F2.position.y, l3 = Q2.z - F2.position.z;
      a2 = Math.sqrt(B3 * B3 + U3 * U3 + l3 * l3), R2 = Math.atan2(U3, Math.sqrt(B3 * B3 + l3 * l3)), I2 = -Math.atan2(B3, l3), e2 = new A(Q2.x, Q2.y, Q2.z);
    };
    const o2 = () => 0.1 + 0.9 * (a2 - this.minZoom) / (this.maxZoom - this.minZoom), J2 = (A2) => {
      h2[A2.code] = true, "ArrowUp" === A2.code && (h2.KeyW = true), "ArrowDown" === A2.code && (h2.KeyS = true), "ArrowLeft" === A2.code && (h2.KeyA = true), "ArrowRight" === A2.code && (h2.KeyD = true);
    }, b2 = (A2) => {
      h2[A2.code] = false, "ArrowUp" === A2.code && (h2.KeyW = false), "ArrowDown" === A2.code && (h2.KeyS = false), "ArrowLeft" === A2.code && (h2.KeyA = false), "ArrowRight" === A2.code && (h2.KeyD = false);
    }, r2 = (A2) => {
      p(A2), g2 = true, i2 = 2 === A2.button, c2 = A2.clientX, C2 = A2.clientY, window.addEventListener("mouseup", E2);
    }, E2 = (A2) => {
      p(A2), g2 = false, i2 = false, window.removeEventListener("mouseup", E2);
    }, m2 = (Q2) => {
      if (p(Q2), !g2 || !F2)
        return;
      const B3 = Q2.clientX - c2, U3 = Q2.clientY - C2;
      if (i2) {
        const Q3 = o2(), l3 = -B3 * this.panSpeed * 0.01 * Q3, t3 = -U3 * this.panSpeed * 0.01 * Q3, d3 = n.RotationFromQuaternion(F2.rotation).buffer, V3 = new A(d3[0], d3[3], d3[6]), Z3 = new A(d3[1], d3[4], d3[7]);
        e2 = e2.add(V3.multiply(l3)), e2 = e2.add(Z3.multiply(t3));
      } else
        I2 -= B3 * this.orbitSpeed * 3e-3, R2 += U3 * this.orbitSpeed * 3e-3, R2 = Math.min(Math.max(R2, this.minAngle * Math.PI / 180), this.maxAngle * Math.PI / 180);
      c2 = Q2.clientX, C2 = Q2.clientY;
    }, N2 = (A2) => {
      p(A2);
      const Q2 = o2();
      a2 += A2.deltaY * this.zoomSpeed * 0.025 * Q2, a2 = Math.min(Math.max(a2, this.minZoom), this.maxZoom);
    }, G2 = (A2) => {
      if (p(A2), 1 === A2.touches.length)
        g2 = true, i2 = false, c2 = A2.touches[0].clientX, C2 = A2.touches[0].clientY, W2 = 0;
      else if (2 === A2.touches.length) {
        g2 = true, i2 = true, c2 = (A2.touches[0].clientX + A2.touches[1].clientX) / 2, C2 = (A2.touches[0].clientY + A2.touches[1].clientY) / 2;
        const Q2 = A2.touches[0].clientX - A2.touches[1].clientX, F3 = A2.touches[0].clientY - A2.touches[1].clientY;
        W2 = Math.sqrt(Q2 * Q2 + F3 * F3);
      }
    }, X2 = (A2) => {
      p(A2), g2 = false, i2 = false;
    }, Y2 = (Q2) => {
      if (p(Q2), g2 && F2)
        if (i2) {
          const B3 = o2(), U3 = Q2.touches[0].clientX - Q2.touches[1].clientX, l3 = Q2.touches[0].clientY - Q2.touches[1].clientY, t3 = Math.sqrt(U3 * U3 + l3 * l3);
          a2 += (W2 - t3) * this.zoomSpeed * 0.1 * B3, a2 = Math.min(Math.max(a2, this.minZoom), this.maxZoom), W2 = t3;
          const d3 = (Q2.touches[0].clientX + Q2.touches[1].clientX) / 2, V3 = (Q2.touches[0].clientY + Q2.touches[1].clientY) / 2, Z3 = d3 - c2, I3 = V3 - C2, R3 = n.RotationFromQuaternion(F2.rotation).buffer, g3 = new A(R3[0], R3[3], R3[6]), i3 = new A(R3[1], R3[4], R3[7]);
          e2 = e2.add(g3.multiply(-Z3 * this.panSpeed * 0.025 * B3)), e2 = e2.add(i3.multiply(-I3 * this.panSpeed * 0.025 * B3)), c2 = d3, C2 = V3;
        } else {
          const A2 = Q2.touches[0].clientX - c2, F3 = Q2.touches[0].clientY - C2;
          I2 -= A2 * this.orbitSpeed * 3e-3, R2 += F3 * this.orbitSpeed * 3e-3, R2 = Math.min(Math.max(R2, this.minAngle * Math.PI / 180), this.maxAngle * Math.PI / 180), c2 = Q2.touches[0].clientX, C2 = Q2.touches[0].clientY;
        }
    }, y2 = (A2, Q2, F3) => (1 - F3) * A2 + F3 * Q2;
    this.update = () => {
      s2 = true, U2 = y2(U2, I2, this.dampening), l2 = y2(l2, R2, this.dampening), t2 = y2(t2, a2, this.dampening), Z2 = Z2.lerp(e2, this.dampening);
      const B3 = Z2.x + t2 * Math.sin(U2) * Math.cos(l2), d3 = Z2.y - t2 * Math.sin(l2), V3 = Z2.z - t2 * Math.cos(U2) * Math.cos(l2);
      F2.position = new A(B3, d3, V3);
      const g3 = Z2.subtract(F2.position).normalize(), i3 = Math.asin(-g3.y), W3 = Math.atan2(g3.x, g3.z);
      F2.rotation = Q.FromEuler(new A(i3, W3, 0));
      const c3 = 0.025, C3 = 0.01, o3 = n.RotationFromQuaternion(F2.rotation).buffer, J3 = new A(-o3[2], -o3[5], -o3[8]), b3 = new A(o3[0], o3[3], o3[6]);
      h2.KeyS && (e2 = e2.add(J3.multiply(c3))), h2.KeyW && (e2 = e2.subtract(J3.multiply(c3))), h2.KeyA && (e2 = e2.subtract(b3.multiply(c3))), h2.KeyD && (e2 = e2.add(b3.multiply(c3))), h2.KeyE && (I2 += C3), h2.KeyQ && (I2 -= C3), h2.KeyR && (R2 += C3), h2.KeyF && (R2 -= C3), s2 = false;
    };
    const p = (A2) => {
      A2.preventDefault(), A2.stopPropagation();
    };
    this.dispose = () => {
      B2.removeEventListener("dragenter", p), B2.removeEventListener("dragover", p), B2.removeEventListener("dragleave", p), B2.removeEventListener("contextmenu", p), B2.removeEventListener("mousedown", r2), B2.removeEventListener("mousemove", m2), B2.removeEventListener("wheel", N2), B2.removeEventListener("touchstart", G2), B2.removeEventListener("touchend", X2), B2.removeEventListener("touchmove", Y2), d2 && (window.removeEventListener("keydown", J2), window.removeEventListener("keyup", b2));
    }, d2 && (window.addEventListener("keydown", J2), window.addEventListener("keyup", b2)), B2.addEventListener("dragenter", p), B2.addEventListener("dragover", p), B2.addEventListener("dragleave", p), B2.addEventListener("contextmenu", p), B2.addEventListener("mousedown", r2), B2.addEventListener("mousemove", m2), B2.addEventListener("wheel", N2), B2.addEventListener("touchstart", G2), B2.addEventListener("touchend", X2), B2.addEventListener("touchmove", Y2), this.update();
  }
};
var G = class {
  constructor(A2, Q2) {
    this.normal = A2, this.point = Q2;
  }
  intersect(A2, Q2) {
    const F2 = this.normal.dot(Q2);
    if (Math.abs(F2) < 1e-4)
      return null;
    const B2 = this.normal.dot(this.point.subtract(A2)) / F2;
    return B2 < 0 ? null : A2.add(Q2.multiply(B2));
  }
};
var X = class {
  initialize(A2) {
  }
  render() {
  }
  dispose() {
  }
};
var Y = function(A2 = {}) {
  var Q2, F2, B2 = A2;
  B2.ready = new Promise((A3, B3) => {
    Q2 = A3, F2 = B3;
  });
  var U2 = Object.assign({}, B2), l2 = "";
  "undefined" != typeof document && document.currentScript && (l2 = document.currentScript.src), l2 = 0 !== l2.indexOf("blob:") ? l2.substr(0, l2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", B2.print || console.log.bind(console);
  var t2, d2, n2 = B2.printErr || console.error.bind(console);
  function V2(A3) {
    if (G2(A3))
      return function(A4) {
        for (var Q3 = atob(A4), F3 = new Uint8Array(Q3.length), B3 = 0; B3 < Q3.length; ++B3)
          F3[B3] = Q3.charCodeAt(B3);
        return F3;
      }(A3.slice(N2.length));
  }
  Object.assign(B2, U2), U2 = null, B2.arguments && B2.arguments, B2.thisProgram && B2.thisProgram, B2.quit && B2.quit, B2.wasmBinary && (t2 = B2.wasmBinary), "object" != typeof WebAssembly && r2("no native wasm support detected");
  var Z2, e2, I2, R2, a2, g2, i2, W2, c2 = false;
  function C2() {
    var A3 = d2.buffer;
    B2.HEAP8 = Z2 = new Int8Array(A3), B2.HEAP16 = I2 = new Int16Array(A3), B2.HEAPU8 = e2 = new Uint8Array(A3), B2.HEAPU16 = R2 = new Uint16Array(A3), B2.HEAP32 = a2 = new Int32Array(A3), B2.HEAPU32 = g2 = new Uint32Array(A3), B2.HEAPF32 = i2 = new Float32Array(A3), B2.HEAPF64 = W2 = new Float64Array(A3);
  }
  var h2 = [], s2 = [], o2 = [], J2 = 0, b2 = null;
  function r2(A3) {
    var _a;
    (_a = B2.onAbort) == null ? void 0 : _a.call(B2, A3), n2(A3 = "Aborted(" + A3 + ")"), c2 = true, A3 += ". Build with -sASSERTIONS for more info.";
    var Q3 = new WebAssembly.RuntimeError(A3);
    throw F2(Q3), Q3;
  }
  var E2, m2, N2 = "data:application/octet-stream;base64,", G2 = (A3) => A3.startsWith(N2);
  function X2(A3) {
    return Promise.resolve().then(() => function(A4) {
      if (A4 == E2 && t2)
        return new Uint8Array(t2);
      var Q3 = V2(A4);
      if (Q3)
        return Q3;
      throw "both async and sync fetching of the wasm failed";
    }(A3));
  }
  function Y2(A3, Q3, F3, B3) {
    return function(A4, Q4, F4) {
      return X2(A4).then((A5) => WebAssembly.instantiate(A5, Q4)).then((A5) => A5).then(F4, (A5) => {
        n2(`failed to asynchronously prepare wasm: ${A5}`), r2(A5);
      });
    }(Q3, F3, B3);
  }
  G2(E2 = "data:application/octet-stream;base64,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IAUQCgRAIAEgAiADIAQQEw8LIAAoAggiACABIAIgAyAEIAUgACgCACgCFBEDAAuRAQAgACABKAIIIAQQCgRAIAEgAiADEBEPCwJAIAAgASgCACAEEApFDQACQCACIAEoAhBHBEAgASgCFCACRw0BCyADQQFHDQEgAUEBNgIgDwsgASACNgIUIAEgAzYCICABIAEoAihBAWo2AigCQCABKAIkQQFHDQAgASgCGEECRw0AIAFBAToANgsgAUEENgIsCwvyAQAgACABKAIIIAQQCgRAIAEgAiADEBEPCwJAIAAgASgCACAEEAoEQAJAIAIgASgCEEcEQCABKAIUIAJHDQELIANBAUcNAiABQQE2AiAPCyABIAM2AiACQCABKAIsQQRGDQAgAUEAOwE0IAAoAggiACABIAIgAkEBIAQgACgCACgCFBEDACABLQA1BEAgAUEDNgIsIAEtADRFDQEMAwsgAUEENgIsCyABIAI2AhQgASABKAIoQQFqNgIoIAEoAiRBAUcNASABKAIYQQJHDQEgAUEBOgA2DwsgACgCCCIAIAEgAiADIAQgACgCACgCGBECAAsLMQAgACABKAIIQQAQCgRAIAEgAiADEBQPCyAAKAIIIgAgASACIAMgACgCACgCHBEAAAsYACAAIAEoAghBABAKBEAgASACIAMQFAsLgAMBBH8jAEHwAGsiAiQAIAAoAgAiA0EEaygCACEEIANBCGsoAgAhBSACQgA3AlAgAkIANwJYIAJCADcCYCACQgA3AGcgAkIANwJIIAJBADYCRCACQfwVNgJAIAIgADYCPCACIAE2AjggACAFaiEDAkAgBCABQQAQCgRAQQAgAyAFGyEADAELIAAgA04EQCACQgA3AC8gAkIANwIYIAJCADcCICACQgA3AiggAkIANwIQIAJBADYCDCACIAE2AgggAiAANgIEIAIgBDYCACACQQE2AjAgBCACIAMgA0EBQQAgBCgCACgCFBEDACACKAIYDQELQQAhACAEIAJBOGogA0EBQQAgBCgCACgCGBECAAJAAkAgAigCXA4CAAECCyACKAJMQQAgAigCWEEBRhtBACACKAJUQQFGG0EAIAIoAmBBAUYbIQAMAQsgAigCUEEBRwRAIAIoAmANASACKAJUQQFHDQEgAigCWEEBRw0BCyACKAJIIQALIAJB8ABqJAAgAAu1AQEEfyMAQUBqIgMkAAJ/QQEgACABQQAQCg0AGkEAIAFFDQAaQQAgAUGsFhAgIgFFDQAaIANBDGohBEE0IQUDQCAEQQA6AAAgBEEBaiEEIAVBAWsiBQ0ACyADQQE2AjggA0F/NgIUIAMgADYCECADIAE2AgggASADQQhqIAIoAgBBASABKAIAKAIcEQAAIAMoAiAiAEEBRgRAIAIgAygCGDYCAAsgAEEBRgshBiADQUBrJAAgBgsKACAAIAFBABAKCwvHEgIAQYAIC7YSdW5zaWduZWQgc2hvcnQAdW5zaWduZWQgaW50AGZsb2F0AHVpbnQ2NF90AHVuc2lnbmVkIGNoYXIAYm9vbABlbXNjcmlwdGVuOjp2YWwAdW5zaWduZWQgbG9uZwBzdGQ6OndzdHJpbmcAc3RkOjpzdHJpbmcAc3RkOjp1MTZzdHJpbmcAc3RkOjp1MzJzdHJpbmcAZG91YmxlAHZvaWQAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ2NF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4ATlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUAAAAApAwAAEIHAABOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQAApAwAAIwHAABOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQAApAwAANQHAABOU3QzX18yMTJiYXNpY19zdHJpbmdJRHNOU18xMWNoYXJfdHJhaXRzSURzRUVOU185YWxsb2NhdG9ySURzRUVFRQAAAKQMAAAcCAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURpTlNfMTFjaGFyX3RyYWl0c0lEaUVFTlNfOWFsbG9jYXRvcklEaUVFRUUAAACkDAAAaAgAAE4xMGVtc2NyaXB0ZW4zdmFsRQAApAwAALQIAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUAAKQMAADQCAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAACkDAAA+AgAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWhFRQAApAwAACAJAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUAAKQMAABICQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAACkDAAAcAkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAApAwAAJgJAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUAAKQMAADACQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAACkDAAA6AkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAApAwAABAKAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l4RUUAAKQMAAA4CgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJeUVFAACkDAAAYAoAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWZFRQAApAwAAIgKAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lkRUUAAKQMAACwCgAATjEwX19jeHhhYml2MTE2X19zaGltX3R5cGVfaW5mb0UAAAAAzAwAANgKAAAwDQAATjEwX19jeHhhYml2MTE3X19jbGFzc190eXBlX2luZm9FAAAAzAwAAAgLAAD8CgAATjEwX19jeHhhYml2MTE3X19wYmFzZV90eXBlX2luZm9FAAAAzAwAADgLAAD8CgAATjEwX19jeHhhYml2MTE5X19wb2ludGVyX3R5cGVfaW5mb0UAzAwAAGgLAABcCwAAAAAAANwLAAACAAAAAwAAAAQAAAAFAAAABgAAAE4xMF9fY3h4YWJpdjEyM19fZnVuZGFtZW50YWxfdHlwZV9pbmZvRQDMDAAAtAsAAPwKAAB2AAAAoAsAAOgLAABiAAAAoAsAAPQLAABjAAAAoAsAAAAMAABoAAAAoAsAAAwMAABhAAAAoAsAABgMAABzAAAAoAsAACQMAAB0AAAAoAsAADAMAABpAAAAoAsAADwMAABqAAAAoAsAAEgMAABsAAAAoAsAAFQMAABtAAAAoAsAAGAMAAB4AAAAoAsAAGwMAAB5AAAAoAsAAHgMAABmAAAAoAsAAIQMAABkAAAAoAsAAJAMAAAAAAAALAsAAAIAAAAHAAAABAAAAAUAAAAIAAAACQAAAAoAAAALAAAAAAAAABQNAAACAAAADAAAAAQAAAAFAAAACAAAAA0AAAAOAAAADwAAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAADMDAAA7AwAACwLAABTdDl0eXBlX2luZm8AAAAApAwAACANAEG4GgsD8A8B") || (m2 = E2, E2 = B2.locateFile ? B2.locateFile(m2, l2) : l2 + m2);
  var y2 = (A3) => {
    for (; A3.length > 0; )
      A3.shift()(B2);
  };
  B2.noExitRuntime;
  var p, S, k = (A3) => {
    for (var Q3 = "", F3 = A3; e2[F3]; )
      Q3 += p[e2[F3++]];
    return Q3;
  }, u = {}, T = {}, D = (A3) => {
    throw new S(A3);
  };
  function H(A3, Q3, F3 = {}) {
    if (!("argPackAdvance" in Q3))
      throw new TypeError("registerType registeredInstance requires argPackAdvance");
    return function(A4, Q4, F4 = {}) {
      var B3 = Q4.name;
      if (A4 || D(`type "${B3}" must have a positive integer typeid pointer`), T.hasOwnProperty(A4)) {
        if (F4.ignoreDuplicateRegistrations)
          return;
        D(`Cannot register type '${B3}' twice`);
      }
      if (T[A4] = Q4, u.hasOwnProperty(A4)) {
        var U3 = u[A4];
        delete u[A4], U3.forEach((A5) => A5());
      }
    }(A3, Q3, F3);
  }
  function w() {
    this.allocated = [void 0], this.freelist = [];
  }
  var x = new w(), f = () => {
    for (var A3 = 0, Q3 = x.reserved; Q3 < x.allocated.length; ++Q3)
      void 0 !== x.allocated[Q3] && ++A3;
    return A3;
  }, M = (A3) => (A3 || D("Cannot use deleted val. handle = " + A3), x.get(A3).value), z = (A3) => {
    switch (A3) {
      case void 0:
        return 1;
      case null:
        return 2;
      case true:
        return 3;
      case false:
        return 4;
      default:
        return x.allocate({ refcount: 1, value: A3 });
    }
  };
  function v(A3) {
    return this.fromWireType(a2[A3 >> 2]);
  }
  var K = (A3, Q3) => {
    switch (Q3) {
      case 4:
        return function(A4) {
          return this.fromWireType(i2[A4 >> 2]);
        };
      case 8:
        return function(A4) {
          return this.fromWireType(W2[A4 >> 3]);
        };
      default:
        throw new TypeError(`invalid float width (${Q3}): ${A3}`);
    }
  }, j = (A3, Q3, F3) => {
    switch (Q3) {
      case 1:
        return F3 ? (A4) => Z2[A4 >> 0] : (A4) => e2[A4 >> 0];
      case 2:
        return F3 ? (A4) => I2[A4 >> 1] : (A4) => R2[A4 >> 1];
      case 4:
        return F3 ? (A4) => a2[A4 >> 2] : (A4) => g2[A4 >> 2];
      default:
        throw new TypeError(`invalid integer width (${Q3}): ${A3}`);
    }
  };
  function O(A3) {
    return this.fromWireType(g2[A3 >> 2]);
  }
  var L = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, P = (A3, Q3) => A3 ? ((A4, Q4, F3) => {
    for (var B3 = Q4 + F3, U3 = Q4; A4[U3] && !(U3 >= B3); )
      ++U3;
    if (U3 - Q4 > 16 && A4.buffer && L)
      return L.decode(A4.subarray(Q4, U3));
    for (var l3 = ""; Q4 < U3; ) {
      var t3 = A4[Q4++];
      if (128 & t3) {
        var d3 = 63 & A4[Q4++];
        if (192 != (224 & t3)) {
          var n3 = 63 & A4[Q4++];
          if ((t3 = 224 == (240 & t3) ? (15 & t3) << 12 | d3 << 6 | n3 : (7 & t3) << 18 | d3 << 12 | n3 << 6 | 63 & A4[Q4++]) < 65536)
            l3 += String.fromCharCode(t3);
          else {
            var V3 = t3 - 65536;
            l3 += String.fromCharCode(55296 | V3 >> 10, 56320 | 1023 & V3);
          }
        } else
          l3 += String.fromCharCode((31 & t3) << 6 | d3);
      } else
        l3 += String.fromCharCode(t3);
    }
    return l3;
  })(e2, A3, Q3) : "", _ = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0, q = (A3, Q3) => {
    for (var F3 = A3, B3 = F3 >> 1, U3 = B3 + Q3 / 2; !(B3 >= U3) && R2[B3]; )
      ++B3;
    if ((F3 = B3 << 1) - A3 > 32 && _)
      return _.decode(e2.subarray(A3, F3));
    for (var l3 = "", t3 = 0; !(t3 >= Q3 / 2); ++t3) {
      var d3 = I2[A3 + 2 * t3 >> 1];
      if (0 == d3)
        break;
      l3 += String.fromCharCode(d3);
    }
    return l3;
  }, $ = (A3, Q3, F3) => {
    if (F3 ?? (F3 = 2147483647), F3 < 2)
      return 0;
    for (var B3 = Q3, U3 = (F3 -= 2) < 2 * A3.length ? F3 / 2 : A3.length, l3 = 0; l3 < U3; ++l3) {
      var t3 = A3.charCodeAt(l3);
      I2[Q3 >> 1] = t3, Q3 += 2;
    }
    return I2[Q3 >> 1] = 0, Q3 - B3;
  }, AA = (A3) => 2 * A3.length, QA = (A3, Q3) => {
    for (var F3 = 0, B3 = ""; !(F3 >= Q3 / 4); ) {
      var U3 = a2[A3 + 4 * F3 >> 2];
      if (0 == U3)
        break;
      if (++F3, U3 >= 65536) {
        var l3 = U3 - 65536;
        B3 += String.fromCharCode(55296 | l3 >> 10, 56320 | 1023 & l3);
      } else
        B3 += String.fromCharCode(U3);
    }
    return B3;
  }, FA = (A3, Q3, F3) => {
    if (F3 ?? (F3 = 2147483647), F3 < 4)
      return 0;
    for (var B3 = Q3, U3 = B3 + F3 - 4, l3 = 0; l3 < A3.length; ++l3) {
      var t3 = A3.charCodeAt(l3);
      if (t3 >= 55296 && t3 <= 57343 && (t3 = 65536 + ((1023 & t3) << 10) | 1023 & A3.charCodeAt(++l3)), a2[Q3 >> 2] = t3, (Q3 += 4) + 4 > U3)
        break;
    }
    return a2[Q3 >> 2] = 0, Q3 - B3;
  }, BA = (A3) => {
    for (var Q3 = 0, F3 = 0; F3 < A3.length; ++F3) {
      var B3 = A3.charCodeAt(F3);
      B3 >= 55296 && B3 <= 57343 && ++F3, Q3 += 4;
    }
    return Q3;
  }, UA = (A3) => {
    var Q3 = (A3 - d2.buffer.byteLength + 65535) / 65536;
    try {
      return d2.grow(Q3), C2(), 1;
    } catch (A4) {
    }
  };
  (() => {
    for (var A3 = new Array(256), Q3 = 0; Q3 < 256; ++Q3)
      A3[Q3] = String.fromCharCode(Q3);
    p = A3;
  })(), S = B2.BindingError = class extends Error {
    constructor(A3) {
      super(A3), this.name = "BindingError";
    }
  }, B2.InternalError = class extends Error {
    constructor(A3) {
      super(A3), this.name = "InternalError";
    }
  }, Object.assign(w.prototype, { get(A3) {
    return this.allocated[A3];
  }, has(A3) {
    return void 0 !== this.allocated[A3];
  }, allocate(A3) {
    var Q3 = this.freelist.pop() || this.allocated.length;
    return this.allocated[Q3] = A3, Q3;
  }, free(A3) {
    this.allocated[A3] = void 0, this.freelist.push(A3);
  } }), x.allocated.push({ value: void 0 }, { value: null }, { value: true }, { value: false }), x.reserved = x.allocated.length, B2.count_emval_handles = f;
  var lA = { f: (A3, Q3, F3, B3, U3) => {
  }, i: (A3, Q3, F3, B3) => {
    H(A3, { name: Q3 = k(Q3), fromWireType: function(A4) {
      return !!A4;
    }, toWireType: function(A4, Q4) {
      return Q4 ? F3 : B3;
    }, argPackAdvance: 8, readValueFromPointer: function(A4) {
      return this.fromWireType(e2[A4]);
    }, destructorFunction: null });
  }, h: (A3, Q3) => {
    H(A3, { name: Q3 = k(Q3), fromWireType: (A4) => {
      var Q4 = M(A4);
      return ((A5) => {
        A5 >= x.reserved && 0 == --x.get(A5).refcount && x.free(A5);
      })(A4), Q4;
    }, toWireType: (A4, Q4) => z(Q4), argPackAdvance: 8, readValueFromPointer: v, destructorFunction: null });
  }, e: (A3, Q3, F3) => {
    H(A3, { name: Q3 = k(Q3), fromWireType: (A4) => A4, toWireType: (A4, Q4) => Q4, argPackAdvance: 8, readValueFromPointer: K(Q3, F3), destructorFunction: null });
  }, b: (A3, Q3, F3, B3, U3) => {
    Q3 = k(Q3);
    var l3 = (A4) => A4;
    if (0 === B3) {
      var t3 = 32 - 8 * F3;
      l3 = (A4) => A4 << t3 >>> t3;
    }
    var d3 = Q3.includes("unsigned");
    H(A3, { name: Q3, fromWireType: l3, toWireType: d3 ? function(A4, Q4) {
      return this.name, Q4 >>> 0;
    } : function(A4, Q4) {
      return this.name, Q4;
    }, argPackAdvance: 8, readValueFromPointer: j(Q3, F3, 0 !== B3), destructorFunction: null });
  }, a: (A3, Q3, F3) => {
    var B3 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][Q3];
    function U3(A4) {
      var Q4 = g2[A4 >> 2], F4 = g2[A4 + 4 >> 2];
      return new B3(Z2.buffer, F4, Q4);
    }
    H(A3, { name: F3 = k(F3), fromWireType: U3, argPackAdvance: 8, readValueFromPointer: U3 }, { ignoreDuplicateRegistrations: true });
  }, d: (A3, Q3) => {
    var F3 = "std::string" === (Q3 = k(Q3));
    H(A3, { name: Q3, fromWireType(A4) {
      var Q4, B3 = g2[A4 >> 2], U3 = A4 + 4;
      if (F3)
        for (var l3 = U3, t3 = 0; t3 <= B3; ++t3) {
          var d3 = U3 + t3;
          if (t3 == B3 || 0 == e2[d3]) {
            var n3 = P(l3, d3 - l3);
            void 0 === Q4 ? Q4 = n3 : (Q4 += String.fromCharCode(0), Q4 += n3), l3 = d3 + 1;
          }
        }
      else {
        var V3 = new Array(B3);
        for (t3 = 0; t3 < B3; ++t3)
          V3[t3] = String.fromCharCode(e2[U3 + t3]);
        Q4 = V3.join("");
      }
      return VA(A4), Q4;
    }, toWireType(A4, Q4) {
      var B3;
      Q4 instanceof ArrayBuffer && (Q4 = new Uint8Array(Q4));
      var U3 = "string" == typeof Q4;
      U3 || Q4 instanceof Uint8Array || Q4 instanceof Uint8ClampedArray || Q4 instanceof Int8Array || D("Cannot pass non-string to std::string"), B3 = F3 && U3 ? ((A5) => {
        for (var Q5 = 0, F4 = 0; F4 < A5.length; ++F4) {
          var B4 = A5.charCodeAt(F4);
          B4 <= 127 ? Q5++ : B4 <= 2047 ? Q5 += 2 : B4 >= 55296 && B4 <= 57343 ? (Q5 += 4, ++F4) : Q5 += 3;
        }
        return Q5;
      })(Q4) : Q4.length;
      var l3 = nA(4 + B3 + 1), t3 = l3 + 4;
      if (g2[l3 >> 2] = B3, F3 && U3)
        ((A5, Q5, F4, B4) => {
          if (!(B4 > 0))
            return 0;
          for (var U4 = F4 + B4 - 1, l4 = 0; l4 < A5.length; ++l4) {
            var t4 = A5.charCodeAt(l4);
            if (t4 >= 55296 && t4 <= 57343 && (t4 = 65536 + ((1023 & t4) << 10) | 1023 & A5.charCodeAt(++l4)), t4 <= 127) {
              if (F4 >= U4)
                break;
              Q5[F4++] = t4;
            } else if (t4 <= 2047) {
              if (F4 + 1 >= U4)
                break;
              Q5[F4++] = 192 | t4 >> 6, Q5[F4++] = 128 | 63 & t4;
            } else if (t4 <= 65535) {
              if (F4 + 2 >= U4)
                break;
              Q5[F4++] = 224 | t4 >> 12, Q5[F4++] = 128 | t4 >> 6 & 63, Q5[F4++] = 128 | 63 & t4;
            } else {
              if (F4 + 3 >= U4)
                break;
              Q5[F4++] = 240 | t4 >> 18, Q5[F4++] = 128 | t4 >> 12 & 63, Q5[F4++] = 128 | t4 >> 6 & 63, Q5[F4++] = 128 | 63 & t4;
            }
          }
          Q5[F4] = 0;
        })(Q4, e2, t3, B3 + 1);
      else if (U3)
        for (var d3 = 0; d3 < B3; ++d3) {
          var n3 = Q4.charCodeAt(d3);
          n3 > 255 && (VA(t3), D("String has UTF-16 code units that do not fit in 8 bits")), e2[t3 + d3] = n3;
        }
      else
        for (d3 = 0; d3 < B3; ++d3)
          e2[t3 + d3] = Q4[d3];
      return null !== A4 && A4.push(VA, l3), l3;
    }, argPackAdvance: 8, readValueFromPointer: O, destructorFunction(A4) {
      VA(A4);
    } });
  }, c: (A3, Q3, F3) => {
    var B3, U3, l3, t3, d3;
    F3 = k(F3), 2 === Q3 ? (B3 = q, U3 = $, t3 = AA, l3 = () => R2, d3 = 1) : 4 === Q3 && (B3 = QA, U3 = FA, t3 = BA, l3 = () => g2, d3 = 2), H(A3, { name: F3, fromWireType: (A4) => {
      for (var F4, U4 = g2[A4 >> 2], t4 = l3(), n3 = A4 + 4, V3 = 0; V3 <= U4; ++V3) {
        var Z3 = A4 + 4 + V3 * Q3;
        if (V3 == U4 || 0 == t4[Z3 >> d3]) {
          var e3 = B3(n3, Z3 - n3);
          void 0 === F4 ? F4 = e3 : (F4 += String.fromCharCode(0), F4 += e3), n3 = Z3 + Q3;
        }
      }
      return VA(A4), F4;
    }, toWireType: (A4, B4) => {
      "string" != typeof B4 && D(`Cannot pass non-string to C++ string type ${F3}`);
      var l4 = t3(B4), n3 = nA(4 + l4 + Q3);
      return g2[n3 >> 2] = l4 >> d3, U3(B4, n3 + 4, l4 + Q3), null !== A4 && A4.push(VA, n3), n3;
    }, argPackAdvance: 8, readValueFromPointer: v, destructorFunction(A4) {
      VA(A4);
    } });
  }, j: (A3, Q3) => {
    H(A3, { isVoid: true, name: Q3 = k(Q3), argPackAdvance: 0, fromWireType: () => {
    }, toWireType: (A4, Q4) => {
    } });
  }, g: (A3) => {
    var Q3 = e2.length, F3 = 2147483648;
    if ((A3 >>>= 0) > F3)
      return false;
    for (var B3, U3, l3 = 1; l3 <= 4; l3 *= 2) {
      var t3 = Q3 * (1 + 0.2 / l3);
      t3 = Math.min(t3, A3 + 100663296);
      var d3 = Math.min(F3, (B3 = Math.max(A3, t3)) + ((U3 = 65536) - B3 % U3) % U3);
      if (UA(d3))
        return true;
    }
    return false;
  } }, tA = function() {
    var _a;
    var A3 = { a: lA };
    function Q3(A4, Q4) {
      var F3;
      return tA = A4.exports, d2 = tA.k, C2(), F3 = tA.l, s2.unshift(F3), function(A5) {
        var _a2;
        if (J2--, (_a2 = B2.monitorRunDependencies) == null ? void 0 : _a2.call(B2, J2), 0 == J2 && b2) {
          var Q5 = b2;
          b2 = null, Q5();
        }
      }(), tA;
    }
    if (J2++, (_a = B2.monitorRunDependencies) == null ? void 0 : _a.call(B2, J2), B2.instantiateWasm)
      try {
        return B2.instantiateWasm(A3, Q3);
      } catch (A4) {
        n2(`Module.instantiateWasm callback failed with error: ${A4}`), F2(A4);
      }
    return Y2(0, E2, A3, function(A4) {
      Q3(A4.instance);
    }).catch(F2), {};
  }();
  B2._evaluate = (A3, Q3, F3, U3, l3, t3, d3, n3, V3, Z3, e3, I3, R3) => (B2._evaluate = tA.m)(A3, Q3, F3, U3, l3, t3, d3, n3, V3, Z3, e3, I3, R3);
  var dA, nA = B2._malloc = (A3) => (nA = B2._malloc = tA.o)(A3), VA = B2._free = (A3) => (VA = B2._free = tA.p)(A3);
  function ZA() {
    function A3() {
      dA || (dA = true, B2.calledRun = true, c2 || (y2(s2), Q2(B2), B2.onRuntimeInitialized && B2.onRuntimeInitialized(), function() {
        if (B2.postRun)
          for ("function" == typeof B2.postRun && (B2.postRun = [B2.postRun]); B2.postRun.length; )
            A4 = B2.postRun.shift(), o2.unshift(A4);
        var A4;
        y2(o2);
      }()));
    }
    J2 > 0 || (function() {
      if (B2.preRun)
        for ("function" == typeof B2.preRun && (B2.preRun = [B2.preRun]); B2.preRun.length; )
          A4 = B2.preRun.shift(), h2.unshift(A4);
      var A4;
      y2(h2);
    }(), J2 > 0 || (B2.setStatus ? (B2.setStatus("Running..."), setTimeout(function() {
      setTimeout(function() {
        B2.setStatus("");
      }, 1), A3();
    }, 1)) : A3()));
  }
  if (b2 = function A3() {
    dA || ZA(), dA || (b2 = A3);
  }, B2.preInit)
    for ("function" == typeof B2.preInit && (B2.preInit = [B2.preInit]); B2.preInit.length > 0; )
      B2.preInit.pop()();
  return ZA(), A2.ready;
};
var y = class {
  constructor(A2) {
    let Q2;
    (async () => {
      Q2 = await Y();
    })();
    let F2, B2, U2, l2, t2, d2, n2, V2, Z2, e2, I2, R2 = 0, a2 = 0;
    this.testPoint = (g2, i2) => {
      if (!Q2)
        throw new Error("Wasm module not loaded");
      if (!A2.camera)
        throw new Error("Camera not set");
      if (!A2.renderData || !A2.depthIndex || !A2.chunks)
        throw new Error("Render data not set");
      const W2 = A2.renderData, c2 = A2.depthIndex, C2 = A2.chunks, h2 = Math.pow(2, Math.ceil(Math.log2(W2.vertexCount)));
      var s2;
      (s2 = h2) > R2 && (R2 > 0 && (Q2._free(F2), Q2._free(U2), Q2._free(l2), Q2._free(t2), Q2._free(d2), Q2._free(n2), Q2._free(V2), Q2._free(Z2), Q2._free(e2), Q2._free(I2)), R2 = s2, F2 = Q2._malloc(64), U2 = Q2._malloc(4 * R2), l2 = Q2._malloc(3 * R2 * 4), t2 = Q2._malloc(4 * R2 * 4), d2 = Q2._malloc(3 * R2 * 4), n2 = Q2._malloc(4 * R2), V2 = Q2._malloc(R2), Z2 = Q2._malloc(12), e2 = Q2._malloc(12), I2 = Q2._malloc(4));
      const o2 = Math.pow(2, Math.ceil(Math.log2(W2.transforms.length / 20)));
      var J2;
      (J2 = o2) > a2 && (a2 > 0 && Q2._free(B2), a2 = J2, B2 = Q2._malloc(20 * a2 * 4));
      const b2 = (g2 + 1) / 2, r2 = (i2 + 1) / 2, E2 = Math.floor(15 * b2) + 15 * Math.floor(15 * r2), m2 = A2.camera, N2 = m2.screenPointToRay(g2, i2);
      Q2.HEAPF32.set(m2.data.viewMatrix.buffer, F2 / 4), Q2.HEAPU32.set(W2.transformIndices, U2 / 4), Q2.HEAPF32.set(W2.positions, l2 / 4), Q2.HEAPF32.set(W2.rotations, t2 / 4), Q2.HEAPF32.set(W2.scales, d2 / 4), Q2.HEAPU32.set(c2, n2 / 4), Q2.HEAPU8.set(C2, V2), Q2.HEAPF32.set(m2.position.flat(), Z2 / 4), Q2.HEAPF32.set(N2.flat(), e2 / 4), Q2.HEAPF32.set(W2.transforms, B2 / 4), Q2._evaluate(F2, B2, U2, l2, t2, d2, n2, V2, W2.vertexCount, E2, Z2, e2, I2);
      const G2 = Q2.HEAPU32[I2 / 4];
      if (4294967295 !== G2) {
        return W2.getSplat(G2);
      }
      return null;
    };
  }
};
export {
  R as Camera,
  e as CameraData,
  b as Color32,
  E as FadeInPass,
  y as IntersectionTester,
  g as Loader,
  n as Matrix3,
  B as Matrix4,
  d as Object3D,
  N as OrbitControls,
  i as PLYLoader,
  G as Plane,
  Q as Quaternion,
  J as RenderData,
  r as RenderProgram,
  a as Scene,
  X as ShaderPass,
  h as ShaderProgram,
  Z as Splat,
  V as SplatData,
  A as Vector3,
  I as Vector4,
  m as WebGLRenderer
};
//# sourceMappingURL=gsplat.js.map
